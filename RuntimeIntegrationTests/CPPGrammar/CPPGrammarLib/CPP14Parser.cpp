
// Generated from D:\Programming\antlr4\RuntimeIntegrationTests\CPPGrammar\CPPGrammarLib\CPP14.g4 by ANTLR 4.7.2


#include "CPP14Listener.h"
#include "CPP14Visitor.h"

#include "CPP14Parser.h"


using namespace antlrcpp;
using namespace antlr4;

CPP14Parser::CPP14Parser(TokenStream *input) : Parser(input)
{
	setInterpreter(std::make_unique<atn::ParserATNSimulator>(this, _atn, _decisionToDFA, _sharedContextCache));
}

std::string CPP14Parser::getGrammarFileName() const
{
	return "CPP14.g4";
}

const std::vector<std::string_view>& CPP14Parser::getRuleNames() const
{
	return _ruleNames;
}

dfa::Vocabulary& CPP14Parser::getVocabulary() const
{
	return _vocabulary;
}


//----------------- TranslationunitContext ------------------------------------------------------------------

CPP14Parser::TranslationunitContext::TranslationunitContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::TranslationunitContext::EOF()
{
	return getToken(CPP14Parser::EOF, 0);
}

CPP14Parser::DeclarationseqContext* CPP14Parser::TranslationunitContext::declarationseq()
{
	return getRuleContext<CPP14Parser::DeclarationseqContext>(0);//1165
}


size_t CPP14Parser::TranslationunitContext::getRuleIndex() const
{
	return CPP14Parser::RuleTranslationunit;//688
}

void CPP14Parser::TranslationunitContext::copyFrom(TranslationunitContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::TranslationunitContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<TranslationunitContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::TranslationunitContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::TranslationunitContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::TranslationunitContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitTranslationunit(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::TranslationunitContext* CPP14Parser::translationunit( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<TranslationunitContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 0, CPP14Parser::RuleTranslationunit);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(407);//848
		_errHandler->sync(this, ctx);

		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 0, ctx))
		{
		case 1:
		{
			setState(406); //951
			declarationseq(ctx);
			break;
		}

		}
		setState(409);//958
		match(CPP14Parser::EOF,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::TranslationunitContext> CPP14Parser::parsetranslationunit()
{
	translationunit();
	auto result = std::unique_ptr<TranslationunitContext>(dynamic_cast<TranslationunitContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- PrimaryexpressionContext ------------------------------------------------------------------

CPP14Parser::PrimaryexpressionContext::PrimaryexpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::LiteralContext* CPP14Parser::PrimaryexpressionContext::literal()
{
	return getRuleContext<CPP14Parser::LiteralContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::PrimaryexpressionContext::This()
{
	return getToken(CPP14Parser::This, 0);
}

tree::TerminalNode* CPP14Parser::PrimaryexpressionContext::LeftParen()
{
	return getToken(CPP14Parser::LeftParen, 0);
}

CPP14Parser::ExpressionContext* CPP14Parser::PrimaryexpressionContext::expression()
{
	return getRuleContext<CPP14Parser::ExpressionContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::PrimaryexpressionContext::RightParen()
{
	return getToken(CPP14Parser::RightParen, 0);
}

CPP14Parser::IdexpressionContext* CPP14Parser::PrimaryexpressionContext::idexpression()
{
	return getRuleContext<CPP14Parser::IdexpressionContext>(0);//1165
}

CPP14Parser::LambdaexpressionContext* CPP14Parser::PrimaryexpressionContext::lambdaexpression()
{
	return getRuleContext<CPP14Parser::LambdaexpressionContext>(0);//1165
}


size_t CPP14Parser::PrimaryexpressionContext::getRuleIndex() const
{
	return CPP14Parser::RulePrimaryexpression;//688
}

void CPP14Parser::PrimaryexpressionContext::copyFrom(PrimaryexpressionContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::PrimaryexpressionContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<PrimaryexpressionContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::PrimaryexpressionContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::PrimaryexpressionContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::PrimaryexpressionContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitPrimaryexpression(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::PrimaryexpressionContext* CPP14Parser::primaryexpression( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<PrimaryexpressionContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 2, CPP14Parser::RulePrimaryexpression);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(419);//750
		_errHandler->sync(this, ctx);
		switch (_input->LA(1))
		{
			case CPP14Parser::False:
			case CPP14Parser::Nullptr:
			case CPP14Parser::True:
			case CPP14Parser::Integerliteral:
			case CPP14Parser::Characterliteral:
			case CPP14Parser::Floatingliteral:
			case CPP14Parser::Stringliteral:
			case CPP14Parser::Userdefinedintegerliteral:
			case CPP14Parser::Userdefinedfloatingliteral:
			case CPP14Parser::Userdefinedstringliteral:
			case CPP14Parser::Userdefinedcharacterliteral:
			{
				enterOuterAlt(ctx, 1);
				setState(411); //951
				literal(ctx);
				break;
			}

			case CPP14Parser::This:
			{
				enterOuterAlt(ctx, 2);
				setState(412);//958
				match(CPP14Parser::This,ctx);
				break;
			}

			case CPP14Parser::LeftParen:
			{
				enterOuterAlt(ctx, 3);
				setState(413);//958
				match(CPP14Parser::LeftParen,ctx);
				setState(414); //951
				expression(0,ctx);
				setState(415);//958
				match(CPP14Parser::RightParen,ctx);
				break;
			}

			case CPP14Parser::Decltype:
			case CPP14Parser::Operator:
			case CPP14Parser::Tilde:
			case CPP14Parser::Doublecolon:
			case CPP14Parser::Identifier:
			{
				enterOuterAlt(ctx, 4);
				setState(417); //951
				idexpression(ctx);
				break;
			}

			case CPP14Parser::LeftBracket:
			{
				enterOuterAlt(ctx, 5);
				setState(418); //951
				lambdaexpression(ctx);
				break;
			}

		default:
			throw NoViableAltException(this, ctx);
		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::PrimaryexpressionContext> CPP14Parser::parseprimaryexpression()
{
	primaryexpression();
	auto result = std::unique_ptr<PrimaryexpressionContext>(dynamic_cast<PrimaryexpressionContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- IdexpressionContext ------------------------------------------------------------------

CPP14Parser::IdexpressionContext::IdexpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::UnqualifiedidContext* CPP14Parser::IdexpressionContext::unqualifiedid()
{
	return getRuleContext<CPP14Parser::UnqualifiedidContext>(0);//1165
}

CPP14Parser::QualifiedidContext* CPP14Parser::IdexpressionContext::qualifiedid()
{
	return getRuleContext<CPP14Parser::QualifiedidContext>(0);//1165
}


size_t CPP14Parser::IdexpressionContext::getRuleIndex() const
{
	return CPP14Parser::RuleIdexpression;//688
}

void CPP14Parser::IdexpressionContext::copyFrom(IdexpressionContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::IdexpressionContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<IdexpressionContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::IdexpressionContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::IdexpressionContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::IdexpressionContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitIdexpression(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::IdexpressionContext* CPP14Parser::idexpression( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<IdexpressionContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 4, CPP14Parser::RuleIdexpression);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(423);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 2, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(421); //951
			unqualifiedid(ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(422); //951
			qualifiedid(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::IdexpressionContext> CPP14Parser::parseidexpression()
{
	idexpression();
	auto result = std::unique_ptr<IdexpressionContext>(dynamic_cast<IdexpressionContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- UnqualifiedidContext ------------------------------------------------------------------

CPP14Parser::UnqualifiedidContext::UnqualifiedidContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::UnqualifiedidContext::Identifier()
{
	return getToken(CPP14Parser::Identifier, 0);
}

CPP14Parser::OperatorfunctionidContext* CPP14Parser::UnqualifiedidContext::operatorfunctionid()
{
	return getRuleContext<CPP14Parser::OperatorfunctionidContext>(0);//1165
}

CPP14Parser::ConversionfunctionidContext* CPP14Parser::UnqualifiedidContext::conversionfunctionid()
{
	return getRuleContext<CPP14Parser::ConversionfunctionidContext>(0);//1165
}

CPP14Parser::LiteraloperatoridContext* CPP14Parser::UnqualifiedidContext::literaloperatorid()
{
	return getRuleContext<CPP14Parser::LiteraloperatoridContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::UnqualifiedidContext::Tilde()
{
	return getToken(CPP14Parser::Tilde, 0);
}

CPP14Parser::ClassnameContext* CPP14Parser::UnqualifiedidContext::classname()
{
	return getRuleContext<CPP14Parser::ClassnameContext>(0);//1165
}

CPP14Parser::DecltypespecifierContext* CPP14Parser::UnqualifiedidContext::decltypespecifier()
{
	return getRuleContext<CPP14Parser::DecltypespecifierContext>(0);//1165
}

CPP14Parser::TemplateidContext* CPP14Parser::UnqualifiedidContext::templateid()
{
	return getRuleContext<CPP14Parser::TemplateidContext>(0);//1165
}


size_t CPP14Parser::UnqualifiedidContext::getRuleIndex() const
{
	return CPP14Parser::RuleUnqualifiedid;//688
}

void CPP14Parser::UnqualifiedidContext::copyFrom(UnqualifiedidContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::UnqualifiedidContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<UnqualifiedidContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::UnqualifiedidContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::UnqualifiedidContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::UnqualifiedidContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitUnqualifiedid(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::UnqualifiedidContext* CPP14Parser::unqualifiedid( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<UnqualifiedidContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 6, CPP14Parser::RuleUnqualifiedid);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(434);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(425);//958
			match(CPP14Parser::Identifier,ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(426); //951
			operatorfunctionid(ctx);
			break;
		}

		case 3:
		{
			enterOuterAlt(ctx, 3);
			setState(427); //951
			conversionfunctionid(ctx);
			break;
		}

		case 4:
		{
			enterOuterAlt(ctx, 4);
			setState(428); //951
			literaloperatorid(ctx);
			break;
		}

		case 5:
		{
			enterOuterAlt(ctx, 5);
			setState(429);//958
			match(CPP14Parser::Tilde,ctx);
			setState(430); //951
			classname(ctx);
			break;
		}

		case 6:
		{
			enterOuterAlt(ctx, 6);
			setState(431);//958
			match(CPP14Parser::Tilde,ctx);
			setState(432); //951
			decltypespecifier(ctx);
			break;
		}

		case 7:
		{
			enterOuterAlt(ctx, 7);
			setState(433); //951
			templateid(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::UnqualifiedidContext> CPP14Parser::parseunqualifiedid()
{
	unqualifiedid();
	auto result = std::unique_ptr<UnqualifiedidContext>(dynamic_cast<UnqualifiedidContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- QualifiedidContext ------------------------------------------------------------------

CPP14Parser::QualifiedidContext::QualifiedidContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::NestednamespecifierContext* CPP14Parser::QualifiedidContext::nestednamespecifier()
{
	return getRuleContext<CPP14Parser::NestednamespecifierContext>(0);//1165
}

CPP14Parser::UnqualifiedidContext* CPP14Parser::QualifiedidContext::unqualifiedid()
{
	return getRuleContext<CPP14Parser::UnqualifiedidContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::QualifiedidContext::Template()
{
	return getToken(CPP14Parser::Template, 0);
}


size_t CPP14Parser::QualifiedidContext::getRuleIndex() const
{
	return CPP14Parser::RuleQualifiedid;//688
}

void CPP14Parser::QualifiedidContext::copyFrom(QualifiedidContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::QualifiedidContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<QualifiedidContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::QualifiedidContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::QualifiedidContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::QualifiedidContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitQualifiedid(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::QualifiedidContext* CPP14Parser::qualifiedid( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<QualifiedidContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 8, CPP14Parser::RuleQualifiedid);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(436); //951
		nestednamespecifier(0,ctx);
		setState(438);//788
		_errHandler->sync(this, ctx);

		_la = _input->LA(1);
		if (_la == CPP14Parser::Template)
		{
			setState(437);//958
			match(CPP14Parser::Template,ctx);
		}
		setState(440); //951
		unqualifiedid(ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::QualifiedidContext> CPP14Parser::parsequalifiedid()
{
	qualifiedid();
	auto result = std::unique_ptr<QualifiedidContext>(dynamic_cast<QualifiedidContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- NestednamespecifierContext ------------------------------------------------------------------

CPP14Parser::NestednamespecifierContext::NestednamespecifierContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::NestednamespecifierContext::Doublecolon()
{
	return getToken(CPP14Parser::Doublecolon, 0);
}

CPP14Parser::ThetypenameContext* CPP14Parser::NestednamespecifierContext::thetypename()
{
	return getRuleContext<CPP14Parser::ThetypenameContext>(0);//1165
}

CPP14Parser::NamespacenameContext* CPP14Parser::NestednamespecifierContext::namespacename()
{
	return getRuleContext<CPP14Parser::NamespacenameContext>(0);//1165
}

CPP14Parser::DecltypespecifierContext* CPP14Parser::NestednamespecifierContext::decltypespecifier()
{
	return getRuleContext<CPP14Parser::DecltypespecifierContext>(0);//1165
}

CPP14Parser::NestednamespecifierContext* CPP14Parser::NestednamespecifierContext::nestednamespecifier()
{
	return getRuleContext<CPP14Parser::NestednamespecifierContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::NestednamespecifierContext::Identifier()
{
	return getToken(CPP14Parser::Identifier, 0);
}

CPP14Parser::SimpletemplateidContext* CPP14Parser::NestednamespecifierContext::simpletemplateid()
{
	return getRuleContext<CPP14Parser::SimpletemplateidContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::NestednamespecifierContext::Template()
{
	return getToken(CPP14Parser::Template, 0);
}


size_t CPP14Parser::NestednamespecifierContext::getRuleIndex() const
{
	return CPP14Parser::RuleNestednamespecifier;//688
}

void CPP14Parser::NestednamespecifierContext::copyFrom(NestednamespecifierContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::NestednamespecifierContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<NestednamespecifierContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::NestednamespecifierContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::NestednamespecifierContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::NestednamespecifierContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitNestednamespecifier(this);
	else
		return visitor->visitChildren(this);
}


CPP14Parser::NestednamespecifierContext* CPP14Parser::nestednamespecifier()
{
	 return nestednamespecifier(0, nullptr);//600
}

CPP14Parser::NestednamespecifierContext* CPP14Parser::nestednamespecifier(int precedence, antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	antlr4::ParserRuleContext *parentContext = parent;
	size_t parentState = getState();
	auto _localctx = std::make_unique<NestednamespecifierContext>(parentContext, parentState);//610
	auto ctx = _localctx.get();//609
	size_t startState = 10;
	enterRecursionRule(ctx, 10, CPP14Parser::RuleNestednamespecifier, precedence);

		size_t _la = 0;

	auto onExit = finally([=,&_localctx]
{
		unrollRecursionContexts(parentContext, std::move(_localctx));
	});
	try
{
		size_t alt;
		enterOuterAlt(ctx, 1);
		setState(453);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 5, ctx))
		{
		case 1:
		{
			setState(443);//958
			match(CPP14Parser::Doublecolon,ctx);
			break;
		}

		case 2:
		{
			setState(444); //951
			thetypename(ctx);
			setState(445);//958
			match(CPP14Parser::Doublecolon,ctx);
			break;
		}

		case 3:
		{
			setState(447); //951
			namespacename(ctx);
			setState(448);//958
			match(CPP14Parser::Doublecolon,ctx);
			break;
		}

		case 4:
		{
			setState(450); //951
			decltypespecifier(ctx);
			setState(451);//958
			match(CPP14Parser::Doublecolon,ctx);
			break;
		}

		}
		ctx->stop = _input->LT(-1);
		setState(467);//865
		_errHandler->sync(this, ctx);
		alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, ctx);
		while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
		{
			if (alt == 1)
		{
				if (!_parseListeners.empty())
					triggerExitRuleEvent(ctx);

				setState(465);//830
				_errHandler->sync(this, ctx);
				switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 7, ctx))
				{
				case 1:
				{
					auto tmpContext = std::make_unique<NestednamespecifierContext>(parentContext, parentState);
					pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleNestednamespecifier);//1240
					_localctx = std::move(tmpContext);
					ctx = _localctx.get();
					setState(455);//1002

					if (!(precpred(nullptr, 2))) throw FailedPredicateException(this, "precpred(nullptr, 2)", ctx);
					setState(456);//958
					match(CPP14Parser::Identifier,ctx);
					setState(457);//958
					match(CPP14Parser::Doublecolon,ctx);
					break;
				}

				case 2:
				{
					auto tmpContext = std::make_unique<NestednamespecifierContext>(parentContext, parentState);
					pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleNestednamespecifier);//1240
					_localctx = std::move(tmpContext);
					ctx = _localctx.get();
					setState(458);//1002

					if (!(precpred(nullptr, 1))) throw FailedPredicateException(this, "precpred(nullptr, 1)", ctx);
					setState(460);//788
					_errHandler->sync(this, ctx);

					_la = _input->LA(1);
					if (_la == CPP14Parser::Template)
					{
						setState(459);//958
						match(CPP14Parser::Template,ctx);
					}
					setState(462); //951
					simpletemplateid(ctx);
					setState(463);//958
					match(CPP14Parser::Doublecolon,ctx);
					break;
				}

				} 
			}
			setState(469);//875
			_errHandler->sync(this, ctx);
			alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, ctx);
		}
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		_localctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}
	onExit();
	return ctx;
}

std::unique_ptr< CPP14Parser::NestednamespecifierContext> CPP14Parser::parsenestednamespecifier()
{
	nestednamespecifier();
	auto result = std::unique_ptr<NestednamespecifierContext>(dynamic_cast<NestednamespecifierContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}

//----------------- LambdaexpressionContext ------------------------------------------------------------------

CPP14Parser::LambdaexpressionContext::LambdaexpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::LambdaintroducerContext* CPP14Parser::LambdaexpressionContext::lambdaintroducer()
{
	return getRuleContext<CPP14Parser::LambdaintroducerContext>(0);//1165
}

CPP14Parser::CompoundstatementContext* CPP14Parser::LambdaexpressionContext::compoundstatement()
{
	return getRuleContext<CPP14Parser::CompoundstatementContext>(0);//1165
}

CPP14Parser::LambdadeclaratorContext* CPP14Parser::LambdaexpressionContext::lambdadeclarator()
{
	return getRuleContext<CPP14Parser::LambdadeclaratorContext>(0);//1165
}


size_t CPP14Parser::LambdaexpressionContext::getRuleIndex() const
{
	return CPP14Parser::RuleLambdaexpression;//688
}

void CPP14Parser::LambdaexpressionContext::copyFrom(LambdaexpressionContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::LambdaexpressionContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<LambdaexpressionContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::LambdaexpressionContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::LambdaexpressionContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::LambdaexpressionContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitLambdaexpression(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::LambdaexpressionContext* CPP14Parser::lambdaexpression( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<LambdaexpressionContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 12, CPP14Parser::RuleLambdaexpression);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(470); //951
		lambdaintroducer(ctx);
		setState(472);//788
		_errHandler->sync(this, ctx);

		_la = _input->LA(1);
		if (_la == CPP14Parser::LeftParen)
		{
			setState(471); //951
			lambdadeclarator(ctx);
		}
		setState(474); //951
		compoundstatement(ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::LambdaexpressionContext> CPP14Parser::parselambdaexpression()
{
	lambdaexpression();
	auto result = std::unique_ptr<LambdaexpressionContext>(dynamic_cast<LambdaexpressionContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- LambdaintroducerContext ------------------------------------------------------------------

CPP14Parser::LambdaintroducerContext::LambdaintroducerContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::LambdaintroducerContext::LeftBracket()
{
	return getToken(CPP14Parser::LeftBracket, 0);
}

tree::TerminalNode* CPP14Parser::LambdaintroducerContext::RightBracket()
{
	return getToken(CPP14Parser::RightBracket, 0);
}

CPP14Parser::LambdacaptureContext* CPP14Parser::LambdaintroducerContext::lambdacapture()
{
	return getRuleContext<CPP14Parser::LambdacaptureContext>(0);//1165
}


size_t CPP14Parser::LambdaintroducerContext::getRuleIndex() const
{
	return CPP14Parser::RuleLambdaintroducer;//688
}

void CPP14Parser::LambdaintroducerContext::copyFrom(LambdaintroducerContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::LambdaintroducerContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<LambdaintroducerContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::LambdaintroducerContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::LambdaintroducerContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::LambdaintroducerContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitLambdaintroducer(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::LambdaintroducerContext* CPP14Parser::lambdaintroducer( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<LambdaintroducerContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 14, CPP14Parser::RuleLambdaintroducer);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(476);//958
		match(CPP14Parser::LeftBracket,ctx);
		setState(478);//788
		_errHandler->sync(this, ctx);

		_la = _input->LA(1);
		if (((((_la - 68) & ~ 0x3fULL) == 0) &&
			((1ULL << (_la - 68)) & ((1ULL << (CPP14Parser::This - 68))
			| (1ULL << (CPP14Parser::And - 68))
			| (1ULL << (CPP14Parser::Assign - 68))
			| (1ULL << (CPP14Parser::Identifier - 68)))) != 0))
		{
			setState(477); //951
			lambdacapture(ctx);
		}
		setState(480);//958
		match(CPP14Parser::RightBracket,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::LambdaintroducerContext> CPP14Parser::parselambdaintroducer()
{
	lambdaintroducer();
	auto result = std::unique_ptr<LambdaintroducerContext>(dynamic_cast<LambdaintroducerContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- LambdacaptureContext ------------------------------------------------------------------

CPP14Parser::LambdacaptureContext::LambdacaptureContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::CapturedefaultContext* CPP14Parser::LambdacaptureContext::capturedefault()
{
	return getRuleContext<CPP14Parser::CapturedefaultContext>(0);//1165
}

CPP14Parser::CapturelistContext* CPP14Parser::LambdacaptureContext::capturelist()
{
	return getRuleContext<CPP14Parser::CapturelistContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::LambdacaptureContext::Comma()
{
	return getToken(CPP14Parser::Comma, 0);
}


size_t CPP14Parser::LambdacaptureContext::getRuleIndex() const
{
	return CPP14Parser::RuleLambdacapture;//688
}

void CPP14Parser::LambdacaptureContext::copyFrom(LambdacaptureContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::LambdacaptureContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<LambdacaptureContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::LambdacaptureContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::LambdacaptureContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::LambdacaptureContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitLambdacapture(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::LambdacaptureContext* CPP14Parser::lambdacapture( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<LambdacaptureContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 16, CPP14Parser::RuleLambdacapture);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(488);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(482); //951
			capturedefault(ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(483); //951
			capturelist(0,ctx);
			break;
		}

		case 3:
		{
			enterOuterAlt(ctx, 3);
			setState(484); //951
			capturedefault(ctx);
			setState(485);//958
			match(CPP14Parser::Comma,ctx);
			setState(486); //951
			capturelist(0,ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::LambdacaptureContext> CPP14Parser::parselambdacapture()
{
	lambdacapture();
	auto result = std::unique_ptr<LambdacaptureContext>(dynamic_cast<LambdacaptureContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- CapturedefaultContext ------------------------------------------------------------------

CPP14Parser::CapturedefaultContext::CapturedefaultContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::CapturedefaultContext::And()
{
	return getToken(CPP14Parser::And, 0);
}

tree::TerminalNode* CPP14Parser::CapturedefaultContext::Assign()
{
	return getToken(CPP14Parser::Assign, 0);
}


size_t CPP14Parser::CapturedefaultContext::getRuleIndex() const
{
	return CPP14Parser::RuleCapturedefault;//688
}

void CPP14Parser::CapturedefaultContext::copyFrom(CapturedefaultContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::CapturedefaultContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<CapturedefaultContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::CapturedefaultContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::CapturedefaultContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::CapturedefaultContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitCapturedefault(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::CapturedefaultContext* CPP14Parser::capturedefault( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<CapturedefaultContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 18, CPP14Parser::RuleCapturedefault);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(490);//970
		_la = _input->LA(1);
		if (!(_la == CPP14Parser::And

		|| _la == CPP14Parser::Assign))
		{
		_errHandler->recoverInline(this, ctx);
		}
		else
		{
			_errHandler->reportMatch(this);
			consume(ctx);
		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::CapturedefaultContext> CPP14Parser::parsecapturedefault()
{
	capturedefault();
	auto result = std::unique_ptr<CapturedefaultContext>(dynamic_cast<CapturedefaultContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- CapturelistContext ------------------------------------------------------------------

CPP14Parser::CapturelistContext::CapturelistContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::CaptureContext* CPP14Parser::CapturelistContext::capture()
{
	return getRuleContext<CPP14Parser::CaptureContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::CapturelistContext::Ellipsis()
{
	return getToken(CPP14Parser::Ellipsis, 0);
}

CPP14Parser::CapturelistContext* CPP14Parser::CapturelistContext::capturelist()
{
	return getRuleContext<CPP14Parser::CapturelistContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::CapturelistContext::Comma()
{
	return getToken(CPP14Parser::Comma, 0);
}


size_t CPP14Parser::CapturelistContext::getRuleIndex() const
{
	return CPP14Parser::RuleCapturelist;//688
}

void CPP14Parser::CapturelistContext::copyFrom(CapturelistContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::CapturelistContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<CapturelistContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::CapturelistContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::CapturelistContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::CapturelistContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitCapturelist(this);
	else
		return visitor->visitChildren(this);
}


CPP14Parser::CapturelistContext* CPP14Parser::capturelist()
{
	 return capturelist(0, nullptr);//600
}

CPP14Parser::CapturelistContext* CPP14Parser::capturelist(int precedence, antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	antlr4::ParserRuleContext *parentContext = parent;
	size_t parentState = getState();
	auto _localctx = std::make_unique<CapturelistContext>(parentContext, parentState);//610
	auto ctx = _localctx.get();//609
	size_t startState = 20;
	enterRecursionRule(ctx, 20, CPP14Parser::RuleCapturelist, precedence);

		

	auto onExit = finally([=,&_localctx]
{
		unrollRecursionContexts(parentContext, std::move(_localctx));
	});
	try
{
		size_t alt;
		enterOuterAlt(ctx, 1);
		setState(493); //951
		capture(ctx);
		setState(495);//848
		_errHandler->sync(this, ctx);

		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 12, ctx))
		{
		case 1:
		{
			setState(494);//958
			match(CPP14Parser::Ellipsis,ctx);
			break;
		}

		}
		ctx->stop = _input->LT(-1);
		setState(505);//865
		_errHandler->sync(this, ctx);
		alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, ctx);
		while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
		{
			if (alt == 1)
		{
				if (!_parseListeners.empty())
					triggerExitRuleEvent(ctx);

				auto tmpContext = std::make_unique<CapturelistContext>(parentContext, parentState);
				pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleCapturelist);//1240
				_localctx = std::move(tmpContext);
				ctx = _localctx.get();
				setState(497);//1002

				if (!(precpred(nullptr, 1))) throw FailedPredicateException(this, "precpred(nullptr, 1)", ctx);
				setState(498);//958
				match(CPP14Parser::Comma,ctx);
				setState(499); //951
				capture(ctx);
				setState(501);//848
				_errHandler->sync(this, ctx);

				switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, ctx))
				{
				case 1:
				{
					setState(500);//958
					match(CPP14Parser::Ellipsis,ctx);
					break;
				}

				} 
			}
			setState(507);//875
			_errHandler->sync(this, ctx);
			alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, ctx);
		}
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		_localctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}
	onExit();
	return ctx;
}

std::unique_ptr< CPP14Parser::CapturelistContext> CPP14Parser::parsecapturelist()
{
	capturelist();
	auto result = std::unique_ptr<CapturelistContext>(dynamic_cast<CapturelistContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}

//----------------- CaptureContext ------------------------------------------------------------------

CPP14Parser::CaptureContext::CaptureContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::SimplecaptureContext* CPP14Parser::CaptureContext::simplecapture()
{
	return getRuleContext<CPP14Parser::SimplecaptureContext>(0);//1165
}

CPP14Parser::InitcaptureContext* CPP14Parser::CaptureContext::initcapture()
{
	return getRuleContext<CPP14Parser::InitcaptureContext>(0);//1165
}


size_t CPP14Parser::CaptureContext::getRuleIndex() const
{
	return CPP14Parser::RuleCapture;//688
}

void CPP14Parser::CaptureContext::copyFrom(CaptureContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::CaptureContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<CaptureContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::CaptureContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::CaptureContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::CaptureContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitCapture(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::CaptureContext* CPP14Parser::capture( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<CaptureContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 22, CPP14Parser::RuleCapture);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(510);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(508); //951
			simplecapture(ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(509); //951
			initcapture(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::CaptureContext> CPP14Parser::parsecapture()
{
	capture();
	auto result = std::unique_ptr<CaptureContext>(dynamic_cast<CaptureContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- SimplecaptureContext ------------------------------------------------------------------

CPP14Parser::SimplecaptureContext::SimplecaptureContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::SimplecaptureContext::Identifier()
{
	return getToken(CPP14Parser::Identifier, 0);
}

tree::TerminalNode* CPP14Parser::SimplecaptureContext::And()
{
	return getToken(CPP14Parser::And, 0);
}

tree::TerminalNode* CPP14Parser::SimplecaptureContext::This()
{
	return getToken(CPP14Parser::This, 0);
}


size_t CPP14Parser::SimplecaptureContext::getRuleIndex() const
{
	return CPP14Parser::RuleSimplecapture;//688
}

void CPP14Parser::SimplecaptureContext::copyFrom(SimplecaptureContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::SimplecaptureContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<SimplecaptureContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::SimplecaptureContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::SimplecaptureContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::SimplecaptureContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitSimplecapture(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::SimplecaptureContext* CPP14Parser::simplecapture( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<SimplecaptureContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 24, CPP14Parser::RuleSimplecapture);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(516);//750
		_errHandler->sync(this, ctx);
		switch (_input->LA(1))
		{
			case CPP14Parser::Identifier:
			{
				enterOuterAlt(ctx, 1);
				setState(512);//958
				match(CPP14Parser::Identifier,ctx);
				break;
			}

			case CPP14Parser::And:
			{
				enterOuterAlt(ctx, 2);
				setState(513);//958
				match(CPP14Parser::And,ctx);
				setState(514);//958
				match(CPP14Parser::Identifier,ctx);
				break;
			}

			case CPP14Parser::This:
			{
				enterOuterAlt(ctx, 3);
				setState(515);//958
				match(CPP14Parser::This,ctx);
				break;
			}

		default:
			throw NoViableAltException(this, ctx);
		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::SimplecaptureContext> CPP14Parser::parsesimplecapture()
{
	simplecapture();
	auto result = std::unique_ptr<SimplecaptureContext>(dynamic_cast<SimplecaptureContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- InitcaptureContext ------------------------------------------------------------------

CPP14Parser::InitcaptureContext::InitcaptureContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::InitcaptureContext::Identifier()
{
	return getToken(CPP14Parser::Identifier, 0);
}

CPP14Parser::InitializerContext* CPP14Parser::InitcaptureContext::initializer()
{
	return getRuleContext<CPP14Parser::InitializerContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::InitcaptureContext::And()
{
	return getToken(CPP14Parser::And, 0);
}


size_t CPP14Parser::InitcaptureContext::getRuleIndex() const
{
	return CPP14Parser::RuleInitcapture;//688
}

void CPP14Parser::InitcaptureContext::copyFrom(InitcaptureContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::InitcaptureContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<InitcaptureContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::InitcaptureContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::InitcaptureContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::InitcaptureContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitInitcapture(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::InitcaptureContext* CPP14Parser::initcapture( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<InitcaptureContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 26, CPP14Parser::RuleInitcapture);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(523);//750
		_errHandler->sync(this, ctx);
		switch (_input->LA(1))
		{
			case CPP14Parser::Identifier:
			{
				enterOuterAlt(ctx, 1);
				setState(518);//958
				match(CPP14Parser::Identifier,ctx);
				setState(519); //951
				initializer(ctx);
				break;
			}

			case CPP14Parser::And:
			{
				enterOuterAlt(ctx, 2);
				setState(520);//958
				match(CPP14Parser::And,ctx);
				setState(521);//958
				match(CPP14Parser::Identifier,ctx);
				setState(522); //951
				initializer(ctx);
				break;
			}

		default:
			throw NoViableAltException(this, ctx);
		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::InitcaptureContext> CPP14Parser::parseinitcapture()
{
	initcapture();
	auto result = std::unique_ptr<InitcaptureContext>(dynamic_cast<InitcaptureContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- LambdadeclaratorContext ------------------------------------------------------------------

CPP14Parser::LambdadeclaratorContext::LambdadeclaratorContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::LambdadeclaratorContext::LeftParen()
{
	return getToken(CPP14Parser::LeftParen, 0);
}

CPP14Parser::ParameterdeclarationclauseContext* CPP14Parser::LambdadeclaratorContext::parameterdeclarationclause()
{
	return getRuleContext<CPP14Parser::ParameterdeclarationclauseContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::LambdadeclaratorContext::RightParen()
{
	return getToken(CPP14Parser::RightParen, 0);
}

tree::TerminalNode* CPP14Parser::LambdadeclaratorContext::Mutable()
{
	return getToken(CPP14Parser::Mutable, 0);
}

CPP14Parser::ExceptionspecificationContext* CPP14Parser::LambdadeclaratorContext::exceptionspecification()
{
	return getRuleContext<CPP14Parser::ExceptionspecificationContext>(0);//1165
}

CPP14Parser::AttributespecifierseqContext* CPP14Parser::LambdadeclaratorContext::attributespecifierseq()
{
	return getRuleContext<CPP14Parser::AttributespecifierseqContext>(0);//1165
}

CPP14Parser::TrailingreturntypeContext* CPP14Parser::LambdadeclaratorContext::trailingreturntype()
{
	return getRuleContext<CPP14Parser::TrailingreturntypeContext>(0);//1165
}


size_t CPP14Parser::LambdadeclaratorContext::getRuleIndex() const
{
	return CPP14Parser::RuleLambdadeclarator;//688
}

void CPP14Parser::LambdadeclaratorContext::copyFrom(LambdadeclaratorContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::LambdadeclaratorContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<LambdadeclaratorContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::LambdadeclaratorContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::LambdadeclaratorContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::LambdadeclaratorContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitLambdadeclarator(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::LambdadeclaratorContext* CPP14Parser::lambdadeclarator( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<LambdadeclaratorContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 28, CPP14Parser::RuleLambdadeclarator);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(525);//958
		match(CPP14Parser::LeftParen,ctx);
		setState(526); //951
		parameterdeclarationclause(ctx);
		setState(527);//958
		match(CPP14Parser::RightParen,ctx);
		setState(529);//788
		_errHandler->sync(this, ctx);

		_la = _input->LA(1);
		if (_la == CPP14Parser::Mutable)
		{
			setState(528);//958
			match(CPP14Parser::Mutable,ctx);
		}
		setState(532);//788
		_errHandler->sync(this, ctx);

		_la = _input->LA(1);
		if (_la == CPP14Parser::Noexcept

		|| _la == CPP14Parser::Throw)
		{
			setState(531); //951
			exceptionspecification(ctx);
		}
		setState(535);//788
		_errHandler->sync(this, ctx);

		_la = _input->LA(1);
		if (_la == CPP14Parser::Alignas || _la == CPP14Parser::LeftBracket)
		{
			setState(534); //951
			attributespecifierseq(0,ctx);
		}
		setState(538);//788
		_errHandler->sync(this, ctx);

		_la = _input->LA(1);
		if (_la == CPP14Parser::Arrow)
		{
			setState(537); //951
			trailingreturntype(ctx);
		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::LambdadeclaratorContext> CPP14Parser::parselambdadeclarator()
{
	lambdadeclarator();
	auto result = std::unique_ptr<LambdadeclaratorContext>(dynamic_cast<LambdadeclaratorContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- PostfixexpressionContext ------------------------------------------------------------------

CPP14Parser::PostfixexpressionContext::PostfixexpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::PrimaryexpressionContext* CPP14Parser::PostfixexpressionContext::primaryexpression()
{
	return getRuleContext<CPP14Parser::PrimaryexpressionContext>(0);//1165
}

CPP14Parser::SimpletypespecifierContext* CPP14Parser::PostfixexpressionContext::simpletypespecifier()
{
	return getRuleContext<CPP14Parser::SimpletypespecifierContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::PostfixexpressionContext::LeftParen()
{
	return getToken(CPP14Parser::LeftParen, 0);
}

tree::TerminalNode* CPP14Parser::PostfixexpressionContext::RightParen()
{
	return getToken(CPP14Parser::RightParen, 0);
}

CPP14Parser::ExpressionlistContext* CPP14Parser::PostfixexpressionContext::expressionlist()
{
	return getRuleContext<CPP14Parser::ExpressionlistContext>(0);//1165
}

CPP14Parser::TypenamespecifierContext* CPP14Parser::PostfixexpressionContext::typenamespecifier()
{
	return getRuleContext<CPP14Parser::TypenamespecifierContext>(0);//1165
}

CPP14Parser::BracedinitlistContext* CPP14Parser::PostfixexpressionContext::bracedinitlist()
{
	return getRuleContext<CPP14Parser::BracedinitlistContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::PostfixexpressionContext::Dynamic_cast()
{
	return getToken(CPP14Parser::Dynamic_cast, 0);
}

tree::TerminalNode* CPP14Parser::PostfixexpressionContext::Less()
{
	return getToken(CPP14Parser::Less, 0);
}

CPP14Parser::ThetypeidContext* CPP14Parser::PostfixexpressionContext::thetypeid()
{
	return getRuleContext<CPP14Parser::ThetypeidContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::PostfixexpressionContext::GreaterThan()
{
	return getToken(CPP14Parser::GreaterThan, 0);
}

CPP14Parser::ExpressionContext* CPP14Parser::PostfixexpressionContext::expression()
{
	return getRuleContext<CPP14Parser::ExpressionContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::PostfixexpressionContext::Static_cast()
{
	return getToken(CPP14Parser::Static_cast, 0);
}

tree::TerminalNode* CPP14Parser::PostfixexpressionContext::Reinterpret_cast()
{
	return getToken(CPP14Parser::Reinterpret_cast, 0);
}

tree::TerminalNode* CPP14Parser::PostfixexpressionContext::Const_cast()
{
	return getToken(CPP14Parser::Const_cast, 0);
}

CPP14Parser::TypeidofthetypeidContext* CPP14Parser::PostfixexpressionContext::typeidofthetypeid()
{
	return getRuleContext<CPP14Parser::TypeidofthetypeidContext>(0);//1165
}

CPP14Parser::PostfixexpressionContext* CPP14Parser::PostfixexpressionContext::postfixexpression()
{
	return getRuleContext<CPP14Parser::PostfixexpressionContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::PostfixexpressionContext::LeftBracket()
{
	return getToken(CPP14Parser::LeftBracket, 0);
}

tree::TerminalNode* CPP14Parser::PostfixexpressionContext::RightBracket()
{
	return getToken(CPP14Parser::RightBracket, 0);
}

tree::TerminalNode* CPP14Parser::PostfixexpressionContext::Dot()
{
	return getToken(CPP14Parser::Dot, 0);
}

CPP14Parser::IdexpressionContext* CPP14Parser::PostfixexpressionContext::idexpression()
{
	return getRuleContext<CPP14Parser::IdexpressionContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::PostfixexpressionContext::Template()
{
	return getToken(CPP14Parser::Template, 0);
}

tree::TerminalNode* CPP14Parser::PostfixexpressionContext::Arrow()
{
	return getToken(CPP14Parser::Arrow, 0);
}

CPP14Parser::PseudodestructornameContext* CPP14Parser::PostfixexpressionContext::pseudodestructorname()
{
	return getRuleContext<CPP14Parser::PseudodestructornameContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::PostfixexpressionContext::PlusPlus()
{
	return getToken(CPP14Parser::PlusPlus, 0);
}

tree::TerminalNode* CPP14Parser::PostfixexpressionContext::MinusMinus()
{
	return getToken(CPP14Parser::MinusMinus, 0);
}


size_t CPP14Parser::PostfixexpressionContext::getRuleIndex() const
{
	return CPP14Parser::RulePostfixexpression;//688
}

void CPP14Parser::PostfixexpressionContext::copyFrom(PostfixexpressionContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::PostfixexpressionContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<PostfixexpressionContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::PostfixexpressionContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::PostfixexpressionContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::PostfixexpressionContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitPostfixexpression(this);
	else
		return visitor->visitChildren(this);
}


CPP14Parser::PostfixexpressionContext* CPP14Parser::postfixexpression()
{
	 return postfixexpression(0, nullptr);//600
}

CPP14Parser::PostfixexpressionContext* CPP14Parser::postfixexpression(int precedence, antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	antlr4::ParserRuleContext *parentContext = parent;
	size_t parentState = getState();
	auto _localctx = std::make_unique<PostfixexpressionContext>(parentContext, parentState);//610
	auto ctx = _localctx.get();//609
	size_t startState = 30;
	enterRecursionRule(ctx, 30, CPP14Parser::RulePostfixexpression, precedence);

		size_t _la = 0;

	auto onExit = finally([=,&_localctx]
{
		unrollRecursionContexts(parentContext, std::move(_localctx));
	});
	try
{
		size_t alt;
		enterOuterAlt(ctx, 1);
		setState(604);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 24, ctx))
		{
		case 1:
		{
			setState(541); //951
			primaryexpression(ctx);
			break;
		}

		case 2:
		{
			setState(542); //951
			simpletypespecifier(ctx);
			setState(543);//958
			match(CPP14Parser::LeftParen,ctx);
			setState(545);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if ((((_la & ~ 0x3fULL) == 0) &&
				((1ULL << _la) & ((1ULL << CPP14Parser::T__0)
				| (1ULL << CPP14Parser::T__1)
				| (1ULL << CPP14Parser::Alignof)
				| (1ULL << CPP14Parser::Auto)
				| (1ULL << CPP14Parser::Bool)
				| (1ULL << CPP14Parser::Char)
				| (1ULL << CPP14Parser::Char16)
				| (1ULL << CPP14Parser::Char32)
				| (1ULL << CPP14Parser::Const_cast)
				| (1ULL << CPP14Parser::Decltype)
				| (1ULL << CPP14Parser::Delete)
				| (1ULL << CPP14Parser::Double)
				| (1ULL << CPP14Parser::Dynamic_cast)
				| (1ULL << CPP14Parser::False)
				| (1ULL << CPP14Parser::Float)
				| (1ULL << CPP14Parser::Int)
				| (1ULL << CPP14Parser::Long)
				| (1ULL << CPP14Parser::New)
				| (1ULL << CPP14Parser::Noexcept)
				| (1ULL << CPP14Parser::Nullptr)
				| (1ULL << CPP14Parser::Operator)
				| (1ULL << CPP14Parser::Reinterpret_cast)
				| (1ULL << CPP14Parser::Short)
				| (1ULL << CPP14Parser::Signed)
				| (1ULL << CPP14Parser::Sizeof))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
				((1ULL << (_la - 64)) & ((1ULL << (CPP14Parser::Static_cast - 64))
				| (1ULL << (CPP14Parser::This - 64))
				| (1ULL << (CPP14Parser::Throw - 64))
				| (1ULL << (CPP14Parser::True - 64))
				| (1ULL << (CPP14Parser::Typeid_ - 64))
				| (1ULL << (CPP14Parser::Typename_ - 64))
				| (1ULL << (CPP14Parser::Unsigned - 64))
				| (1ULL << (CPP14Parser::Void - 64))
				| (1ULL << (CPP14Parser::Wchar - 64))
				| (1ULL << (CPP14Parser::LeftParen - 64))
				| (1ULL << (CPP14Parser::LeftBracket - 64))
				| (1ULL << (CPP14Parser::LeftBrace - 64))
				| (1ULL << (CPP14Parser::Plus - 64))
				| (1ULL << (CPP14Parser::Minus - 64))
				| (1ULL << (CPP14Parser::Star - 64))
				| (1ULL << (CPP14Parser::And - 64))
				| (1ULL << (CPP14Parser::Or - 64))
				| (1ULL << (CPP14Parser::Tilde - 64))
				| (1ULL << (CPP14Parser::PlusPlus - 64))
				| (1ULL << (CPP14Parser::MinusMinus - 64))
				| (1ULL << (CPP14Parser::Doublecolon - 64)))) != 0) || ((((_la - 130) & ~ 0x3fULL) == 0) &&
				((1ULL << (_la - 130)) & ((1ULL << (CPP14Parser::Identifier - 130))
				| (1ULL << (CPP14Parser::Integerliteral - 130))
				| (1ULL << (CPP14Parser::Characterliteral - 130))
				| (1ULL << (CPP14Parser::Floatingliteral - 130))
				| (1ULL << (CPP14Parser::Stringliteral - 130))
				| (1ULL << (CPP14Parser::Userdefinedintegerliteral - 130))
				| (1ULL << (CPP14Parser::Userdefinedfloatingliteral - 130))
				| (1ULL << (CPP14Parser::Userdefinedstringliteral - 130))
				| (1ULL << (CPP14Parser::Userdefinedcharacterliteral - 130)))) != 0))
			{
				setState(544); //951
				expressionlist(ctx);
			}
			setState(547);//958
			match(CPP14Parser::RightParen,ctx);
			break;
		}

		case 3:
		{
			setState(549); //951
			typenamespecifier(ctx);
			setState(550);//958
			match(CPP14Parser::LeftParen,ctx);
			setState(552);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if ((((_la & ~ 0x3fULL) == 0) &&
				((1ULL << _la) & ((1ULL << CPP14Parser::T__0)
				| (1ULL << CPP14Parser::T__1)
				| (1ULL << CPP14Parser::Alignof)
				| (1ULL << CPP14Parser::Auto)
				| (1ULL << CPP14Parser::Bool)
				| (1ULL << CPP14Parser::Char)
				| (1ULL << CPP14Parser::Char16)
				| (1ULL << CPP14Parser::Char32)
				| (1ULL << CPP14Parser::Const_cast)
				| (1ULL << CPP14Parser::Decltype)
				| (1ULL << CPP14Parser::Delete)
				| (1ULL << CPP14Parser::Double)
				| (1ULL << CPP14Parser::Dynamic_cast)
				| (1ULL << CPP14Parser::False)
				| (1ULL << CPP14Parser::Float)
				| (1ULL << CPP14Parser::Int)
				| (1ULL << CPP14Parser::Long)
				| (1ULL << CPP14Parser::New)
				| (1ULL << CPP14Parser::Noexcept)
				| (1ULL << CPP14Parser::Nullptr)
				| (1ULL << CPP14Parser::Operator)
				| (1ULL << CPP14Parser::Reinterpret_cast)
				| (1ULL << CPP14Parser::Short)
				| (1ULL << CPP14Parser::Signed)
				| (1ULL << CPP14Parser::Sizeof))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
				((1ULL << (_la - 64)) & ((1ULL << (CPP14Parser::Static_cast - 64))
				| (1ULL << (CPP14Parser::This - 64))
				| (1ULL << (CPP14Parser::Throw - 64))
				| (1ULL << (CPP14Parser::True - 64))
				| (1ULL << (CPP14Parser::Typeid_ - 64))
				| (1ULL << (CPP14Parser::Typename_ - 64))
				| (1ULL << (CPP14Parser::Unsigned - 64))
				| (1ULL << (CPP14Parser::Void - 64))
				| (1ULL << (CPP14Parser::Wchar - 64))
				| (1ULL << (CPP14Parser::LeftParen - 64))
				| (1ULL << (CPP14Parser::LeftBracket - 64))
				| (1ULL << (CPP14Parser::LeftBrace - 64))
				| (1ULL << (CPP14Parser::Plus - 64))
				| (1ULL << (CPP14Parser::Minus - 64))
				| (1ULL << (CPP14Parser::Star - 64))
				| (1ULL << (CPP14Parser::And - 64))
				| (1ULL << (CPP14Parser::Or - 64))
				| (1ULL << (CPP14Parser::Tilde - 64))
				| (1ULL << (CPP14Parser::PlusPlus - 64))
				| (1ULL << (CPP14Parser::MinusMinus - 64))
				| (1ULL << (CPP14Parser::Doublecolon - 64)))) != 0) || ((((_la - 130) & ~ 0x3fULL) == 0) &&
				((1ULL << (_la - 130)) & ((1ULL << (CPP14Parser::Identifier - 130))
				| (1ULL << (CPP14Parser::Integerliteral - 130))
				| (1ULL << (CPP14Parser::Characterliteral - 130))
				| (1ULL << (CPP14Parser::Floatingliteral - 130))
				| (1ULL << (CPP14Parser::Stringliteral - 130))
				| (1ULL << (CPP14Parser::Userdefinedintegerliteral - 130))
				| (1ULL << (CPP14Parser::Userdefinedfloatingliteral - 130))
				| (1ULL << (CPP14Parser::Userdefinedstringliteral - 130))
				| (1ULL << (CPP14Parser::Userdefinedcharacterliteral - 130)))) != 0))
			{
				setState(551); //951
				expressionlist(ctx);
			}
			setState(554);//958
			match(CPP14Parser::RightParen,ctx);
			break;
		}

		case 4:
		{
			setState(556); //951
			simpletypespecifier(ctx);
			setState(557); //951
			bracedinitlist(ctx);
			break;
		}

		case 5:
		{
			setState(559); //951
			typenamespecifier(ctx);
			setState(560); //951
			bracedinitlist(ctx);
			break;
		}

		case 6:
		{
			setState(562);//958
			match(CPP14Parser::Dynamic_cast,ctx);
			setState(563);//958
			match(CPP14Parser::Less,ctx);
			setState(564); //951
			thetypeid(ctx);
			setState(565);//958
			match(CPP14Parser::GreaterThan,ctx);
			setState(566);//958
			match(CPP14Parser::LeftParen,ctx);
			setState(567); //951
			expression(0,ctx);
			setState(568);//958
			match(CPP14Parser::RightParen,ctx);
			break;
		}

		case 7:
		{
			setState(570);//958
			match(CPP14Parser::Static_cast,ctx);
			setState(571);//958
			match(CPP14Parser::Less,ctx);
			setState(572); //951
			thetypeid(ctx);
			setState(573);//958
			match(CPP14Parser::GreaterThan,ctx);
			setState(574);//958
			match(CPP14Parser::LeftParen,ctx);
			setState(575); //951
			expression(0,ctx);
			setState(576);//958
			match(CPP14Parser::RightParen,ctx);
			break;
		}

		case 8:
		{
			setState(578);//958
			match(CPP14Parser::Reinterpret_cast,ctx);
			setState(579);//958
			match(CPP14Parser::Less,ctx);
			setState(580); //951
			thetypeid(ctx);
			setState(581);//958
			match(CPP14Parser::GreaterThan,ctx);
			setState(582);//958
			match(CPP14Parser::LeftParen,ctx);
			setState(583); //951
			expression(0,ctx);
			setState(584);//958
			match(CPP14Parser::RightParen,ctx);
			break;
		}

		case 9:
		{
			setState(586);//958
			match(CPP14Parser::Const_cast,ctx);
			setState(587);//958
			match(CPP14Parser::Less,ctx);
			setState(588); //951
			thetypeid(ctx);
			setState(589);//958
			match(CPP14Parser::GreaterThan,ctx);
			setState(590);//958
			match(CPP14Parser::LeftParen,ctx);
			setState(591); //951
			expression(0,ctx);
			setState(592);//958
			match(CPP14Parser::RightParen,ctx);
			break;
		}

		case 10:
		{
			setState(594); //951
			typeidofthetypeid(ctx);
			setState(595);//958
			match(CPP14Parser::LeftParen,ctx);
			setState(596); //951
			expression(0,ctx);
			setState(597);//958
			match(CPP14Parser::RightParen,ctx);
			break;
		}

		case 11:
		{
			setState(599); //951
			typeidofthetypeid(ctx);
			setState(600);//958
			match(CPP14Parser::LeftParen,ctx);
			setState(601); //951
			thetypeid(ctx);
			setState(602);//958
			match(CPP14Parser::RightParen,ctx);
			break;
		}

		}
		ctx->stop = _input->LT(-1);
		setState(646);//865
		_errHandler->sync(this, ctx);
		alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, ctx);
		while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
		{
			if (alt == 1)
		{
				if (!_parseListeners.empty())
					triggerExitRuleEvent(ctx);

				setState(644);//830
				_errHandler->sync(this, ctx);
				switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 28, ctx))
				{
				case 1:
				{
					auto tmpContext = std::make_unique<PostfixexpressionContext>(parentContext, parentState);
					pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RulePostfixexpression);//1240
					_localctx = std::move(tmpContext);
					ctx = _localctx.get();
					setState(606);//1002

					if (!(precpred(nullptr, 19))) throw FailedPredicateException(this, "precpred(nullptr, 19)", ctx);
					setState(607);//958
					match(CPP14Parser::LeftBracket,ctx);
					setState(608); //951
					expression(0,ctx);
					setState(609);//958
					match(CPP14Parser::RightBracket,ctx);
					break;
				}

				case 2:
				{
					auto tmpContext = std::make_unique<PostfixexpressionContext>(parentContext, parentState);
					pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RulePostfixexpression);//1240
					_localctx = std::move(tmpContext);
					ctx = _localctx.get();
					setState(611);//1002

					if (!(precpred(nullptr, 18))) throw FailedPredicateException(this, "precpred(nullptr, 18)", ctx);
					setState(612);//958
					match(CPP14Parser::LeftBracket,ctx);
					setState(613); //951
					bracedinitlist(ctx);
					setState(614);//958
					match(CPP14Parser::RightBracket,ctx);
					break;
				}

				case 3:
				{
					auto tmpContext = std::make_unique<PostfixexpressionContext>(parentContext, parentState);
					pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RulePostfixexpression);//1240
					_localctx = std::move(tmpContext);
					ctx = _localctx.get();
					setState(616);//1002

					if (!(precpred(nullptr, 17))) throw FailedPredicateException(this, "precpred(nullptr, 17)", ctx);
					setState(617);//958
					match(CPP14Parser::LeftParen,ctx);
					setState(619);//788
					_errHandler->sync(this, ctx);

					_la = _input->LA(1);
					if ((((_la & ~ 0x3fULL) == 0) &&
						((1ULL << _la) & ((1ULL << CPP14Parser::T__0)
						| (1ULL << CPP14Parser::T__1)
						| (1ULL << CPP14Parser::Alignof)
						| (1ULL << CPP14Parser::Auto)
						| (1ULL << CPP14Parser::Bool)
						| (1ULL << CPP14Parser::Char)
						| (1ULL << CPP14Parser::Char16)
						| (1ULL << CPP14Parser::Char32)
						| (1ULL << CPP14Parser::Const_cast)
						| (1ULL << CPP14Parser::Decltype)
						| (1ULL << CPP14Parser::Delete)
						| (1ULL << CPP14Parser::Double)
						| (1ULL << CPP14Parser::Dynamic_cast)
						| (1ULL << CPP14Parser::False)
						| (1ULL << CPP14Parser::Float)
						| (1ULL << CPP14Parser::Int)
						| (1ULL << CPP14Parser::Long)
						| (1ULL << CPP14Parser::New)
						| (1ULL << CPP14Parser::Noexcept)
						| (1ULL << CPP14Parser::Nullptr)
						| (1ULL << CPP14Parser::Operator)
						| (1ULL << CPP14Parser::Reinterpret_cast)
						| (1ULL << CPP14Parser::Short)
						| (1ULL << CPP14Parser::Signed)
						| (1ULL << CPP14Parser::Sizeof))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
						((1ULL << (_la - 64)) & ((1ULL << (CPP14Parser::Static_cast - 64))
						| (1ULL << (CPP14Parser::This - 64))
						| (1ULL << (CPP14Parser::Throw - 64))
						| (1ULL << (CPP14Parser::True - 64))
						| (1ULL << (CPP14Parser::Typeid_ - 64))
						| (1ULL << (CPP14Parser::Typename_ - 64))
						| (1ULL << (CPP14Parser::Unsigned - 64))
						| (1ULL << (CPP14Parser::Void - 64))
						| (1ULL << (CPP14Parser::Wchar - 64))
						| (1ULL << (CPP14Parser::LeftParen - 64))
						| (1ULL << (CPP14Parser::LeftBracket - 64))
						| (1ULL << (CPP14Parser::LeftBrace - 64))
						| (1ULL << (CPP14Parser::Plus - 64))
						| (1ULL << (CPP14Parser::Minus - 64))
						| (1ULL << (CPP14Parser::Star - 64))
						| (1ULL << (CPP14Parser::And - 64))
						| (1ULL << (CPP14Parser::Or - 64))
						| (1ULL << (CPP14Parser::Tilde - 64))
						| (1ULL << (CPP14Parser::PlusPlus - 64))
						| (1ULL << (CPP14Parser::MinusMinus - 64))
						| (1ULL << (CPP14Parser::Doublecolon - 64)))) != 0) || ((((_la - 130) & ~ 0x3fULL) == 0) &&
						((1ULL << (_la - 130)) & ((1ULL << (CPP14Parser::Identifier - 130))
						| (1ULL << (CPP14Parser::Integerliteral - 130))
						| (1ULL << (CPP14Parser::Characterliteral - 130))
						| (1ULL << (CPP14Parser::Floatingliteral - 130))
						| (1ULL << (CPP14Parser::Stringliteral - 130))
						| (1ULL << (CPP14Parser::Userdefinedintegerliteral - 130))
						| (1ULL << (CPP14Parser::Userdefinedfloatingliteral - 130))
						| (1ULL << (CPP14Parser::Userdefinedstringliteral - 130))
						| (1ULL << (CPP14Parser::Userdefinedcharacterliteral - 130)))) != 0))
					{
						setState(618); //951
						expressionlist(ctx);
					}
					setState(621);//958
					match(CPP14Parser::RightParen,ctx);
					break;
				}

				case 4:
				{
					auto tmpContext = std::make_unique<PostfixexpressionContext>(parentContext, parentState);
					pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RulePostfixexpression);//1240
					_localctx = std::move(tmpContext);
					ctx = _localctx.get();
					setState(622);//1002

					if (!(precpred(nullptr, 12))) throw FailedPredicateException(this, "precpred(nullptr, 12)", ctx);
					setState(623);//958
					match(CPP14Parser::Dot,ctx);
					setState(625);//788
					_errHandler->sync(this, ctx);

					_la = _input->LA(1);
					if (_la == CPP14Parser::Template)
					{
						setState(624);//958
						match(CPP14Parser::Template,ctx);
					}
					setState(627); //951
					idexpression(ctx);
					break;
				}

				case 5:
				{
					auto tmpContext = std::make_unique<PostfixexpressionContext>(parentContext, parentState);
					pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RulePostfixexpression);//1240
					_localctx = std::move(tmpContext);
					ctx = _localctx.get();
					setState(628);//1002

					if (!(precpred(nullptr, 11))) throw FailedPredicateException(this, "precpred(nullptr, 11)", ctx);
					setState(629);//958
					match(CPP14Parser::Arrow,ctx);
					setState(631);//788
					_errHandler->sync(this, ctx);

					_la = _input->LA(1);
					if (_la == CPP14Parser::Template)
					{
						setState(630);//958
						match(CPP14Parser::Template,ctx);
					}
					setState(633); //951
					idexpression(ctx);
					break;
				}

				case 6:
				{
					auto tmpContext = std::make_unique<PostfixexpressionContext>(parentContext, parentState);
					pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RulePostfixexpression);//1240
					_localctx = std::move(tmpContext);
					ctx = _localctx.get();
					setState(634);//1002

					if (!(precpred(nullptr, 10))) throw FailedPredicateException(this, "precpred(nullptr, 10)", ctx);
					setState(635);//958
					match(CPP14Parser::Dot,ctx);
					setState(636); //951
					pseudodestructorname(ctx);
					break;
				}

				case 7:
				{
					auto tmpContext = std::make_unique<PostfixexpressionContext>(parentContext, parentState);
					pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RulePostfixexpression);//1240
					_localctx = std::move(tmpContext);
					ctx = _localctx.get();
					setState(637);//1002

					if (!(precpred(nullptr, 9))) throw FailedPredicateException(this, "precpred(nullptr, 9)", ctx);
					setState(638);//958
					match(CPP14Parser::Arrow,ctx);
					setState(639); //951
					pseudodestructorname(ctx);
					break;
				}

				case 8:
				{
					auto tmpContext = std::make_unique<PostfixexpressionContext>(parentContext, parentState);
					pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RulePostfixexpression);//1240
					_localctx = std::move(tmpContext);
					ctx = _localctx.get();
					setState(640);//1002

					if (!(precpred(nullptr, 8))) throw FailedPredicateException(this, "precpred(nullptr, 8)", ctx);
					setState(641);//958
					match(CPP14Parser::PlusPlus,ctx);
					break;
				}

				case 9:
				{
					auto tmpContext = std::make_unique<PostfixexpressionContext>(parentContext, parentState);
					pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RulePostfixexpression);//1240
					_localctx = std::move(tmpContext);
					ctx = _localctx.get();
					setState(642);//1002

					if (!(precpred(nullptr, 7))) throw FailedPredicateException(this, "precpred(nullptr, 7)", ctx);
					setState(643);//958
					match(CPP14Parser::MinusMinus,ctx);
					break;
				}

				} 
			}
			setState(648);//875
			_errHandler->sync(this, ctx);
			alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, ctx);
		}
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		_localctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}
	onExit();
	return ctx;
}

std::unique_ptr< CPP14Parser::PostfixexpressionContext> CPP14Parser::parsepostfixexpression()
{
	postfixexpression();
	auto result = std::unique_ptr<PostfixexpressionContext>(dynamic_cast<PostfixexpressionContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}

//----------------- TypeidofexprContext ------------------------------------------------------------------

CPP14Parser::TypeidofexprContext::TypeidofexprContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::TypeidofexprContext::Typeid_()
{
	return getToken(CPP14Parser::Typeid_, 0);
}


size_t CPP14Parser::TypeidofexprContext::getRuleIndex() const
{
	return CPP14Parser::RuleTypeidofexpr;//688
}

void CPP14Parser::TypeidofexprContext::copyFrom(TypeidofexprContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::TypeidofexprContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<TypeidofexprContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::TypeidofexprContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::TypeidofexprContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::TypeidofexprContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitTypeidofexpr(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::TypeidofexprContext* CPP14Parser::typeidofexpr( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<TypeidofexprContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 32, CPP14Parser::RuleTypeidofexpr);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(649);//958
		match(CPP14Parser::Typeid_,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::TypeidofexprContext> CPP14Parser::parsetypeidofexpr()
{
	typeidofexpr();
	auto result = std::unique_ptr<TypeidofexprContext>(dynamic_cast<TypeidofexprContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- TypeidofthetypeidContext ------------------------------------------------------------------

CPP14Parser::TypeidofthetypeidContext::TypeidofthetypeidContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::TypeidofthetypeidContext::Typeid_()
{
	return getToken(CPP14Parser::Typeid_, 0);
}


size_t CPP14Parser::TypeidofthetypeidContext::getRuleIndex() const
{
	return CPP14Parser::RuleTypeidofthetypeid;//688
}

void CPP14Parser::TypeidofthetypeidContext::copyFrom(TypeidofthetypeidContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::TypeidofthetypeidContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<TypeidofthetypeidContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::TypeidofthetypeidContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::TypeidofthetypeidContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::TypeidofthetypeidContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitTypeidofthetypeid(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::TypeidofthetypeidContext* CPP14Parser::typeidofthetypeid( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<TypeidofthetypeidContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 34, CPP14Parser::RuleTypeidofthetypeid);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(651);//958
		match(CPP14Parser::Typeid_,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::TypeidofthetypeidContext> CPP14Parser::parsetypeidofthetypeid()
{
	typeidofthetypeid();
	auto result = std::unique_ptr<TypeidofthetypeidContext>(dynamic_cast<TypeidofthetypeidContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- ExpressionlistContext ------------------------------------------------------------------

CPP14Parser::ExpressionlistContext::ExpressionlistContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::InitializerlistContext* CPP14Parser::ExpressionlistContext::initializerlist()
{
	return getRuleContext<CPP14Parser::InitializerlistContext>(0);//1165
}


size_t CPP14Parser::ExpressionlistContext::getRuleIndex() const
{
	return CPP14Parser::RuleExpressionlist;//688
}

void CPP14Parser::ExpressionlistContext::copyFrom(ExpressionlistContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::ExpressionlistContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<ExpressionlistContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::ExpressionlistContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::ExpressionlistContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::ExpressionlistContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitExpressionlist(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::ExpressionlistContext* CPP14Parser::expressionlist( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<ExpressionlistContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 36, CPP14Parser::RuleExpressionlist);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(653); //951
		initializerlist(0,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::ExpressionlistContext> CPP14Parser::parseexpressionlist()
{
	expressionlist();
	auto result = std::unique_ptr<ExpressionlistContext>(dynamic_cast<ExpressionlistContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- PseudodestructornameContext ------------------------------------------------------------------

CPP14Parser::PseudodestructornameContext::PseudodestructornameContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

std::vector<CPP14Parser::ThetypenameContext *> CPP14Parser::PseudodestructornameContext::thetypename()
{
	return getRuleContexts<CPP14Parser::ThetypenameContext>();//1174
}

CPP14Parser::ThetypenameContext* CPP14Parser::PseudodestructornameContext::thetypename(size_t i)
{
	return getRuleContext<CPP14Parser::ThetypenameContext>(i);//1183
}

tree::TerminalNode* CPP14Parser::PseudodestructornameContext::Doublecolon()
{
	return getToken(CPP14Parser::Doublecolon, 0);
}

tree::TerminalNode* CPP14Parser::PseudodestructornameContext::Tilde()
{
	return getToken(CPP14Parser::Tilde, 0);
}

CPP14Parser::NestednamespecifierContext* CPP14Parser::PseudodestructornameContext::nestednamespecifier()
{
	return getRuleContext<CPP14Parser::NestednamespecifierContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::PseudodestructornameContext::Template()
{
	return getToken(CPP14Parser::Template, 0);
}

CPP14Parser::SimpletemplateidContext* CPP14Parser::PseudodestructornameContext::simpletemplateid()
{
	return getRuleContext<CPP14Parser::SimpletemplateidContext>(0);//1165
}

CPP14Parser::DecltypespecifierContext* CPP14Parser::PseudodestructornameContext::decltypespecifier()
{
	return getRuleContext<CPP14Parser::DecltypespecifierContext>(0);//1165
}


size_t CPP14Parser::PseudodestructornameContext::getRuleIndex() const
{
	return CPP14Parser::RulePseudodestructorname;//688
}

void CPP14Parser::PseudodestructornameContext::copyFrom(PseudodestructornameContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::PseudodestructornameContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<PseudodestructornameContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::PseudodestructornameContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::PseudodestructornameContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::PseudodestructornameContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitPseudodestructorname(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::PseudodestructornameContext* CPP14Parser::pseudodestructorname( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<PseudodestructornameContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 38, CPP14Parser::RulePseudodestructorname);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(677);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(656);//848
			_errHandler->sync(this, ctx);

			switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, ctx))
			{
			case 1:
			{
				setState(655); //951
				nestednamespecifier(0,ctx);
				break;
			}

			}
			setState(658); //951
			thetypename(ctx);
			setState(659);//958
			match(CPP14Parser::Doublecolon,ctx);
			setState(660);//958
			match(CPP14Parser::Tilde,ctx);
			setState(661); //951
			thetypename(ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(663); //951
			nestednamespecifier(0,ctx);
			setState(664);//958
			match(CPP14Parser::Template,ctx);
			setState(665); //951
			simpletemplateid(ctx);
			setState(666);//958
			match(CPP14Parser::Doublecolon,ctx);
			setState(667);//958
			match(CPP14Parser::Tilde,ctx);
			setState(668); //951
			thetypename(ctx);
			break;
		}

		case 3:
		{
			enterOuterAlt(ctx, 3);
			setState(671);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Decltype || _la == CPP14Parser::Doublecolon

			|| _la == CPP14Parser::Identifier)
			{
				setState(670); //951
				nestednamespecifier(0,ctx);
			}
			setState(673);//958
			match(CPP14Parser::Tilde,ctx);
			setState(674); //951
			thetypename(ctx);
			break;
		}

		case 4:
		{
			enterOuterAlt(ctx, 4);
			setState(675);//958
			match(CPP14Parser::Tilde,ctx);
			setState(676); //951
			decltypespecifier(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::PseudodestructornameContext> CPP14Parser::parsepseudodestructorname()
{
	pseudodestructorname();
	auto result = std::unique_ptr<PseudodestructornameContext>(dynamic_cast<PseudodestructornameContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- UnaryexpressionContext ------------------------------------------------------------------

CPP14Parser::UnaryexpressionContext::UnaryexpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::PostfixexpressionContext* CPP14Parser::UnaryexpressionContext::postfixexpression()
{
	return getRuleContext<CPP14Parser::PostfixexpressionContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::UnaryexpressionContext::PlusPlus()
{
	return getToken(CPP14Parser::PlusPlus, 0);
}

CPP14Parser::CastexpressionContext* CPP14Parser::UnaryexpressionContext::castexpression()
{
	return getRuleContext<CPP14Parser::CastexpressionContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::UnaryexpressionContext::MinusMinus()
{
	return getToken(CPP14Parser::MinusMinus, 0);
}

CPP14Parser::UnaryoperatorContext* CPP14Parser::UnaryexpressionContext::unaryoperator()
{
	return getRuleContext<CPP14Parser::UnaryoperatorContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::UnaryexpressionContext::Sizeof()
{
	return getToken(CPP14Parser::Sizeof, 0);
}

CPP14Parser::UnaryexpressionContext* CPP14Parser::UnaryexpressionContext::unaryexpression()
{
	return getRuleContext<CPP14Parser::UnaryexpressionContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::UnaryexpressionContext::LeftParen()
{
	return getToken(CPP14Parser::LeftParen, 0);
}

CPP14Parser::ThetypeidContext* CPP14Parser::UnaryexpressionContext::thetypeid()
{
	return getRuleContext<CPP14Parser::ThetypeidContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::UnaryexpressionContext::RightParen()
{
	return getToken(CPP14Parser::RightParen, 0);
}

tree::TerminalNode* CPP14Parser::UnaryexpressionContext::Ellipsis()
{
	return getToken(CPP14Parser::Ellipsis, 0);
}

tree::TerminalNode* CPP14Parser::UnaryexpressionContext::Identifier()
{
	return getToken(CPP14Parser::Identifier, 0);
}

tree::TerminalNode* CPP14Parser::UnaryexpressionContext::Alignof()
{
	return getToken(CPP14Parser::Alignof, 0);
}

CPP14Parser::NoexceptexpressionContext* CPP14Parser::UnaryexpressionContext::noexceptexpression()
{
	return getRuleContext<CPP14Parser::NoexceptexpressionContext>(0);//1165
}

CPP14Parser::NewexpressionContext* CPP14Parser::UnaryexpressionContext::newexpression()
{
	return getRuleContext<CPP14Parser::NewexpressionContext>(0);//1165
}

CPP14Parser::DeleteexpressionContext* CPP14Parser::UnaryexpressionContext::deleteexpression()
{
	return getRuleContext<CPP14Parser::DeleteexpressionContext>(0);//1165
}


size_t CPP14Parser::UnaryexpressionContext::getRuleIndex() const
{
	return CPP14Parser::RuleUnaryexpression;//688
}

void CPP14Parser::UnaryexpressionContext::copyFrom(UnaryexpressionContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::UnaryexpressionContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<UnaryexpressionContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::UnaryexpressionContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::UnaryexpressionContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::UnaryexpressionContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitUnaryexpression(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::UnaryexpressionContext* CPP14Parser::unaryexpression( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<UnaryexpressionContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 40, CPP14Parser::RuleUnaryexpression);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(707);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(679); //951
			postfixexpression(0,ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(680);//958
			match(CPP14Parser::PlusPlus,ctx);
			setState(681); //951
			castexpression(ctx);
			break;
		}

		case 3:
		{
			enterOuterAlt(ctx, 3);
			setState(682);//958
			match(CPP14Parser::MinusMinus,ctx);
			setState(683); //951
			castexpression(ctx);
			break;
		}

		case 4:
		{
			enterOuterAlt(ctx, 4);
			setState(684); //951
			unaryoperator(ctx);
			setState(685); //951
			castexpression(ctx);
			break;
		}

		case 5:
		{
			enterOuterAlt(ctx, 5);
			setState(687);//958
			match(CPP14Parser::Sizeof,ctx);
			setState(688); //951
			unaryexpression(ctx);
			break;
		}

		case 6:
		{
			enterOuterAlt(ctx, 6);
			setState(689);//958
			match(CPP14Parser::Sizeof,ctx);
			setState(690);//958
			match(CPP14Parser::LeftParen,ctx);
			setState(691); //951
			thetypeid(ctx);
			setState(692);//958
			match(CPP14Parser::RightParen,ctx);
			break;
		}

		case 7:
		{
			enterOuterAlt(ctx, 7);
			setState(694);//958
			match(CPP14Parser::Sizeof,ctx);
			setState(695);//958
			match(CPP14Parser::Ellipsis,ctx);
			setState(696);//958
			match(CPP14Parser::LeftParen,ctx);
			setState(697);//958
			match(CPP14Parser::Identifier,ctx);
			setState(698);//958
			match(CPP14Parser::RightParen,ctx);
			break;
		}

		case 8:
		{
			enterOuterAlt(ctx, 8);
			setState(699);//958
			match(CPP14Parser::Alignof,ctx);
			setState(700);//958
			match(CPP14Parser::LeftParen,ctx);
			setState(701); //951
			thetypeid(ctx);
			setState(702);//958
			match(CPP14Parser::RightParen,ctx);
			break;
		}

		case 9:
		{
			enterOuterAlt(ctx, 9);
			setState(704); //951
			noexceptexpression(ctx);
			break;
		}

		case 10:
		{
			enterOuterAlt(ctx, 10);
			setState(705); //951
			newexpression(ctx);
			break;
		}

		case 11:
		{
			enterOuterAlt(ctx, 11);
			setState(706); //951
			deleteexpression(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::UnaryexpressionContext> CPP14Parser::parseunaryexpression()
{
	unaryexpression();
	auto result = std::unique_ptr<UnaryexpressionContext>(dynamic_cast<UnaryexpressionContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- UnaryoperatorContext ------------------------------------------------------------------

CPP14Parser::UnaryoperatorContext::UnaryoperatorContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::UnaryoperatorContext::Or()
{
	return getToken(CPP14Parser::Or, 0);
}

tree::TerminalNode* CPP14Parser::UnaryoperatorContext::Star()
{
	return getToken(CPP14Parser::Star, 0);
}

tree::TerminalNode* CPP14Parser::UnaryoperatorContext::And()
{
	return getToken(CPP14Parser::And, 0);
}

tree::TerminalNode* CPP14Parser::UnaryoperatorContext::Plus()
{
	return getToken(CPP14Parser::Plus, 0);
}

tree::TerminalNode* CPP14Parser::UnaryoperatorContext::Tilde()
{
	return getToken(CPP14Parser::Tilde, 0);
}

tree::TerminalNode* CPP14Parser::UnaryoperatorContext::Minus()
{
	return getToken(CPP14Parser::Minus, 0);
}


size_t CPP14Parser::UnaryoperatorContext::getRuleIndex() const
{
	return CPP14Parser::RuleUnaryoperator;//688
}

void CPP14Parser::UnaryoperatorContext::copyFrom(UnaryoperatorContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::UnaryoperatorContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<UnaryoperatorContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::UnaryoperatorContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::UnaryoperatorContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::UnaryoperatorContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitUnaryoperator(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::UnaryoperatorContext* CPP14Parser::unaryoperator( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<UnaryoperatorContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 42, CPP14Parser::RuleUnaryoperator);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(709);//970
		_la = _input->LA(1);
		if (!(_la == CPP14Parser::T__0

		|| _la == CPP14Parser::T__1 || ((((_la - 90) & ~ 0x3fULL) == 0) &&
			((1ULL << (_la - 90)) & ((1ULL << (CPP14Parser::Plus - 90))
			| (1ULL << (CPP14Parser::Minus - 90))
			| (1ULL << (CPP14Parser::Star - 90))
			| (1ULL << (CPP14Parser::And - 90))
			| (1ULL << (CPP14Parser::Or - 90))
			| (1ULL << (CPP14Parser::Tilde - 90)))) != 0)))
		{
		_errHandler->recoverInline(this, ctx);
		}
		else
		{
			_errHandler->reportMatch(this);
			consume(ctx);
		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::UnaryoperatorContext> CPP14Parser::parseunaryoperator()
{
	unaryoperator();
	auto result = std::unique_ptr<UnaryoperatorContext>(dynamic_cast<UnaryoperatorContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- NewexpressionContext ------------------------------------------------------------------

CPP14Parser::NewexpressionContext::NewexpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::NewexpressionContext::New()
{
	return getToken(CPP14Parser::New, 0);
}

CPP14Parser::NewtypeidContext* CPP14Parser::NewexpressionContext::newtypeid()
{
	return getRuleContext<CPP14Parser::NewtypeidContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::NewexpressionContext::Doublecolon()
{
	return getToken(CPP14Parser::Doublecolon, 0);
}

CPP14Parser::NewplacementContext* CPP14Parser::NewexpressionContext::newplacement()
{
	return getRuleContext<CPP14Parser::NewplacementContext>(0);//1165
}

CPP14Parser::NewinitializerContext* CPP14Parser::NewexpressionContext::newinitializer()
{
	return getRuleContext<CPP14Parser::NewinitializerContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::NewexpressionContext::LeftParen()
{
	return getToken(CPP14Parser::LeftParen, 0);
}

CPP14Parser::ThetypeidContext* CPP14Parser::NewexpressionContext::thetypeid()
{
	return getRuleContext<CPP14Parser::ThetypeidContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::NewexpressionContext::RightParen()
{
	return getToken(CPP14Parser::RightParen, 0);
}


size_t CPP14Parser::NewexpressionContext::getRuleIndex() const
{
	return CPP14Parser::RuleNewexpression;//688
}

void CPP14Parser::NewexpressionContext::copyFrom(NewexpressionContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::NewexpressionContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<NewexpressionContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::NewexpressionContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::NewexpressionContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::NewexpressionContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitNewexpression(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::NewexpressionContext* CPP14Parser::newexpression( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<NewexpressionContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 44, CPP14Parser::RuleNewexpression);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(735);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 40, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(712);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Doublecolon)
			{
				setState(711);//958
				match(CPP14Parser::Doublecolon,ctx);
			}
			setState(714);//958
			match(CPP14Parser::New,ctx);
			setState(716);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::LeftParen)
			{
				setState(715); //951
				newplacement(ctx);
			}
			setState(718); //951
			newtypeid(ctx);
			setState(720);//848
			_errHandler->sync(this, ctx);

			switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, ctx))
			{
			case 1:
			{
				setState(719); //951
				newinitializer(ctx);
				break;
			}

			}
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(723);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Doublecolon)
			{
				setState(722);//958
				match(CPP14Parser::Doublecolon,ctx);
			}
			setState(725);//958
			match(CPP14Parser::New,ctx);
			setState(727);//848
			_errHandler->sync(this, ctx);

			switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 38, ctx))
			{
			case 1:
			{
				setState(726); //951
				newplacement(ctx);
				break;
			}

			}
			setState(729);//958
			match(CPP14Parser::LeftParen,ctx);
			setState(730); //951
			thetypeid(ctx);
			setState(731);//958
			match(CPP14Parser::RightParen,ctx);
			setState(733);//848
			_errHandler->sync(this, ctx);

			switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 39, ctx))
			{
			case 1:
			{
				setState(732); //951
				newinitializer(ctx);
				break;
			}

			}
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::NewexpressionContext> CPP14Parser::parsenewexpression()
{
	newexpression();
	auto result = std::unique_ptr<NewexpressionContext>(dynamic_cast<NewexpressionContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- NewplacementContext ------------------------------------------------------------------

CPP14Parser::NewplacementContext::NewplacementContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::NewplacementContext::LeftParen()
{
	return getToken(CPP14Parser::LeftParen, 0);
}

CPP14Parser::ExpressionlistContext* CPP14Parser::NewplacementContext::expressionlist()
{
	return getRuleContext<CPP14Parser::ExpressionlistContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::NewplacementContext::RightParen()
{
	return getToken(CPP14Parser::RightParen, 0);
}


size_t CPP14Parser::NewplacementContext::getRuleIndex() const
{
	return CPP14Parser::RuleNewplacement;//688
}

void CPP14Parser::NewplacementContext::copyFrom(NewplacementContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::NewplacementContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<NewplacementContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::NewplacementContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::NewplacementContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::NewplacementContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitNewplacement(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::NewplacementContext* CPP14Parser::newplacement( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<NewplacementContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 46, CPP14Parser::RuleNewplacement);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(737);//958
		match(CPP14Parser::LeftParen,ctx);
		setState(738); //951
		expressionlist(ctx);
		setState(739);//958
		match(CPP14Parser::RightParen,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::NewplacementContext> CPP14Parser::parsenewplacement()
{
	newplacement();
	auto result = std::unique_ptr<NewplacementContext>(dynamic_cast<NewplacementContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- NewtypeidContext ------------------------------------------------------------------

CPP14Parser::NewtypeidContext::NewtypeidContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::TypespecifierseqContext* CPP14Parser::NewtypeidContext::typespecifierseq()
{
	return getRuleContext<CPP14Parser::TypespecifierseqContext>(0);//1165
}

CPP14Parser::NewdeclaratorContext* CPP14Parser::NewtypeidContext::newdeclarator()
{
	return getRuleContext<CPP14Parser::NewdeclaratorContext>(0);//1165
}


size_t CPP14Parser::NewtypeidContext::getRuleIndex() const
{
	return CPP14Parser::RuleNewtypeid;//688
}

void CPP14Parser::NewtypeidContext::copyFrom(NewtypeidContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::NewtypeidContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<NewtypeidContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::NewtypeidContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::NewtypeidContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::NewtypeidContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitNewtypeid(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::NewtypeidContext* CPP14Parser::newtypeid( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<NewtypeidContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 48, CPP14Parser::RuleNewtypeid);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(741); //951
		typespecifierseq(ctx);
		setState(743);//848
		_errHandler->sync(this, ctx);

		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 41, ctx))
		{
		case 1:
		{
			setState(742); //951
			newdeclarator(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::NewtypeidContext> CPP14Parser::parsenewtypeid()
{
	newtypeid();
	auto result = std::unique_ptr<NewtypeidContext>(dynamic_cast<NewtypeidContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- NewdeclaratorContext ------------------------------------------------------------------

CPP14Parser::NewdeclaratorContext::NewdeclaratorContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::PtroperatorContext* CPP14Parser::NewdeclaratorContext::ptroperator()
{
	return getRuleContext<CPP14Parser::PtroperatorContext>(0);//1165
}

CPP14Parser::NewdeclaratorContext* CPP14Parser::NewdeclaratorContext::newdeclarator()
{
	return getRuleContext<CPP14Parser::NewdeclaratorContext>(0);//1165
}

CPP14Parser::NoptrnewdeclaratorContext* CPP14Parser::NewdeclaratorContext::noptrnewdeclarator()
{
	return getRuleContext<CPP14Parser::NoptrnewdeclaratorContext>(0);//1165
}

CPP14Parser::AbstractdeclaratorContext* CPP14Parser::NewdeclaratorContext::abstractdeclarator()
{
	return getRuleContext<CPP14Parser::AbstractdeclaratorContext>(0);//1165
}


size_t CPP14Parser::NewdeclaratorContext::getRuleIndex() const
{
	return CPP14Parser::RuleNewdeclarator;//688
}

void CPP14Parser::NewdeclaratorContext::copyFrom(NewdeclaratorContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::NewdeclaratorContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<NewdeclaratorContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::NewdeclaratorContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::NewdeclaratorContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::NewdeclaratorContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitNewdeclarator(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::NewdeclaratorContext* CPP14Parser::newdeclarator( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<NewdeclaratorContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 50, CPP14Parser::RuleNewdeclarator);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(751);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 43, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(745); //951
			ptroperator(ctx);
			setState(747);//848
			_errHandler->sync(this, ctx);

			switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 42, ctx))
			{
			case 1:
			{
				setState(746); //951
				newdeclarator(ctx);
				break;
			}

			}
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(749); //951
			noptrnewdeclarator(0,ctx);
			break;
		}

		case 3:
		{
			enterOuterAlt(ctx, 3);
			setState(750); //951
			abstractdeclarator(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::NewdeclaratorContext> CPP14Parser::parsenewdeclarator()
{
	newdeclarator();
	auto result = std::unique_ptr<NewdeclaratorContext>(dynamic_cast<NewdeclaratorContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- NoptrnewdeclaratorContext ------------------------------------------------------------------

CPP14Parser::NoptrnewdeclaratorContext::NoptrnewdeclaratorContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::NoptrnewdeclaratorContext::LeftBracket()
{
	return getToken(CPP14Parser::LeftBracket, 0);
}

CPP14Parser::ExpressionContext* CPP14Parser::NoptrnewdeclaratorContext::expression()
{
	return getRuleContext<CPP14Parser::ExpressionContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::NoptrnewdeclaratorContext::RightBracket()
{
	return getToken(CPP14Parser::RightBracket, 0);
}

CPP14Parser::AttributespecifierseqContext* CPP14Parser::NoptrnewdeclaratorContext::attributespecifierseq()
{
	return getRuleContext<CPP14Parser::AttributespecifierseqContext>(0);//1165
}

CPP14Parser::NoptrnewdeclaratorContext* CPP14Parser::NoptrnewdeclaratorContext::noptrnewdeclarator()
{
	return getRuleContext<CPP14Parser::NoptrnewdeclaratorContext>(0);//1165
}

CPP14Parser::ConstantexpressionContext* CPP14Parser::NoptrnewdeclaratorContext::constantexpression()
{
	return getRuleContext<CPP14Parser::ConstantexpressionContext>(0);//1165
}


size_t CPP14Parser::NoptrnewdeclaratorContext::getRuleIndex() const
{
	return CPP14Parser::RuleNoptrnewdeclarator;//688
}

void CPP14Parser::NoptrnewdeclaratorContext::copyFrom(NoptrnewdeclaratorContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::NoptrnewdeclaratorContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<NoptrnewdeclaratorContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::NoptrnewdeclaratorContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::NoptrnewdeclaratorContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::NoptrnewdeclaratorContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitNoptrnewdeclarator(this);
	else
		return visitor->visitChildren(this);
}


CPP14Parser::NoptrnewdeclaratorContext* CPP14Parser::noptrnewdeclarator()
{
	 return noptrnewdeclarator(0, nullptr);//600
}

CPP14Parser::NoptrnewdeclaratorContext* CPP14Parser::noptrnewdeclarator(int precedence, antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	antlr4::ParserRuleContext *parentContext = parent;
	size_t parentState = getState();
	auto _localctx = std::make_unique<NoptrnewdeclaratorContext>(parentContext, parentState);//610
	auto ctx = _localctx.get();//609
	size_t startState = 52;
	enterRecursionRule(ctx, 52, CPP14Parser::RuleNoptrnewdeclarator, precedence);

		

	auto onExit = finally([=,&_localctx]
{
		unrollRecursionContexts(parentContext, std::move(_localctx));
	});
	try
{
		size_t alt;
		enterOuterAlt(ctx, 1);
		setState(754);//958
		match(CPP14Parser::LeftBracket,ctx);
		setState(755); //951
		expression(0,ctx);
		setState(756);//958
		match(CPP14Parser::RightBracket,ctx);
		setState(758);//848
		_errHandler->sync(this, ctx);

		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 44, ctx))
		{
		case 1:
		{
			setState(757); //951
			attributespecifierseq(0,ctx);
			break;
		}

		}
		ctx->stop = _input->LT(-1);
		setState(769);//865
		_errHandler->sync(this, ctx);
		alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 46, ctx);
		while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
		{
			if (alt == 1)
		{
				if (!_parseListeners.empty())
					triggerExitRuleEvent(ctx);

				auto tmpContext = std::make_unique<NoptrnewdeclaratorContext>(parentContext, parentState);
				pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleNoptrnewdeclarator);//1240
				_localctx = std::move(tmpContext);
				ctx = _localctx.get();
				setState(760);//1002

				if (!(precpred(nullptr, 1))) throw FailedPredicateException(this, "precpred(nullptr, 1)", ctx);
				setState(761);//958
				match(CPP14Parser::LeftBracket,ctx);
				setState(762); //951
				constantexpression(ctx);
				setState(763);//958
				match(CPP14Parser::RightBracket,ctx);
				setState(765);//848
				_errHandler->sync(this, ctx);

				switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, ctx))
				{
				case 1:
				{
					setState(764); //951
					attributespecifierseq(0,ctx);
					break;
				}

				} 
			}
			setState(771);//875
			_errHandler->sync(this, ctx);
			alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 46, ctx);
		}
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		_localctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}
	onExit();
	return ctx;
}

std::unique_ptr< CPP14Parser::NoptrnewdeclaratorContext> CPP14Parser::parsenoptrnewdeclarator()
{
	noptrnewdeclarator();
	auto result = std::unique_ptr<NoptrnewdeclaratorContext>(dynamic_cast<NoptrnewdeclaratorContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}

//----------------- NewinitializerContext ------------------------------------------------------------------

CPP14Parser::NewinitializerContext::NewinitializerContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::NewinitializerContext::LeftParen()
{
	return getToken(CPP14Parser::LeftParen, 0);
}

tree::TerminalNode* CPP14Parser::NewinitializerContext::RightParen()
{
	return getToken(CPP14Parser::RightParen, 0);
}

CPP14Parser::ExpressionlistContext* CPP14Parser::NewinitializerContext::expressionlist()
{
	return getRuleContext<CPP14Parser::ExpressionlistContext>(0);//1165
}

CPP14Parser::BracedinitlistContext* CPP14Parser::NewinitializerContext::bracedinitlist()
{
	return getRuleContext<CPP14Parser::BracedinitlistContext>(0);//1165
}


size_t CPP14Parser::NewinitializerContext::getRuleIndex() const
{
	return CPP14Parser::RuleNewinitializer;//688
}

void CPP14Parser::NewinitializerContext::copyFrom(NewinitializerContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::NewinitializerContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<NewinitializerContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::NewinitializerContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::NewinitializerContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::NewinitializerContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitNewinitializer(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::NewinitializerContext* CPP14Parser::newinitializer( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<NewinitializerContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 54, CPP14Parser::RuleNewinitializer);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(778);//750
		_errHandler->sync(this, ctx);
		switch (_input->LA(1))
		{
			case CPP14Parser::LeftParen:
			{
				enterOuterAlt(ctx, 1);
				setState(772);//958
				match(CPP14Parser::LeftParen,ctx);
				setState(774);//788
				_errHandler->sync(this, ctx);

				_la = _input->LA(1);
				if ((((_la & ~ 0x3fULL) == 0) &&
					((1ULL << _la) & ((1ULL << CPP14Parser::T__0)
					| (1ULL << CPP14Parser::T__1)
					| (1ULL << CPP14Parser::Alignof)
					| (1ULL << CPP14Parser::Auto)
					| (1ULL << CPP14Parser::Bool)
					| (1ULL << CPP14Parser::Char)
					| (1ULL << CPP14Parser::Char16)
					| (1ULL << CPP14Parser::Char32)
					| (1ULL << CPP14Parser::Const_cast)
					| (1ULL << CPP14Parser::Decltype)
					| (1ULL << CPP14Parser::Delete)
					| (1ULL << CPP14Parser::Double)
					| (1ULL << CPP14Parser::Dynamic_cast)
					| (1ULL << CPP14Parser::False)
					| (1ULL << CPP14Parser::Float)
					| (1ULL << CPP14Parser::Int)
					| (1ULL << CPP14Parser::Long)
					| (1ULL << CPP14Parser::New)
					| (1ULL << CPP14Parser::Noexcept)
					| (1ULL << CPP14Parser::Nullptr)
					| (1ULL << CPP14Parser::Operator)
					| (1ULL << CPP14Parser::Reinterpret_cast)
					| (1ULL << CPP14Parser::Short)
					| (1ULL << CPP14Parser::Signed)
					| (1ULL << CPP14Parser::Sizeof))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
					((1ULL << (_la - 64)) & ((1ULL << (CPP14Parser::Static_cast - 64))
					| (1ULL << (CPP14Parser::This - 64))
					| (1ULL << (CPP14Parser::Throw - 64))
					| (1ULL << (CPP14Parser::True - 64))
					| (1ULL << (CPP14Parser::Typeid_ - 64))
					| (1ULL << (CPP14Parser::Typename_ - 64))
					| (1ULL << (CPP14Parser::Unsigned - 64))
					| (1ULL << (CPP14Parser::Void - 64))
					| (1ULL << (CPP14Parser::Wchar - 64))
					| (1ULL << (CPP14Parser::LeftParen - 64))
					| (1ULL << (CPP14Parser::LeftBracket - 64))
					| (1ULL << (CPP14Parser::LeftBrace - 64))
					| (1ULL << (CPP14Parser::Plus - 64))
					| (1ULL << (CPP14Parser::Minus - 64))
					| (1ULL << (CPP14Parser::Star - 64))
					| (1ULL << (CPP14Parser::And - 64))
					| (1ULL << (CPP14Parser::Or - 64))
					| (1ULL << (CPP14Parser::Tilde - 64))
					| (1ULL << (CPP14Parser::PlusPlus - 64))
					| (1ULL << (CPP14Parser::MinusMinus - 64))
					| (1ULL << (CPP14Parser::Doublecolon - 64)))) != 0) || ((((_la - 130) & ~ 0x3fULL) == 0) &&
					((1ULL << (_la - 130)) & ((1ULL << (CPP14Parser::Identifier - 130))
					| (1ULL << (CPP14Parser::Integerliteral - 130))
					| (1ULL << (CPP14Parser::Characterliteral - 130))
					| (1ULL << (CPP14Parser::Floatingliteral - 130))
					| (1ULL << (CPP14Parser::Stringliteral - 130))
					| (1ULL << (CPP14Parser::Userdefinedintegerliteral - 130))
					| (1ULL << (CPP14Parser::Userdefinedfloatingliteral - 130))
					| (1ULL << (CPP14Parser::Userdefinedstringliteral - 130))
					| (1ULL << (CPP14Parser::Userdefinedcharacterliteral - 130)))) != 0))
				{
					setState(773); //951
					expressionlist(ctx);
				}
				setState(776);//958
				match(CPP14Parser::RightParen,ctx);
				break;
			}

			case CPP14Parser::LeftBrace:
			{
				enterOuterAlt(ctx, 2);
				setState(777); //951
				bracedinitlist(ctx);
				break;
			}

		default:
			throw NoViableAltException(this, ctx);
		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::NewinitializerContext> CPP14Parser::parsenewinitializer()
{
	newinitializer();
	auto result = std::unique_ptr<NewinitializerContext>(dynamic_cast<NewinitializerContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- DeleteexpressionContext ------------------------------------------------------------------

CPP14Parser::DeleteexpressionContext::DeleteexpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::DeleteexpressionContext::Delete()
{
	return getToken(CPP14Parser::Delete, 0);
}

CPP14Parser::CastexpressionContext* CPP14Parser::DeleteexpressionContext::castexpression()
{
	return getRuleContext<CPP14Parser::CastexpressionContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::DeleteexpressionContext::Doublecolon()
{
	return getToken(CPP14Parser::Doublecolon, 0);
}

tree::TerminalNode* CPP14Parser::DeleteexpressionContext::LeftBracket()
{
	return getToken(CPP14Parser::LeftBracket, 0);
}

tree::TerminalNode* CPP14Parser::DeleteexpressionContext::RightBracket()
{
	return getToken(CPP14Parser::RightBracket, 0);
}


size_t CPP14Parser::DeleteexpressionContext::getRuleIndex() const
{
	return CPP14Parser::RuleDeleteexpression;//688
}

void CPP14Parser::DeleteexpressionContext::copyFrom(DeleteexpressionContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::DeleteexpressionContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<DeleteexpressionContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::DeleteexpressionContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::DeleteexpressionContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::DeleteexpressionContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitDeleteexpression(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::DeleteexpressionContext* CPP14Parser::deleteexpression( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<DeleteexpressionContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 56, CPP14Parser::RuleDeleteexpression);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(792);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 51, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(781);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Doublecolon)
			{
				setState(780);//958
				match(CPP14Parser::Doublecolon,ctx);
			}
			setState(783);//958
			match(CPP14Parser::Delete,ctx);
			setState(784); //951
			castexpression(ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(786);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Doublecolon)
			{
				setState(785);//958
				match(CPP14Parser::Doublecolon,ctx);
			}
			setState(788);//958
			match(CPP14Parser::Delete,ctx);
			setState(789);//958
			match(CPP14Parser::LeftBracket,ctx);
			setState(790);//958
			match(CPP14Parser::RightBracket,ctx);
			setState(791); //951
			castexpression(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::DeleteexpressionContext> CPP14Parser::parsedeleteexpression()
{
	deleteexpression();
	auto result = std::unique_ptr<DeleteexpressionContext>(dynamic_cast<DeleteexpressionContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- NoexceptexpressionContext ------------------------------------------------------------------

CPP14Parser::NoexceptexpressionContext::NoexceptexpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::NoexceptexpressionContext::Noexcept()
{
	return getToken(CPP14Parser::Noexcept, 0);
}

tree::TerminalNode* CPP14Parser::NoexceptexpressionContext::LeftParen()
{
	return getToken(CPP14Parser::LeftParen, 0);
}

CPP14Parser::ExpressionContext* CPP14Parser::NoexceptexpressionContext::expression()
{
	return getRuleContext<CPP14Parser::ExpressionContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::NoexceptexpressionContext::RightParen()
{
	return getToken(CPP14Parser::RightParen, 0);
}


size_t CPP14Parser::NoexceptexpressionContext::getRuleIndex() const
{
	return CPP14Parser::RuleNoexceptexpression;//688
}

void CPP14Parser::NoexceptexpressionContext::copyFrom(NoexceptexpressionContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::NoexceptexpressionContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<NoexceptexpressionContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::NoexceptexpressionContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::NoexceptexpressionContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::NoexceptexpressionContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitNoexceptexpression(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::NoexceptexpressionContext* CPP14Parser::noexceptexpression( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<NoexceptexpressionContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 58, CPP14Parser::RuleNoexceptexpression);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(794);//958
		match(CPP14Parser::Noexcept,ctx);
		setState(795);//958
		match(CPP14Parser::LeftParen,ctx);
		setState(796); //951
		expression(0,ctx);
		setState(797);//958
		match(CPP14Parser::RightParen,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::NoexceptexpressionContext> CPP14Parser::parsenoexceptexpression()
{
	noexceptexpression();
	auto result = std::unique_ptr<NoexceptexpressionContext>(dynamic_cast<NoexceptexpressionContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- CastexpressionContext ------------------------------------------------------------------

CPP14Parser::CastexpressionContext::CastexpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::UnaryexpressionContext* CPP14Parser::CastexpressionContext::unaryexpression()
{
	return getRuleContext<CPP14Parser::UnaryexpressionContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::CastexpressionContext::LeftParen()
{
	return getToken(CPP14Parser::LeftParen, 0);
}

CPP14Parser::ThetypeidContext* CPP14Parser::CastexpressionContext::thetypeid()
{
	return getRuleContext<CPP14Parser::ThetypeidContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::CastexpressionContext::RightParen()
{
	return getToken(CPP14Parser::RightParen, 0);
}

CPP14Parser::CastexpressionContext* CPP14Parser::CastexpressionContext::castexpression()
{
	return getRuleContext<CPP14Parser::CastexpressionContext>(0);//1165
}


size_t CPP14Parser::CastexpressionContext::getRuleIndex() const
{
	return CPP14Parser::RuleCastexpression;//688
}

void CPP14Parser::CastexpressionContext::copyFrom(CastexpressionContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::CastexpressionContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<CastexpressionContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::CastexpressionContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::CastexpressionContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::CastexpressionContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitCastexpression(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::CastexpressionContext* CPP14Parser::castexpression( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<CastexpressionContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 60, CPP14Parser::RuleCastexpression);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(805);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(799); //951
			unaryexpression(ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(800);//958
			match(CPP14Parser::LeftParen,ctx);
			setState(801); //951
			thetypeid(ctx);
			setState(802);//958
			match(CPP14Parser::RightParen,ctx);
			setState(803); //951
			castexpression(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::CastexpressionContext> CPP14Parser::parsecastexpression()
{
	castexpression();
	auto result = std::unique_ptr<CastexpressionContext>(dynamic_cast<CastexpressionContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- PmexpressionContext ------------------------------------------------------------------

CPP14Parser::PmexpressionContext::PmexpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::CastexpressionContext* CPP14Parser::PmexpressionContext::castexpression()
{
	return getRuleContext<CPP14Parser::CastexpressionContext>(0);//1165
}

CPP14Parser::PmexpressionContext* CPP14Parser::PmexpressionContext::pmexpression()
{
	return getRuleContext<CPP14Parser::PmexpressionContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::PmexpressionContext::DotStar()
{
	return getToken(CPP14Parser::DotStar, 0);
}

tree::TerminalNode* CPP14Parser::PmexpressionContext::ArrowStar()
{
	return getToken(CPP14Parser::ArrowStar, 0);
}


size_t CPP14Parser::PmexpressionContext::getRuleIndex() const
{
	return CPP14Parser::RulePmexpression;//688
}

void CPP14Parser::PmexpressionContext::copyFrom(PmexpressionContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::PmexpressionContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<PmexpressionContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::PmexpressionContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::PmexpressionContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::PmexpressionContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitPmexpression(this);
	else
		return visitor->visitChildren(this);
}


CPP14Parser::PmexpressionContext* CPP14Parser::pmexpression()
{
	 return pmexpression(0, nullptr);//600
}

CPP14Parser::PmexpressionContext* CPP14Parser::pmexpression(int precedence, antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	antlr4::ParserRuleContext *parentContext = parent;
	size_t parentState = getState();
	auto _localctx = std::make_unique<PmexpressionContext>(parentContext, parentState);//610
	auto ctx = _localctx.get();//609
	size_t startState = 62;
	enterRecursionRule(ctx, 62, CPP14Parser::RulePmexpression, precedence);

		

	auto onExit = finally([=,&_localctx]
{
		unrollRecursionContexts(parentContext, std::move(_localctx));
	});
	try
{
		size_t alt;
		enterOuterAlt(ctx, 1);
		setState(808); //951
		castexpression(ctx);
		ctx->stop = _input->LT(-1);
		setState(818);//865
		_errHandler->sync(this, ctx);
		alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 54, ctx);
		while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
		{
			if (alt == 1)
		{
				if (!_parseListeners.empty())
					triggerExitRuleEvent(ctx);

				setState(816);//830
				_errHandler->sync(this, ctx);
				switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, ctx))
				{
				case 1:
				{
					auto tmpContext = std::make_unique<PmexpressionContext>(parentContext, parentState);
					pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RulePmexpression);//1240
					_localctx = std::move(tmpContext);
					ctx = _localctx.get();
					setState(810);//1002

					if (!(precpred(nullptr, 2))) throw FailedPredicateException(this, "precpred(nullptr, 2)", ctx);
					setState(811);//958
					match(CPP14Parser::DotStar,ctx);
					setState(812); //951
					castexpression(ctx);
					break;
				}

				case 2:
				{
					auto tmpContext = std::make_unique<PmexpressionContext>(parentContext, parentState);
					pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RulePmexpression);//1240
					_localctx = std::move(tmpContext);
					ctx = _localctx.get();
					setState(813);//1002

					if (!(precpred(nullptr, 1))) throw FailedPredicateException(this, "precpred(nullptr, 1)", ctx);
					setState(814);//958
					match(CPP14Parser::ArrowStar,ctx);
					setState(815); //951
					castexpression(ctx);
					break;
				}

				} 
			}
			setState(820);//875
			_errHandler->sync(this, ctx);
			alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 54, ctx);
		}
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		_localctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}
	onExit();
	return ctx;
}

std::unique_ptr< CPP14Parser::PmexpressionContext> CPP14Parser::parsepmexpression()
{
	pmexpression();
	auto result = std::unique_ptr<PmexpressionContext>(dynamic_cast<PmexpressionContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}

//----------------- MultiplicativeexpressionContext ------------------------------------------------------------------

CPP14Parser::MultiplicativeexpressionContext::MultiplicativeexpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::PmexpressionContext* CPP14Parser::MultiplicativeexpressionContext::pmexpression()
{
	return getRuleContext<CPP14Parser::PmexpressionContext>(0);//1165
}

CPP14Parser::MultiplicativeexpressionContext* CPP14Parser::MultiplicativeexpressionContext::multiplicativeexpression()
{
	return getRuleContext<CPP14Parser::MultiplicativeexpressionContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::MultiplicativeexpressionContext::Star()
{
	return getToken(CPP14Parser::Star, 0);
}

tree::TerminalNode* CPP14Parser::MultiplicativeexpressionContext::Div()
{
	return getToken(CPP14Parser::Div, 0);
}

tree::TerminalNode* CPP14Parser::MultiplicativeexpressionContext::Mod()
{
	return getToken(CPP14Parser::Mod, 0);
}


size_t CPP14Parser::MultiplicativeexpressionContext::getRuleIndex() const
{
	return CPP14Parser::RuleMultiplicativeexpression;//688
}

void CPP14Parser::MultiplicativeexpressionContext::copyFrom(MultiplicativeexpressionContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::MultiplicativeexpressionContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<MultiplicativeexpressionContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::MultiplicativeexpressionContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::MultiplicativeexpressionContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::MultiplicativeexpressionContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitMultiplicativeexpression(this);
	else
		return visitor->visitChildren(this);
}


CPP14Parser::MultiplicativeexpressionContext* CPP14Parser::multiplicativeexpression()
{
	 return multiplicativeexpression(0, nullptr);//600
}

CPP14Parser::MultiplicativeexpressionContext* CPP14Parser::multiplicativeexpression(int precedence, antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	antlr4::ParserRuleContext *parentContext = parent;
	size_t parentState = getState();
	auto _localctx = std::make_unique<MultiplicativeexpressionContext>(parentContext, parentState);//610
	auto ctx = _localctx.get();//609
	size_t startState = 64;
	enterRecursionRule(ctx, 64, CPP14Parser::RuleMultiplicativeexpression, precedence);

		

	auto onExit = finally([=,&_localctx]
{
		unrollRecursionContexts(parentContext, std::move(_localctx));
	});
	try
{
		size_t alt;
		enterOuterAlt(ctx, 1);
		setState(822); //951
		pmexpression(0,ctx);
		ctx->stop = _input->LT(-1);
		setState(835);//865
		_errHandler->sync(this, ctx);
		alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 56, ctx);
		while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
		{
			if (alt == 1)
		{
				if (!_parseListeners.empty())
					triggerExitRuleEvent(ctx);

				setState(833);//830
				_errHandler->sync(this, ctx);
				switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 55, ctx))
				{
				case 1:
				{
					auto tmpContext = std::make_unique<MultiplicativeexpressionContext>(parentContext, parentState);
					pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleMultiplicativeexpression);//1240
					_localctx = std::move(tmpContext);
					ctx = _localctx.get();
					setState(824);//1002

					if (!(precpred(nullptr, 3))) throw FailedPredicateException(this, "precpred(nullptr, 3)", ctx);
					setState(825);//958
					match(CPP14Parser::Star,ctx);
					setState(826); //951
					pmexpression(0,ctx);
					break;
				}

				case 2:
				{
					auto tmpContext = std::make_unique<MultiplicativeexpressionContext>(parentContext, parentState);
					pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleMultiplicativeexpression);//1240
					_localctx = std::move(tmpContext);
					ctx = _localctx.get();
					setState(827);//1002

					if (!(precpred(nullptr, 2))) throw FailedPredicateException(this, "precpred(nullptr, 2)", ctx);
					setState(828);//958
					match(CPP14Parser::Div,ctx);
					setState(829); //951
					pmexpression(0,ctx);
					break;
				}

				case 3:
				{
					auto tmpContext = std::make_unique<MultiplicativeexpressionContext>(parentContext, parentState);
					pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleMultiplicativeexpression);//1240
					_localctx = std::move(tmpContext);
					ctx = _localctx.get();
					setState(830);//1002

					if (!(precpred(nullptr, 1))) throw FailedPredicateException(this, "precpred(nullptr, 1)", ctx);
					setState(831);//958
					match(CPP14Parser::Mod,ctx);
					setState(832); //951
					pmexpression(0,ctx);
					break;
				}

				} 
			}
			setState(837);//875
			_errHandler->sync(this, ctx);
			alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 56, ctx);
		}
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		_localctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}
	onExit();
	return ctx;
}

std::unique_ptr< CPP14Parser::MultiplicativeexpressionContext> CPP14Parser::parsemultiplicativeexpression()
{
	multiplicativeexpression();
	auto result = std::unique_ptr<MultiplicativeexpressionContext>(dynamic_cast<MultiplicativeexpressionContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}

//----------------- AdditiveexpressionContext ------------------------------------------------------------------

CPP14Parser::AdditiveexpressionContext::AdditiveexpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::MultiplicativeexpressionContext* CPP14Parser::AdditiveexpressionContext::multiplicativeexpression()
{
	return getRuleContext<CPP14Parser::MultiplicativeexpressionContext>(0);//1165
}

CPP14Parser::AdditiveexpressionContext* CPP14Parser::AdditiveexpressionContext::additiveexpression()
{
	return getRuleContext<CPP14Parser::AdditiveexpressionContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::AdditiveexpressionContext::Plus()
{
	return getToken(CPP14Parser::Plus, 0);
}

tree::TerminalNode* CPP14Parser::AdditiveexpressionContext::Minus()
{
	return getToken(CPP14Parser::Minus, 0);
}


size_t CPP14Parser::AdditiveexpressionContext::getRuleIndex() const
{
	return CPP14Parser::RuleAdditiveexpression;//688
}

void CPP14Parser::AdditiveexpressionContext::copyFrom(AdditiveexpressionContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::AdditiveexpressionContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<AdditiveexpressionContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::AdditiveexpressionContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::AdditiveexpressionContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::AdditiveexpressionContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitAdditiveexpression(this);
	else
		return visitor->visitChildren(this);
}


CPP14Parser::AdditiveexpressionContext* CPP14Parser::additiveexpression()
{
	 return additiveexpression(0, nullptr);//600
}

CPP14Parser::AdditiveexpressionContext* CPP14Parser::additiveexpression(int precedence, antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	antlr4::ParserRuleContext *parentContext = parent;
	size_t parentState = getState();
	auto _localctx = std::make_unique<AdditiveexpressionContext>(parentContext, parentState);//610
	auto ctx = _localctx.get();//609
	size_t startState = 66;
	enterRecursionRule(ctx, 66, CPP14Parser::RuleAdditiveexpression, precedence);

		

	auto onExit = finally([=,&_localctx]
{
		unrollRecursionContexts(parentContext, std::move(_localctx));
	});
	try
{
		size_t alt;
		enterOuterAlt(ctx, 1);
		setState(839); //951
		multiplicativeexpression(0,ctx);
		ctx->stop = _input->LT(-1);
		setState(849);//865
		_errHandler->sync(this, ctx);
		alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, ctx);
		while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
		{
			if (alt == 1)
		{
				if (!_parseListeners.empty())
					triggerExitRuleEvent(ctx);

				setState(847);//830
				_errHandler->sync(this, ctx);
				switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 57, ctx))
				{
				case 1:
				{
					auto tmpContext = std::make_unique<AdditiveexpressionContext>(parentContext, parentState);
					pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleAdditiveexpression);//1240
					_localctx = std::move(tmpContext);
					ctx = _localctx.get();
					setState(841);//1002

					if (!(precpred(nullptr, 2))) throw FailedPredicateException(this, "precpred(nullptr, 2)", ctx);
					setState(842);//958
					match(CPP14Parser::Plus,ctx);
					setState(843); //951
					multiplicativeexpression(0,ctx);
					break;
				}

				case 2:
				{
					auto tmpContext = std::make_unique<AdditiveexpressionContext>(parentContext, parentState);
					pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleAdditiveexpression);//1240
					_localctx = std::move(tmpContext);
					ctx = _localctx.get();
					setState(844);//1002

					if (!(precpred(nullptr, 1))) throw FailedPredicateException(this, "precpred(nullptr, 1)", ctx);
					setState(845);//958
					match(CPP14Parser::Minus,ctx);
					setState(846); //951
					multiplicativeexpression(0,ctx);
					break;
				}

				} 
			}
			setState(851);//875
			_errHandler->sync(this, ctx);
			alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, ctx);
		}
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		_localctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}
	onExit();
	return ctx;
}

std::unique_ptr< CPP14Parser::AdditiveexpressionContext> CPP14Parser::parseadditiveexpression()
{
	additiveexpression();
	auto result = std::unique_ptr<AdditiveexpressionContext>(dynamic_cast<AdditiveexpressionContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}

//----------------- ShiftexpressionContext ------------------------------------------------------------------

CPP14Parser::ShiftexpressionContext::ShiftexpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::AdditiveexpressionContext* CPP14Parser::ShiftexpressionContext::additiveexpression()
{
	return getRuleContext<CPP14Parser::AdditiveexpressionContext>(0);//1165
}

CPP14Parser::ShiftexpressionContext* CPP14Parser::ShiftexpressionContext::shiftexpression()
{
	return getRuleContext<CPP14Parser::ShiftexpressionContext>(0);//1165
}

CPP14Parser::ShiftoperatorContext* CPP14Parser::ShiftexpressionContext::shiftoperator()
{
	return getRuleContext<CPP14Parser::ShiftoperatorContext>(0);//1165
}


size_t CPP14Parser::ShiftexpressionContext::getRuleIndex() const
{
	return CPP14Parser::RuleShiftexpression;//688
}

void CPP14Parser::ShiftexpressionContext::copyFrom(ShiftexpressionContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::ShiftexpressionContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<ShiftexpressionContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::ShiftexpressionContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::ShiftexpressionContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::ShiftexpressionContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitShiftexpression(this);
	else
		return visitor->visitChildren(this);
}


CPP14Parser::ShiftexpressionContext* CPP14Parser::shiftexpression()
{
	 return shiftexpression(0, nullptr);//600
}

CPP14Parser::ShiftexpressionContext* CPP14Parser::shiftexpression(int precedence, antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	antlr4::ParserRuleContext *parentContext = parent;
	size_t parentState = getState();
	auto _localctx = std::make_unique<ShiftexpressionContext>(parentContext, parentState);//610
	auto ctx = _localctx.get();//609
	size_t startState = 68;
	enterRecursionRule(ctx, 68, CPP14Parser::RuleShiftexpression, precedence);

		

	auto onExit = finally([=,&_localctx]
{
		unrollRecursionContexts(parentContext, std::move(_localctx));
	});
	try
{
		size_t alt;
		enterOuterAlt(ctx, 1);
		setState(853); //951
		additiveexpression(0,ctx);
		ctx->stop = _input->LT(-1);
		setState(861);//865
		_errHandler->sync(this, ctx);
		alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, ctx);
		while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
		{
			if (alt == 1)
		{
				if (!_parseListeners.empty())
					triggerExitRuleEvent(ctx);

				auto tmpContext = std::make_unique<ShiftexpressionContext>(parentContext, parentState);
				pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleShiftexpression);//1240
				_localctx = std::move(tmpContext);
				ctx = _localctx.get();
				setState(855);//1002

				if (!(precpred(nullptr, 1))) throw FailedPredicateException(this, "precpred(nullptr, 1)", ctx);
				setState(856); //951
				shiftoperator(ctx);
				setState(857); //951
				additiveexpression(0,ctx); 
			}
			setState(863);//875
			_errHandler->sync(this, ctx);
			alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, ctx);
		}
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		_localctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}
	onExit();
	return ctx;
}

std::unique_ptr< CPP14Parser::ShiftexpressionContext> CPP14Parser::parseshiftexpression()
{
	shiftexpression();
	auto result = std::unique_ptr<ShiftexpressionContext>(dynamic_cast<ShiftexpressionContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}

//----------------- ShiftoperatorContext ------------------------------------------------------------------

CPP14Parser::ShiftoperatorContext::ShiftoperatorContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::RightShiftContext* CPP14Parser::ShiftoperatorContext::rightShift()
{
	return getRuleContext<CPP14Parser::RightShiftContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::ShiftoperatorContext::LeftShift()
{
	return getToken(CPP14Parser::LeftShift, 0);
}


size_t CPP14Parser::ShiftoperatorContext::getRuleIndex() const
{
	return CPP14Parser::RuleShiftoperator;//688
}

void CPP14Parser::ShiftoperatorContext::copyFrom(ShiftoperatorContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::ShiftoperatorContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<ShiftoperatorContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::ShiftoperatorContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::ShiftoperatorContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::ShiftoperatorContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitShiftoperator(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::ShiftoperatorContext* CPP14Parser::shiftoperator( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<ShiftoperatorContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 70, CPP14Parser::RuleShiftoperator);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(866);//750
		_errHandler->sync(this, ctx);
		switch (_input->LA(1))
		{
			case CPP14Parser::GreaterThan:
			{
				enterOuterAlt(ctx, 1);
				setState(864); //951
				rightShift(ctx);
				break;
			}

			case CPP14Parser::LeftShift:
			{
				enterOuterAlt(ctx, 2);
				setState(865);//958
				match(CPP14Parser::LeftShift,ctx);
				break;
			}

		default:
			throw NoViableAltException(this, ctx);
		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::ShiftoperatorContext> CPP14Parser::parseshiftoperator()
{
	shiftoperator();
	auto result = std::unique_ptr<ShiftoperatorContext>(dynamic_cast<ShiftoperatorContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- RelationalexpressionContext ------------------------------------------------------------------

CPP14Parser::RelationalexpressionContext::RelationalexpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::ShiftexpressionContext* CPP14Parser::RelationalexpressionContext::shiftexpression()
{
	return getRuleContext<CPP14Parser::ShiftexpressionContext>(0);//1165
}

CPP14Parser::RelationalexpressionContext* CPP14Parser::RelationalexpressionContext::relationalexpression()
{
	return getRuleContext<CPP14Parser::RelationalexpressionContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::RelationalexpressionContext::Less()
{
	return getToken(CPP14Parser::Less, 0);
}

tree::TerminalNode* CPP14Parser::RelationalexpressionContext::GreaterThan()
{
	return getToken(CPP14Parser::GreaterThan, 0);
}

tree::TerminalNode* CPP14Parser::RelationalexpressionContext::LessEqual()
{
	return getToken(CPP14Parser::LessEqual, 0);
}

tree::TerminalNode* CPP14Parser::RelationalexpressionContext::GreaterEqual()
{
	return getToken(CPP14Parser::GreaterEqual, 0);
}


size_t CPP14Parser::RelationalexpressionContext::getRuleIndex() const
{
	return CPP14Parser::RuleRelationalexpression;//688
}

void CPP14Parser::RelationalexpressionContext::copyFrom(RelationalexpressionContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::RelationalexpressionContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<RelationalexpressionContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::RelationalexpressionContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::RelationalexpressionContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::RelationalexpressionContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitRelationalexpression(this);
	else
		return visitor->visitChildren(this);
}


CPP14Parser::RelationalexpressionContext* CPP14Parser::relationalexpression()
{
	 return relationalexpression(0, nullptr);//600
}

CPP14Parser::RelationalexpressionContext* CPP14Parser::relationalexpression(int precedence, antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	antlr4::ParserRuleContext *parentContext = parent;
	size_t parentState = getState();
	auto _localctx = std::make_unique<RelationalexpressionContext>(parentContext, parentState);//610
	auto ctx = _localctx.get();//609
	size_t startState = 72;
	enterRecursionRule(ctx, 72, CPP14Parser::RuleRelationalexpression, precedence);

		

	auto onExit = finally([=,&_localctx]
{
		unrollRecursionContexts(parentContext, std::move(_localctx));
	});
	try
{
		size_t alt;
		enterOuterAlt(ctx, 1);
		setState(869); //951
		shiftexpression(0,ctx);
		ctx->stop = _input->LT(-1);
		setState(885);//865
		_errHandler->sync(this, ctx);
		alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 62, ctx);
		while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
		{
			if (alt == 1)
		{
				if (!_parseListeners.empty())
					triggerExitRuleEvent(ctx);

				setState(883);//830
				_errHandler->sync(this, ctx);
				switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 61, ctx))
				{
				case 1:
				{
					auto tmpContext = std::make_unique<RelationalexpressionContext>(parentContext, parentState);
					pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleRelationalexpression);//1240
					_localctx = std::move(tmpContext);
					ctx = _localctx.get();
					setState(871);//1002

					if (!(precpred(nullptr, 4))) throw FailedPredicateException(this, "precpred(nullptr, 4)", ctx);
					setState(872);//958
					match(CPP14Parser::Less,ctx);
					setState(873); //951
					shiftexpression(0,ctx);
					break;
				}

				case 2:
				{
					auto tmpContext = std::make_unique<RelationalexpressionContext>(parentContext, parentState);
					pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleRelationalexpression);//1240
					_localctx = std::move(tmpContext);
					ctx = _localctx.get();
					setState(874);//1002

					if (!(precpred(nullptr, 3))) throw FailedPredicateException(this, "precpred(nullptr, 3)", ctx);
					setState(875);//958
					match(CPP14Parser::GreaterThan,ctx);
					setState(876); //951
					shiftexpression(0,ctx);
					break;
				}

				case 3:
				{
					auto tmpContext = std::make_unique<RelationalexpressionContext>(parentContext, parentState);
					pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleRelationalexpression);//1240
					_localctx = std::move(tmpContext);
					ctx = _localctx.get();
					setState(877);//1002

					if (!(precpred(nullptr, 2))) throw FailedPredicateException(this, "precpred(nullptr, 2)", ctx);
					setState(878);//958
					match(CPP14Parser::LessEqual,ctx);
					setState(879); //951
					shiftexpression(0,ctx);
					break;
				}

				case 4:
				{
					auto tmpContext = std::make_unique<RelationalexpressionContext>(parentContext, parentState);
					pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleRelationalexpression);//1240
					_localctx = std::move(tmpContext);
					ctx = _localctx.get();
					setState(880);//1002

					if (!(precpred(nullptr, 1))) throw FailedPredicateException(this, "precpred(nullptr, 1)", ctx);
					setState(881);//958
					match(CPP14Parser::GreaterEqual,ctx);
					setState(882); //951
					shiftexpression(0,ctx);
					break;
				}

				} 
			}
			setState(887);//875
			_errHandler->sync(this, ctx);
			alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 62, ctx);
		}
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		_localctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}
	onExit();
	return ctx;
}

std::unique_ptr< CPP14Parser::RelationalexpressionContext> CPP14Parser::parserelationalexpression()
{
	relationalexpression();
	auto result = std::unique_ptr<RelationalexpressionContext>(dynamic_cast<RelationalexpressionContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}

//----------------- EqualityexpressionContext ------------------------------------------------------------------

CPP14Parser::EqualityexpressionContext::EqualityexpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::RelationalexpressionContext* CPP14Parser::EqualityexpressionContext::relationalexpression()
{
	return getRuleContext<CPP14Parser::RelationalexpressionContext>(0);//1165
}

CPP14Parser::EqualityexpressionContext* CPP14Parser::EqualityexpressionContext::equalityexpression()
{
	return getRuleContext<CPP14Parser::EqualityexpressionContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::EqualityexpressionContext::Equal()
{
	return getToken(CPP14Parser::Equal, 0);
}

tree::TerminalNode* CPP14Parser::EqualityexpressionContext::NotEqual()
{
	return getToken(CPP14Parser::NotEqual, 0);
}


size_t CPP14Parser::EqualityexpressionContext::getRuleIndex() const
{
	return CPP14Parser::RuleEqualityexpression;//688
}

void CPP14Parser::EqualityexpressionContext::copyFrom(EqualityexpressionContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::EqualityexpressionContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<EqualityexpressionContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::EqualityexpressionContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::EqualityexpressionContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::EqualityexpressionContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitEqualityexpression(this);
	else
		return visitor->visitChildren(this);
}


CPP14Parser::EqualityexpressionContext* CPP14Parser::equalityexpression()
{
	 return equalityexpression(0, nullptr);//600
}

CPP14Parser::EqualityexpressionContext* CPP14Parser::equalityexpression(int precedence, antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	antlr4::ParserRuleContext *parentContext = parent;
	size_t parentState = getState();
	auto _localctx = std::make_unique<EqualityexpressionContext>(parentContext, parentState);//610
	auto ctx = _localctx.get();//609
	size_t startState = 74;
	enterRecursionRule(ctx, 74, CPP14Parser::RuleEqualityexpression, precedence);

		

	auto onExit = finally([=,&_localctx]
{
		unrollRecursionContexts(parentContext, std::move(_localctx));
	});
	try
{
		size_t alt;
		enterOuterAlt(ctx, 1);
		setState(889); //951
		relationalexpression(0,ctx);
		ctx->stop = _input->LT(-1);
		setState(899);//865
		_errHandler->sync(this, ctx);
		alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 64, ctx);
		while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
		{
			if (alt == 1)
		{
				if (!_parseListeners.empty())
					triggerExitRuleEvent(ctx);

				setState(897);//830
				_errHandler->sync(this, ctx);
				switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 63, ctx))
				{
				case 1:
				{
					auto tmpContext = std::make_unique<EqualityexpressionContext>(parentContext, parentState);
					pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleEqualityexpression);//1240
					_localctx = std::move(tmpContext);
					ctx = _localctx.get();
					setState(891);//1002

					if (!(precpred(nullptr, 2))) throw FailedPredicateException(this, "precpred(nullptr, 2)", ctx);
					setState(892);//958
					match(CPP14Parser::Equal,ctx);
					setState(893); //951
					relationalexpression(0,ctx);
					break;
				}

				case 2:
				{
					auto tmpContext = std::make_unique<EqualityexpressionContext>(parentContext, parentState);
					pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleEqualityexpression);//1240
					_localctx = std::move(tmpContext);
					ctx = _localctx.get();
					setState(894);//1002

					if (!(precpred(nullptr, 1))) throw FailedPredicateException(this, "precpred(nullptr, 1)", ctx);
					setState(895);//958
					match(CPP14Parser::NotEqual,ctx);
					setState(896); //951
					relationalexpression(0,ctx);
					break;
				}

				} 
			}
			setState(901);//875
			_errHandler->sync(this, ctx);
			alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 64, ctx);
		}
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		_localctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}
	onExit();
	return ctx;
}

std::unique_ptr< CPP14Parser::EqualityexpressionContext> CPP14Parser::parseequalityexpression()
{
	equalityexpression();
	auto result = std::unique_ptr<EqualityexpressionContext>(dynamic_cast<EqualityexpressionContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}

//----------------- AndexpressionContext ------------------------------------------------------------------

CPP14Parser::AndexpressionContext::AndexpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::EqualityexpressionContext* CPP14Parser::AndexpressionContext::equalityexpression()
{
	return getRuleContext<CPP14Parser::EqualityexpressionContext>(0);//1165
}

CPP14Parser::AndexpressionContext* CPP14Parser::AndexpressionContext::andexpression()
{
	return getRuleContext<CPP14Parser::AndexpressionContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::AndexpressionContext::And()
{
	return getToken(CPP14Parser::And, 0);
}


size_t CPP14Parser::AndexpressionContext::getRuleIndex() const
{
	return CPP14Parser::RuleAndexpression;//688
}

void CPP14Parser::AndexpressionContext::copyFrom(AndexpressionContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::AndexpressionContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<AndexpressionContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::AndexpressionContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::AndexpressionContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::AndexpressionContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitAndexpression(this);
	else
		return visitor->visitChildren(this);
}


CPP14Parser::AndexpressionContext* CPP14Parser::andexpression()
{
	 return andexpression(0, nullptr);//600
}

CPP14Parser::AndexpressionContext* CPP14Parser::andexpression(int precedence, antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	antlr4::ParserRuleContext *parentContext = parent;
	size_t parentState = getState();
	auto _localctx = std::make_unique<AndexpressionContext>(parentContext, parentState);//610
	auto ctx = _localctx.get();//609
	size_t startState = 76;
	enterRecursionRule(ctx, 76, CPP14Parser::RuleAndexpression, precedence);

		

	auto onExit = finally([=,&_localctx]
{
		unrollRecursionContexts(parentContext, std::move(_localctx));
	});
	try
{
		size_t alt;
		enterOuterAlt(ctx, 1);
		setState(903); //951
		equalityexpression(0,ctx);
		ctx->stop = _input->LT(-1);
		setState(910);//865
		_errHandler->sync(this, ctx);
		alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 65, ctx);
		while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
		{
			if (alt == 1)
		{
				if (!_parseListeners.empty())
					triggerExitRuleEvent(ctx);

				auto tmpContext = std::make_unique<AndexpressionContext>(parentContext, parentState);
				pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleAndexpression);//1240
				_localctx = std::move(tmpContext);
				ctx = _localctx.get();
				setState(905);//1002

				if (!(precpred(nullptr, 1))) throw FailedPredicateException(this, "precpred(nullptr, 1)", ctx);
				setState(906);//958
				match(CPP14Parser::And,ctx);
				setState(907); //951
				equalityexpression(0,ctx); 
			}
			setState(912);//875
			_errHandler->sync(this, ctx);
			alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 65, ctx);
		}
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		_localctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}
	onExit();
	return ctx;
}

std::unique_ptr< CPP14Parser::AndexpressionContext> CPP14Parser::parseandexpression()
{
	andexpression();
	auto result = std::unique_ptr<AndexpressionContext>(dynamic_cast<AndexpressionContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}

//----------------- ExclusiveorexpressionContext ------------------------------------------------------------------

CPP14Parser::ExclusiveorexpressionContext::ExclusiveorexpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::AndexpressionContext* CPP14Parser::ExclusiveorexpressionContext::andexpression()
{
	return getRuleContext<CPP14Parser::AndexpressionContext>(0);//1165
}

CPP14Parser::ExclusiveorexpressionContext* CPP14Parser::ExclusiveorexpressionContext::exclusiveorexpression()
{
	return getRuleContext<CPP14Parser::ExclusiveorexpressionContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::ExclusiveorexpressionContext::Caret()
{
	return getToken(CPP14Parser::Caret, 0);
}


size_t CPP14Parser::ExclusiveorexpressionContext::getRuleIndex() const
{
	return CPP14Parser::RuleExclusiveorexpression;//688
}

void CPP14Parser::ExclusiveorexpressionContext::copyFrom(ExclusiveorexpressionContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::ExclusiveorexpressionContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<ExclusiveorexpressionContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::ExclusiveorexpressionContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::ExclusiveorexpressionContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::ExclusiveorexpressionContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitExclusiveorexpression(this);
	else
		return visitor->visitChildren(this);
}


CPP14Parser::ExclusiveorexpressionContext* CPP14Parser::exclusiveorexpression()
{
	 return exclusiveorexpression(0, nullptr);//600
}

CPP14Parser::ExclusiveorexpressionContext* CPP14Parser::exclusiveorexpression(int precedence, antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	antlr4::ParserRuleContext *parentContext = parent;
	size_t parentState = getState();
	auto _localctx = std::make_unique<ExclusiveorexpressionContext>(parentContext, parentState);//610
	auto ctx = _localctx.get();//609
	size_t startState = 78;
	enterRecursionRule(ctx, 78, CPP14Parser::RuleExclusiveorexpression, precedence);

		

	auto onExit = finally([=,&_localctx]
{
		unrollRecursionContexts(parentContext, std::move(_localctx));
	});
	try
{
		size_t alt;
		enterOuterAlt(ctx, 1);
		setState(914); //951
		andexpression(0,ctx);
		ctx->stop = _input->LT(-1);
		setState(921);//865
		_errHandler->sync(this, ctx);
		alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 66, ctx);
		while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
		{
			if (alt == 1)
		{
				if (!_parseListeners.empty())
					triggerExitRuleEvent(ctx);

				auto tmpContext = std::make_unique<ExclusiveorexpressionContext>(parentContext, parentState);
				pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleExclusiveorexpression);//1240
				_localctx = std::move(tmpContext);
				ctx = _localctx.get();
				setState(916);//1002

				if (!(precpred(nullptr, 1))) throw FailedPredicateException(this, "precpred(nullptr, 1)", ctx);
				setState(917);//958
				match(CPP14Parser::Caret,ctx);
				setState(918); //951
				andexpression(0,ctx); 
			}
			setState(923);//875
			_errHandler->sync(this, ctx);
			alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 66, ctx);
		}
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		_localctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}
	onExit();
	return ctx;
}

std::unique_ptr< CPP14Parser::ExclusiveorexpressionContext> CPP14Parser::parseexclusiveorexpression()
{
	exclusiveorexpression();
	auto result = std::unique_ptr<ExclusiveorexpressionContext>(dynamic_cast<ExclusiveorexpressionContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}

//----------------- InclusiveorexpressionContext ------------------------------------------------------------------

CPP14Parser::InclusiveorexpressionContext::InclusiveorexpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::ExclusiveorexpressionContext* CPP14Parser::InclusiveorexpressionContext::exclusiveorexpression()
{
	return getRuleContext<CPP14Parser::ExclusiveorexpressionContext>(0);//1165
}

CPP14Parser::InclusiveorexpressionContext* CPP14Parser::InclusiveorexpressionContext::inclusiveorexpression()
{
	return getRuleContext<CPP14Parser::InclusiveorexpressionContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::InclusiveorexpressionContext::Or()
{
	return getToken(CPP14Parser::Or, 0);
}


size_t CPP14Parser::InclusiveorexpressionContext::getRuleIndex() const
{
	return CPP14Parser::RuleInclusiveorexpression;//688
}

void CPP14Parser::InclusiveorexpressionContext::copyFrom(InclusiveorexpressionContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::InclusiveorexpressionContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<InclusiveorexpressionContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::InclusiveorexpressionContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::InclusiveorexpressionContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::InclusiveorexpressionContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitInclusiveorexpression(this);
	else
		return visitor->visitChildren(this);
}


CPP14Parser::InclusiveorexpressionContext* CPP14Parser::inclusiveorexpression()
{
	 return inclusiveorexpression(0, nullptr);//600
}

CPP14Parser::InclusiveorexpressionContext* CPP14Parser::inclusiveorexpression(int precedence, antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	antlr4::ParserRuleContext *parentContext = parent;
	size_t parentState = getState();
	auto _localctx = std::make_unique<InclusiveorexpressionContext>(parentContext, parentState);//610
	auto ctx = _localctx.get();//609
	size_t startState = 80;
	enterRecursionRule(ctx, 80, CPP14Parser::RuleInclusiveorexpression, precedence);

		

	auto onExit = finally([=,&_localctx]
{
		unrollRecursionContexts(parentContext, std::move(_localctx));
	});
	try
{
		size_t alt;
		enterOuterAlt(ctx, 1);
		setState(925); //951
		exclusiveorexpression(0,ctx);
		ctx->stop = _input->LT(-1);
		setState(932);//865
		_errHandler->sync(this, ctx);
		alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 67, ctx);
		while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
		{
			if (alt == 1)
		{
				if (!_parseListeners.empty())
					triggerExitRuleEvent(ctx);

				auto tmpContext = std::make_unique<InclusiveorexpressionContext>(parentContext, parentState);
				pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleInclusiveorexpression);//1240
				_localctx = std::move(tmpContext);
				ctx = _localctx.get();
				setState(927);//1002

				if (!(precpred(nullptr, 1))) throw FailedPredicateException(this, "precpred(nullptr, 1)", ctx);
				setState(928);//958
				match(CPP14Parser::Or,ctx);
				setState(929); //951
				exclusiveorexpression(0,ctx); 
			}
			setState(934);//875
			_errHandler->sync(this, ctx);
			alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 67, ctx);
		}
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		_localctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}
	onExit();
	return ctx;
}

std::unique_ptr< CPP14Parser::InclusiveorexpressionContext> CPP14Parser::parseinclusiveorexpression()
{
	inclusiveorexpression();
	auto result = std::unique_ptr<InclusiveorexpressionContext>(dynamic_cast<InclusiveorexpressionContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}

//----------------- LogicalandexpressionContext ------------------------------------------------------------------

CPP14Parser::LogicalandexpressionContext::LogicalandexpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::InclusiveorexpressionContext* CPP14Parser::LogicalandexpressionContext::inclusiveorexpression()
{
	return getRuleContext<CPP14Parser::InclusiveorexpressionContext>(0);//1165
}

CPP14Parser::LogicalandexpressionContext* CPP14Parser::LogicalandexpressionContext::logicalandexpression()
{
	return getRuleContext<CPP14Parser::LogicalandexpressionContext>(0);//1165
}


size_t CPP14Parser::LogicalandexpressionContext::getRuleIndex() const
{
	return CPP14Parser::RuleLogicalandexpression;//688
}

void CPP14Parser::LogicalandexpressionContext::copyFrom(LogicalandexpressionContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::LogicalandexpressionContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<LogicalandexpressionContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::LogicalandexpressionContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::LogicalandexpressionContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::LogicalandexpressionContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitLogicalandexpression(this);
	else
		return visitor->visitChildren(this);
}


CPP14Parser::LogicalandexpressionContext* CPP14Parser::logicalandexpression()
{
	 return logicalandexpression(0, nullptr);//600
}

CPP14Parser::LogicalandexpressionContext* CPP14Parser::logicalandexpression(int precedence, antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	antlr4::ParserRuleContext *parentContext = parent;
	size_t parentState = getState();
	auto _localctx = std::make_unique<LogicalandexpressionContext>(parentContext, parentState);//610
	auto ctx = _localctx.get();//609
	size_t startState = 82;
	enterRecursionRule(ctx, 82, CPP14Parser::RuleLogicalandexpression, precedence);

		

	auto onExit = finally([=,&_localctx]
{
		unrollRecursionContexts(parentContext, std::move(_localctx));
	});
	try
{
		size_t alt;
		enterOuterAlt(ctx, 1);
		setState(936); //951
		inclusiveorexpression(0,ctx);
		ctx->stop = _input->LT(-1);
		setState(946);//865
		_errHandler->sync(this, ctx);
		alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 69, ctx);
		while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
		{
			if (alt == 1)
		{
				if (!_parseListeners.empty())
					triggerExitRuleEvent(ctx);

				setState(944);//830
				_errHandler->sync(this, ctx);
				switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 68, ctx))
				{
				case 1:
				{
					auto tmpContext = std::make_unique<LogicalandexpressionContext>(parentContext, parentState);
					pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleLogicalandexpression);//1240
					_localctx = std::move(tmpContext);
					ctx = _localctx.get();
					setState(938);//1002

					if (!(precpred(nullptr, 2))) throw FailedPredicateException(this, "precpred(nullptr, 2)", ctx);
					setState(939);//958
					match(CPP14Parser::T__2,ctx);
					setState(940); //951
					inclusiveorexpression(0,ctx);
					break;
				}

				case 2:
				{
					auto tmpContext = std::make_unique<LogicalandexpressionContext>(parentContext, parentState);
					pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleLogicalandexpression);//1240
					_localctx = std::move(tmpContext);
					ctx = _localctx.get();
					setState(941);//1002

					if (!(precpred(nullptr, 1))) throw FailedPredicateException(this, "precpred(nullptr, 1)", ctx);
					setState(942);//958
					match(CPP14Parser::T__3,ctx);
					setState(943); //951
					inclusiveorexpression(0,ctx);
					break;
				}

				} 
			}
			setState(948);//875
			_errHandler->sync(this, ctx);
			alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 69, ctx);
		}
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		_localctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}
	onExit();
	return ctx;
}

std::unique_ptr< CPP14Parser::LogicalandexpressionContext> CPP14Parser::parselogicalandexpression()
{
	logicalandexpression();
	auto result = std::unique_ptr<LogicalandexpressionContext>(dynamic_cast<LogicalandexpressionContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}

//----------------- LogicalorexpressionContext ------------------------------------------------------------------

CPP14Parser::LogicalorexpressionContext::LogicalorexpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::LogicalandexpressionContext* CPP14Parser::LogicalorexpressionContext::logicalandexpression()
{
	return getRuleContext<CPP14Parser::LogicalandexpressionContext>(0);//1165
}

CPP14Parser::LogicalorexpressionContext* CPP14Parser::LogicalorexpressionContext::logicalorexpression()
{
	return getRuleContext<CPP14Parser::LogicalorexpressionContext>(0);//1165
}


size_t CPP14Parser::LogicalorexpressionContext::getRuleIndex() const
{
	return CPP14Parser::RuleLogicalorexpression;//688
}

void CPP14Parser::LogicalorexpressionContext::copyFrom(LogicalorexpressionContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::LogicalorexpressionContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<LogicalorexpressionContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::LogicalorexpressionContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::LogicalorexpressionContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::LogicalorexpressionContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitLogicalorexpression(this);
	else
		return visitor->visitChildren(this);
}


CPP14Parser::LogicalorexpressionContext* CPP14Parser::logicalorexpression()
{
	 return logicalorexpression(0, nullptr);//600
}

CPP14Parser::LogicalorexpressionContext* CPP14Parser::logicalorexpression(int precedence, antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	antlr4::ParserRuleContext *parentContext = parent;
	size_t parentState = getState();
	auto _localctx = std::make_unique<LogicalorexpressionContext>(parentContext, parentState);//610
	auto ctx = _localctx.get();//609
	size_t startState = 84;
	enterRecursionRule(ctx, 84, CPP14Parser::RuleLogicalorexpression, precedence);

		

	auto onExit = finally([=,&_localctx]
{
		unrollRecursionContexts(parentContext, std::move(_localctx));
	});
	try
{
		size_t alt;
		enterOuterAlt(ctx, 1);
		setState(950); //951
		logicalandexpression(0,ctx);
		ctx->stop = _input->LT(-1);
		setState(960);//865
		_errHandler->sync(this, ctx);
		alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 71, ctx);
		while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
		{
			if (alt == 1)
		{
				if (!_parseListeners.empty())
					triggerExitRuleEvent(ctx);

				setState(958);//830
				_errHandler->sync(this, ctx);
				switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 70, ctx))
				{
				case 1:
				{
					auto tmpContext = std::make_unique<LogicalorexpressionContext>(parentContext, parentState);
					pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleLogicalorexpression);//1240
					_localctx = std::move(tmpContext);
					ctx = _localctx.get();
					setState(952);//1002

					if (!(precpred(nullptr, 2))) throw FailedPredicateException(this, "precpred(nullptr, 2)", ctx);
					setState(953);//958
					match(CPP14Parser::T__4,ctx);
					setState(954); //951
					logicalandexpression(0,ctx);
					break;
				}

				case 2:
				{
					auto tmpContext = std::make_unique<LogicalorexpressionContext>(parentContext, parentState);
					pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleLogicalorexpression);//1240
					_localctx = std::move(tmpContext);
					ctx = _localctx.get();
					setState(955);//1002

					if (!(precpred(nullptr, 1))) throw FailedPredicateException(this, "precpred(nullptr, 1)", ctx);
					setState(956);//958
					match(CPP14Parser::T__5,ctx);
					setState(957); //951
					logicalandexpression(0,ctx);
					break;
				}

				} 
			}
			setState(962);//875
			_errHandler->sync(this, ctx);
			alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 71, ctx);
		}
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		_localctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}
	onExit();
	return ctx;
}

std::unique_ptr< CPP14Parser::LogicalorexpressionContext> CPP14Parser::parselogicalorexpression()
{
	logicalorexpression();
	auto result = std::unique_ptr<LogicalorexpressionContext>(dynamic_cast<LogicalorexpressionContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}

//----------------- ConditionalexpressionContext ------------------------------------------------------------------

CPP14Parser::ConditionalexpressionContext::ConditionalexpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::LogicalorexpressionContext* CPP14Parser::ConditionalexpressionContext::logicalorexpression()
{
	return getRuleContext<CPP14Parser::LogicalorexpressionContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::ConditionalexpressionContext::Question()
{
	return getToken(CPP14Parser::Question, 0);
}

CPP14Parser::ExpressionContext* CPP14Parser::ConditionalexpressionContext::expression()
{
	return getRuleContext<CPP14Parser::ExpressionContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::ConditionalexpressionContext::Colon()
{
	return getToken(CPP14Parser::Colon, 0);
}

CPP14Parser::AssignmentexpressionContext* CPP14Parser::ConditionalexpressionContext::assignmentexpression()
{
	return getRuleContext<CPP14Parser::AssignmentexpressionContext>(0);//1165
}


size_t CPP14Parser::ConditionalexpressionContext::getRuleIndex() const
{
	return CPP14Parser::RuleConditionalexpression;//688
}

void CPP14Parser::ConditionalexpressionContext::copyFrom(ConditionalexpressionContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::ConditionalexpressionContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<ConditionalexpressionContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::ConditionalexpressionContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::ConditionalexpressionContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::ConditionalexpressionContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitConditionalexpression(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::ConditionalexpressionContext* CPP14Parser::conditionalexpression( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<ConditionalexpressionContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 86, CPP14Parser::RuleConditionalexpression);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(970);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 72, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(963); //951
			logicalorexpression(0,ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(964); //951
			logicalorexpression(0,ctx);
			setState(965);//958
			match(CPP14Parser::Question,ctx);
			setState(966); //951
			expression(0,ctx);
			setState(967);//958
			match(CPP14Parser::Colon,ctx);
			setState(968); //951
			assignmentexpression(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::ConditionalexpressionContext> CPP14Parser::parseconditionalexpression()
{
	conditionalexpression();
	auto result = std::unique_ptr<ConditionalexpressionContext>(dynamic_cast<ConditionalexpressionContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- AssignmentexpressionContext ------------------------------------------------------------------

CPP14Parser::AssignmentexpressionContext::AssignmentexpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::ConditionalexpressionContext* CPP14Parser::AssignmentexpressionContext::conditionalexpression()
{
	return getRuleContext<CPP14Parser::ConditionalexpressionContext>(0);//1165
}

CPP14Parser::LogicalorexpressionContext* CPP14Parser::AssignmentexpressionContext::logicalorexpression()
{
	return getRuleContext<CPP14Parser::LogicalorexpressionContext>(0);//1165
}

CPP14Parser::AssignmentoperatorContext* CPP14Parser::AssignmentexpressionContext::assignmentoperator()
{
	return getRuleContext<CPP14Parser::AssignmentoperatorContext>(0);//1165
}

CPP14Parser::InitializerclauseContext* CPP14Parser::AssignmentexpressionContext::initializerclause()
{
	return getRuleContext<CPP14Parser::InitializerclauseContext>(0);//1165
}

CPP14Parser::ThrowexpressionContext* CPP14Parser::AssignmentexpressionContext::throwexpression()
{
	return getRuleContext<CPP14Parser::ThrowexpressionContext>(0);//1165
}


size_t CPP14Parser::AssignmentexpressionContext::getRuleIndex() const
{
	return CPP14Parser::RuleAssignmentexpression;//688
}

void CPP14Parser::AssignmentexpressionContext::copyFrom(AssignmentexpressionContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::AssignmentexpressionContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<AssignmentexpressionContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::AssignmentexpressionContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::AssignmentexpressionContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::AssignmentexpressionContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitAssignmentexpression(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::AssignmentexpressionContext* CPP14Parser::assignmentexpression( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<AssignmentexpressionContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 88, CPP14Parser::RuleAssignmentexpression);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(978);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 73, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(972); //951
			conditionalexpression(ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(973); //951
			logicalorexpression(0,ctx);
			setState(974); //951
			assignmentoperator(ctx);
			setState(975); //951
			initializerclause(ctx);
			break;
		}

		case 3:
		{
			enterOuterAlt(ctx, 3);
			setState(977); //951
			throwexpression(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::AssignmentexpressionContext> CPP14Parser::parseassignmentexpression()
{
	assignmentexpression();
	auto result = std::unique_ptr<AssignmentexpressionContext>(dynamic_cast<AssignmentexpressionContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- AssignmentoperatorContext ------------------------------------------------------------------

CPP14Parser::AssignmentoperatorContext::AssignmentoperatorContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::AssignmentoperatorContext::Assign()
{
	return getToken(CPP14Parser::Assign, 0);
}

tree::TerminalNode* CPP14Parser::AssignmentoperatorContext::StarAssign()
{
	return getToken(CPP14Parser::StarAssign, 0);
}

tree::TerminalNode* CPP14Parser::AssignmentoperatorContext::DivAssign()
{
	return getToken(CPP14Parser::DivAssign, 0);
}

tree::TerminalNode* CPP14Parser::AssignmentoperatorContext::ModAssign()
{
	return getToken(CPP14Parser::ModAssign, 0);
}

tree::TerminalNode* CPP14Parser::AssignmentoperatorContext::PlusAssign()
{
	return getToken(CPP14Parser::PlusAssign, 0);
}

tree::TerminalNode* CPP14Parser::AssignmentoperatorContext::MinusAssign()
{
	return getToken(CPP14Parser::MinusAssign, 0);
}

CPP14Parser::RightShiftAssignContext* CPP14Parser::AssignmentoperatorContext::rightShiftAssign()
{
	return getRuleContext<CPP14Parser::RightShiftAssignContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::AssignmentoperatorContext::LeftShiftAssign()
{
	return getToken(CPP14Parser::LeftShiftAssign, 0);
}

tree::TerminalNode* CPP14Parser::AssignmentoperatorContext::AndAssign()
{
	return getToken(CPP14Parser::AndAssign, 0);
}

tree::TerminalNode* CPP14Parser::AssignmentoperatorContext::XorAssign()
{
	return getToken(CPP14Parser::XorAssign, 0);
}

tree::TerminalNode* CPP14Parser::AssignmentoperatorContext::OrAssign()
{
	return getToken(CPP14Parser::OrAssign, 0);
}


size_t CPP14Parser::AssignmentoperatorContext::getRuleIndex() const
{
	return CPP14Parser::RuleAssignmentoperator;//688
}

void CPP14Parser::AssignmentoperatorContext::copyFrom(AssignmentoperatorContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::AssignmentoperatorContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<AssignmentoperatorContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::AssignmentoperatorContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::AssignmentoperatorContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::AssignmentoperatorContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitAssignmentoperator(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::AssignmentoperatorContext* CPP14Parser::assignmentoperator( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<AssignmentoperatorContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 90, CPP14Parser::RuleAssignmentoperator);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(991);//750
		_errHandler->sync(this, ctx);
		switch (_input->LA(1))
		{
			case CPP14Parser::Assign:
			{
				enterOuterAlt(ctx, 1);
				setState(980);//958
				match(CPP14Parser::Assign,ctx);
				break;
			}

			case CPP14Parser::StarAssign:
			{
				enterOuterAlt(ctx, 2);
				setState(981);//958
				match(CPP14Parser::StarAssign,ctx);
				break;
			}

			case CPP14Parser::DivAssign:
			{
				enterOuterAlt(ctx, 3);
				setState(982);//958
				match(CPP14Parser::DivAssign,ctx);
				break;
			}

			case CPP14Parser::ModAssign:
			{
				enterOuterAlt(ctx, 4);
				setState(983);//958
				match(CPP14Parser::ModAssign,ctx);
				break;
			}

			case CPP14Parser::PlusAssign:
			{
				enterOuterAlt(ctx, 5);
				setState(984);//958
				match(CPP14Parser::PlusAssign,ctx);
				break;
			}

			case CPP14Parser::MinusAssign:
			{
				enterOuterAlt(ctx, 6);
				setState(985);//958
				match(CPP14Parser::MinusAssign,ctx);
				break;
			}

			case CPP14Parser::GreaterThan:
			{
				enterOuterAlt(ctx, 7);
				setState(986); //951
				rightShiftAssign(ctx);
				break;
			}

			case CPP14Parser::LeftShiftAssign:
			{
				enterOuterAlt(ctx, 8);
				setState(987);//958
				match(CPP14Parser::LeftShiftAssign,ctx);
				break;
			}

			case CPP14Parser::AndAssign:
			{
				enterOuterAlt(ctx, 9);
				setState(988);//958
				match(CPP14Parser::AndAssign,ctx);
				break;
			}

			case CPP14Parser::XorAssign:
			{
				enterOuterAlt(ctx, 10);
				setState(989);//958
				match(CPP14Parser::XorAssign,ctx);
				break;
			}

			case CPP14Parser::OrAssign:
			{
				enterOuterAlt(ctx, 11);
				setState(990);//958
				match(CPP14Parser::OrAssign,ctx);
				break;
			}

		default:
			throw NoViableAltException(this, ctx);
		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::AssignmentoperatorContext> CPP14Parser::parseassignmentoperator()
{
	assignmentoperator();
	auto result = std::unique_ptr<AssignmentoperatorContext>(dynamic_cast<AssignmentoperatorContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- ExpressionContext ------------------------------------------------------------------

CPP14Parser::ExpressionContext::ExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::AssignmentexpressionContext* CPP14Parser::ExpressionContext::assignmentexpression()
{
	return getRuleContext<CPP14Parser::AssignmentexpressionContext>(0);//1165
}

CPP14Parser::ExpressionContext* CPP14Parser::ExpressionContext::expression()
{
	return getRuleContext<CPP14Parser::ExpressionContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::ExpressionContext::Comma()
{
	return getToken(CPP14Parser::Comma, 0);
}


size_t CPP14Parser::ExpressionContext::getRuleIndex() const
{
	return CPP14Parser::RuleExpression;//688
}

void CPP14Parser::ExpressionContext::copyFrom(ExpressionContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::ExpressionContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<ExpressionContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::ExpressionContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::ExpressionContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::ExpressionContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitExpression(this);
	else
		return visitor->visitChildren(this);
}


CPP14Parser::ExpressionContext* CPP14Parser::expression()
{
	 return expression(0, nullptr);//600
}

CPP14Parser::ExpressionContext* CPP14Parser::expression(int precedence, antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	antlr4::ParserRuleContext *parentContext = parent;
	size_t parentState = getState();
	auto _localctx = std::make_unique<ExpressionContext>(parentContext, parentState);//610
	auto ctx = _localctx.get();//609
	size_t startState = 92;
	enterRecursionRule(ctx, 92, CPP14Parser::RuleExpression, precedence);

		

	auto onExit = finally([=,&_localctx]
{
		unrollRecursionContexts(parentContext, std::move(_localctx));
	});
	try
{
		size_t alt;
		enterOuterAlt(ctx, 1);
		setState(994); //951
		assignmentexpression(ctx);
		ctx->stop = _input->LT(-1);
		setState(1001);//865
		_errHandler->sync(this, ctx);
		alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, ctx);
		while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
		{
			if (alt == 1)
		{
				if (!_parseListeners.empty())
					triggerExitRuleEvent(ctx);

				auto tmpContext = std::make_unique<ExpressionContext>(parentContext, parentState);
				pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleExpression);//1240
				_localctx = std::move(tmpContext);
				ctx = _localctx.get();
				setState(996);//1002

				if (!(precpred(nullptr, 1))) throw FailedPredicateException(this, "precpred(nullptr, 1)", ctx);
				setState(997);//958
				match(CPP14Parser::Comma,ctx);
				setState(998); //951
				assignmentexpression(ctx); 
			}
			setState(1003);//875
			_errHandler->sync(this, ctx);
			alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, ctx);
		}
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		_localctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}
	onExit();
	return ctx;
}

std::unique_ptr< CPP14Parser::ExpressionContext> CPP14Parser::parseexpression()
{
	expression();
	auto result = std::unique_ptr<ExpressionContext>(dynamic_cast<ExpressionContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}

//----------------- ConstantexpressionContext ------------------------------------------------------------------

CPP14Parser::ConstantexpressionContext::ConstantexpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::ConditionalexpressionContext* CPP14Parser::ConstantexpressionContext::conditionalexpression()
{
	return getRuleContext<CPP14Parser::ConditionalexpressionContext>(0);//1165
}


size_t CPP14Parser::ConstantexpressionContext::getRuleIndex() const
{
	return CPP14Parser::RuleConstantexpression;//688
}

void CPP14Parser::ConstantexpressionContext::copyFrom(ConstantexpressionContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::ConstantexpressionContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<ConstantexpressionContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::ConstantexpressionContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::ConstantexpressionContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::ConstantexpressionContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitConstantexpression(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::ConstantexpressionContext* CPP14Parser::constantexpression( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<ConstantexpressionContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 94, CPP14Parser::RuleConstantexpression);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1004); //951
		conditionalexpression(ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::ConstantexpressionContext> CPP14Parser::parseconstantexpression()
{
	constantexpression();
	auto result = std::unique_ptr<ConstantexpressionContext>(dynamic_cast<ConstantexpressionContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- StatementContext ------------------------------------------------------------------

CPP14Parser::StatementContext::StatementContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::LabeledstatementContext* CPP14Parser::StatementContext::labeledstatement()
{
	return getRuleContext<CPP14Parser::LabeledstatementContext>(0);//1165
}

CPP14Parser::ExpressionstatementContext* CPP14Parser::StatementContext::expressionstatement()
{
	return getRuleContext<CPP14Parser::ExpressionstatementContext>(0);//1165
}

CPP14Parser::AttributespecifierseqContext* CPP14Parser::StatementContext::attributespecifierseq()
{
	return getRuleContext<CPP14Parser::AttributespecifierseqContext>(0);//1165
}

CPP14Parser::CompoundstatementContext* CPP14Parser::StatementContext::compoundstatement()
{
	return getRuleContext<CPP14Parser::CompoundstatementContext>(0);//1165
}

CPP14Parser::SelectionstatementContext* CPP14Parser::StatementContext::selectionstatement()
{
	return getRuleContext<CPP14Parser::SelectionstatementContext>(0);//1165
}

CPP14Parser::IterationstatementContext* CPP14Parser::StatementContext::iterationstatement()
{
	return getRuleContext<CPP14Parser::IterationstatementContext>(0);//1165
}

CPP14Parser::JumpstatementContext* CPP14Parser::StatementContext::jumpstatement()
{
	return getRuleContext<CPP14Parser::JumpstatementContext>(0);//1165
}

CPP14Parser::DeclarationstatementContext* CPP14Parser::StatementContext::declarationstatement()
{
	return getRuleContext<CPP14Parser::DeclarationstatementContext>(0);//1165
}

CPP14Parser::TryblockContext* CPP14Parser::StatementContext::tryblock()
{
	return getRuleContext<CPP14Parser::TryblockContext>(0);//1165
}


size_t CPP14Parser::StatementContext::getRuleIndex() const
{
	return CPP14Parser::RuleStatement;//688
}

void CPP14Parser::StatementContext::copyFrom(StatementContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::StatementContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<StatementContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::StatementContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::StatementContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::StatementContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitStatement(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::StatementContext* CPP14Parser::statement( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<StatementContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 96, CPP14Parser::RuleStatement);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1032);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 82, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(1006); //951
			labeledstatement(ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(1008);//848
			_errHandler->sync(this, ctx);

			switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 76, ctx))
			{
			case 1:
			{
				setState(1007); //951
				attributespecifierseq(0,ctx);
				break;
			}

			}
			setState(1010); //951
			expressionstatement(ctx);
			break;
		}

		case 3:
		{
			enterOuterAlt(ctx, 3);
			setState(1012);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Alignas || _la == CPP14Parser::LeftBracket)
			{
				setState(1011); //951
				attributespecifierseq(0,ctx);
			}
			setState(1014); //951
			compoundstatement(ctx);
			break;
		}

		case 4:
		{
			enterOuterAlt(ctx, 4);
			setState(1016);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Alignas || _la == CPP14Parser::LeftBracket)
			{
				setState(1015); //951
				attributespecifierseq(0,ctx);
			}
			setState(1018); //951
			selectionstatement(ctx);
			break;
		}

		case 5:
		{
			enterOuterAlt(ctx, 5);
			setState(1020);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Alignas || _la == CPP14Parser::LeftBracket)
			{
				setState(1019); //951
				attributespecifierseq(0,ctx);
			}
			setState(1022); //951
			iterationstatement(ctx);
			break;
		}

		case 6:
		{
			enterOuterAlt(ctx, 6);
			setState(1024);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Alignas || _la == CPP14Parser::LeftBracket)
			{
				setState(1023); //951
				attributespecifierseq(0,ctx);
			}
			setState(1026); //951
			jumpstatement(ctx);
			break;
		}

		case 7:
		{
			enterOuterAlt(ctx, 7);
			setState(1027); //951
			declarationstatement(ctx);
			break;
		}

		case 8:
		{
			enterOuterAlt(ctx, 8);
			setState(1029);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Alignas || _la == CPP14Parser::LeftBracket)
			{
				setState(1028); //951
				attributespecifierseq(0,ctx);
			}
			setState(1031); //951
			tryblock(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::StatementContext> CPP14Parser::parsestatement()
{
	statement();
	auto result = std::unique_ptr<StatementContext>(dynamic_cast<StatementContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- LabeledstatementContext ------------------------------------------------------------------

CPP14Parser::LabeledstatementContext::LabeledstatementContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::LabeledstatementContext::Identifier()
{
	return getToken(CPP14Parser::Identifier, 0);
}

tree::TerminalNode* CPP14Parser::LabeledstatementContext::Colon()
{
	return getToken(CPP14Parser::Colon, 0);
}

CPP14Parser::StatementContext* CPP14Parser::LabeledstatementContext::statement()
{
	return getRuleContext<CPP14Parser::StatementContext>(0);//1165
}

CPP14Parser::AttributespecifierseqContext* CPP14Parser::LabeledstatementContext::attributespecifierseq()
{
	return getRuleContext<CPP14Parser::AttributespecifierseqContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::LabeledstatementContext::Case()
{
	return getToken(CPP14Parser::Case, 0);
}

CPP14Parser::ConstantexpressionContext* CPP14Parser::LabeledstatementContext::constantexpression()
{
	return getRuleContext<CPP14Parser::ConstantexpressionContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::LabeledstatementContext::Default()
{
	return getToken(CPP14Parser::Default, 0);
}


size_t CPP14Parser::LabeledstatementContext::getRuleIndex() const
{
	return CPP14Parser::RuleLabeledstatement;//688
}

void CPP14Parser::LabeledstatementContext::copyFrom(LabeledstatementContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::LabeledstatementContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<LabeledstatementContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::LabeledstatementContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::LabeledstatementContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::LabeledstatementContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitLabeledstatement(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::LabeledstatementContext* CPP14Parser::labeledstatement( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<LabeledstatementContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 98, CPP14Parser::RuleLabeledstatement);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1054);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 86, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(1035);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Alignas || _la == CPP14Parser::LeftBracket)
			{
				setState(1034); //951
				attributespecifierseq(0,ctx);
			}
			setState(1037);//958
			match(CPP14Parser::Identifier,ctx);
			setState(1038);//958
			match(CPP14Parser::Colon,ctx);
			setState(1039); //951
			statement(ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(1041);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Alignas || _la == CPP14Parser::LeftBracket)
			{
				setState(1040); //951
				attributespecifierseq(0,ctx);
			}
			setState(1043);//958
			match(CPP14Parser::Case,ctx);
			setState(1044); //951
			constantexpression(ctx);
			setState(1045);//958
			match(CPP14Parser::Colon,ctx);
			setState(1046); //951
			statement(ctx);
			break;
		}

		case 3:
		{
			enterOuterAlt(ctx, 3);
			setState(1049);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Alignas || _la == CPP14Parser::LeftBracket)
			{
				setState(1048); //951
				attributespecifierseq(0,ctx);
			}
			setState(1051);//958
			match(CPP14Parser::Default,ctx);
			setState(1052);//958
			match(CPP14Parser::Colon,ctx);
			setState(1053); //951
			statement(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::LabeledstatementContext> CPP14Parser::parselabeledstatement()
{
	labeledstatement();
	auto result = std::unique_ptr<LabeledstatementContext>(dynamic_cast<LabeledstatementContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- ExpressionstatementContext ------------------------------------------------------------------

CPP14Parser::ExpressionstatementContext::ExpressionstatementContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::ExpressionstatementContext::Semi()
{
	return getToken(CPP14Parser::Semi, 0);
}

CPP14Parser::ExpressionContext* CPP14Parser::ExpressionstatementContext::expression()
{
	return getRuleContext<CPP14Parser::ExpressionContext>(0);//1165
}


size_t CPP14Parser::ExpressionstatementContext::getRuleIndex() const
{
	return CPP14Parser::RuleExpressionstatement;//688
}

void CPP14Parser::ExpressionstatementContext::copyFrom(ExpressionstatementContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::ExpressionstatementContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<ExpressionstatementContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::ExpressionstatementContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::ExpressionstatementContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::ExpressionstatementContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitExpressionstatement(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::ExpressionstatementContext* CPP14Parser::expressionstatement( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<ExpressionstatementContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 100, CPP14Parser::RuleExpressionstatement);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1057);//788
		_errHandler->sync(this, ctx);

		_la = _input->LA(1);
		if ((((_la & ~ 0x3fULL) == 0) &&
			((1ULL << _la) & ((1ULL << CPP14Parser::T__0)
			| (1ULL << CPP14Parser::T__1)
			| (1ULL << CPP14Parser::Alignof)
			| (1ULL << CPP14Parser::Auto)
			| (1ULL << CPP14Parser::Bool)
			| (1ULL << CPP14Parser::Char)
			| (1ULL << CPP14Parser::Char16)
			| (1ULL << CPP14Parser::Char32)
			| (1ULL << CPP14Parser::Const_cast)
			| (1ULL << CPP14Parser::Decltype)
			| (1ULL << CPP14Parser::Delete)
			| (1ULL << CPP14Parser::Double)
			| (1ULL << CPP14Parser::Dynamic_cast)
			| (1ULL << CPP14Parser::False)
			| (1ULL << CPP14Parser::Float)
			| (1ULL << CPP14Parser::Int)
			| (1ULL << CPP14Parser::Long)
			| (1ULL << CPP14Parser::New)
			| (1ULL << CPP14Parser::Noexcept)
			| (1ULL << CPP14Parser::Nullptr)
			| (1ULL << CPP14Parser::Operator)
			| (1ULL << CPP14Parser::Reinterpret_cast)
			| (1ULL << CPP14Parser::Short)
			| (1ULL << CPP14Parser::Signed)
			| (1ULL << CPP14Parser::Sizeof))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
			((1ULL << (_la - 64)) & ((1ULL << (CPP14Parser::Static_cast - 64))
			| (1ULL << (CPP14Parser::This - 64))
			| (1ULL << (CPP14Parser::Throw - 64))
			| (1ULL << (CPP14Parser::True - 64))
			| (1ULL << (CPP14Parser::Typeid_ - 64))
			| (1ULL << (CPP14Parser::Typename_ - 64))
			| (1ULL << (CPP14Parser::Unsigned - 64))
			| (1ULL << (CPP14Parser::Void - 64))
			| (1ULL << (CPP14Parser::Wchar - 64))
			| (1ULL << (CPP14Parser::LeftParen - 64))
			| (1ULL << (CPP14Parser::LeftBracket - 64))
			| (1ULL << (CPP14Parser::Plus - 64))
			| (1ULL << (CPP14Parser::Minus - 64))
			| (1ULL << (CPP14Parser::Star - 64))
			| (1ULL << (CPP14Parser::And - 64))
			| (1ULL << (CPP14Parser::Or - 64))
			| (1ULL << (CPP14Parser::Tilde - 64))
			| (1ULL << (CPP14Parser::PlusPlus - 64))
			| (1ULL << (CPP14Parser::MinusMinus - 64))
			| (1ULL << (CPP14Parser::Doublecolon - 64)))) != 0) || ((((_la - 130) & ~ 0x3fULL) == 0) &&
			((1ULL << (_la - 130)) & ((1ULL << (CPP14Parser::Identifier - 130))
			| (1ULL << (CPP14Parser::Integerliteral - 130))
			| (1ULL << (CPP14Parser::Characterliteral - 130))
			| (1ULL << (CPP14Parser::Floatingliteral - 130))
			| (1ULL << (CPP14Parser::Stringliteral - 130))
			| (1ULL << (CPP14Parser::Userdefinedintegerliteral - 130))
			| (1ULL << (CPP14Parser::Userdefinedfloatingliteral - 130))
			| (1ULL << (CPP14Parser::Userdefinedstringliteral - 130))
			| (1ULL << (CPP14Parser::Userdefinedcharacterliteral - 130)))) != 0))
		{
			setState(1056); //951
			expression(0,ctx);
		}
		setState(1059);//958
		match(CPP14Parser::Semi,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::ExpressionstatementContext> CPP14Parser::parseexpressionstatement()
{
	expressionstatement();
	auto result = std::unique_ptr<ExpressionstatementContext>(dynamic_cast<ExpressionstatementContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- CompoundstatementContext ------------------------------------------------------------------

CPP14Parser::CompoundstatementContext::CompoundstatementContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::CompoundstatementContext::LeftBrace()
{
	return getToken(CPP14Parser::LeftBrace, 0);
}

tree::TerminalNode* CPP14Parser::CompoundstatementContext::RightBrace()
{
	return getToken(CPP14Parser::RightBrace, 0);
}

CPP14Parser::StatementseqContext* CPP14Parser::CompoundstatementContext::statementseq()
{
	return getRuleContext<CPP14Parser::StatementseqContext>(0);//1165
}


size_t CPP14Parser::CompoundstatementContext::getRuleIndex() const
{
	return CPP14Parser::RuleCompoundstatement;//688
}

void CPP14Parser::CompoundstatementContext::copyFrom(CompoundstatementContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::CompoundstatementContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<CompoundstatementContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::CompoundstatementContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::CompoundstatementContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::CompoundstatementContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitCompoundstatement(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::CompoundstatementContext* CPP14Parser::compoundstatement( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<CompoundstatementContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 102, CPP14Parser::RuleCompoundstatement);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1061);//958
		match(CPP14Parser::LeftBrace,ctx);
		setState(1063);//788
		_errHandler->sync(this, ctx);

		_la = _input->LA(1);
		if ((((_la & ~ 0x3fULL) == 0) &&
			((1ULL << _la) & ((1ULL << CPP14Parser::T__0)
			| (1ULL << CPP14Parser::T__1)
			| (1ULL << CPP14Parser::T__2)
			| (1ULL << CPP14Parser::Alignas)
			| (1ULL << CPP14Parser::Alignof)
			| (1ULL << CPP14Parser::Asm)
			| (1ULL << CPP14Parser::Auto)
			| (1ULL << CPP14Parser::Bool)
			| (1ULL << CPP14Parser::Break)
			| (1ULL << CPP14Parser::Case)
			| (1ULL << CPP14Parser::Char)
			| (1ULL << CPP14Parser::Char16)
			| (1ULL << CPP14Parser::Char32)
			| (1ULL << CPP14Parser::Class)
			| (1ULL << CPP14Parser::Const)
			| (1ULL << CPP14Parser::Constexpr)
			| (1ULL << CPP14Parser::Const_cast)
			| (1ULL << CPP14Parser::Continue)
			| (1ULL << CPP14Parser::Decltype)
			| (1ULL << CPP14Parser::Default)
			| (1ULL << CPP14Parser::Delete)
			| (1ULL << CPP14Parser::Do)
			| (1ULL << CPP14Parser::Double)
			| (1ULL << CPP14Parser::Dynamic_cast)
			| (1ULL << CPP14Parser::Enum)
			| (1ULL << CPP14Parser::Explicit)
			| (1ULL << CPP14Parser::Extern)
			| (1ULL << CPP14Parser::False)
			| (1ULL << CPP14Parser::Float)
			| (1ULL << CPP14Parser::For)
			| (1ULL << CPP14Parser::Friend)
			| (1ULL << CPP14Parser::Goto)
			| (1ULL << CPP14Parser::If)
			| (1ULL << CPP14Parser::Inline)
			| (1ULL << CPP14Parser::Int)
			| (1ULL << CPP14Parser::Long)
			| (1ULL << CPP14Parser::Mutable)
			| (1ULL << CPP14Parser::Namespace)
			| (1ULL << CPP14Parser::New)
			| (1ULL << CPP14Parser::Noexcept)
			| (1ULL << CPP14Parser::Nullptr)
			| (1ULL << CPP14Parser::Operator)
			| (1ULL << CPP14Parser::Register)
			| (1ULL << CPP14Parser::Reinterpret_cast)
			| (1ULL << CPP14Parser::Return)
			| (1ULL << CPP14Parser::Short)
			| (1ULL << CPP14Parser::Signed)
			| (1ULL << CPP14Parser::Sizeof)
			| (1ULL << CPP14Parser::Static)
			| (1ULL << CPP14Parser::Static_assert))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
			((1ULL << (_la - 64)) & ((1ULL << (CPP14Parser::Static_cast - 64))
			| (1ULL << (CPP14Parser::Struct - 64))
			| (1ULL << (CPP14Parser::Switch - 64))
			| (1ULL << (CPP14Parser::This - 64))
			| (1ULL << (CPP14Parser::Thread_local - 64))
			| (1ULL << (CPP14Parser::Throw - 64))
			| (1ULL << (CPP14Parser::True - 64))
			| (1ULL << (CPP14Parser::Try - 64))
			| (1ULL << (CPP14Parser::Typedef - 64))
			| (1ULL << (CPP14Parser::Typeid_ - 64))
			| (1ULL << (CPP14Parser::Typename_ - 64))
			| (1ULL << (CPP14Parser::Union - 64))
			| (1ULL << (CPP14Parser::Unsigned - 64))
			| (1ULL << (CPP14Parser::Using - 64))
			| (1ULL << (CPP14Parser::Virtual - 64))
			| (1ULL << (CPP14Parser::Void - 64))
			| (1ULL << (CPP14Parser::Volatile - 64))
			| (1ULL << (CPP14Parser::Wchar - 64))
			| (1ULL << (CPP14Parser::While - 64))
			| (1ULL << (CPP14Parser::LeftParen - 64))
			| (1ULL << (CPP14Parser::LeftBracket - 64))
			| (1ULL << (CPP14Parser::LeftBrace - 64))
			| (1ULL << (CPP14Parser::Plus - 64))
			| (1ULL << (CPP14Parser::Minus - 64))
			| (1ULL << (CPP14Parser::Star - 64))
			| (1ULL << (CPP14Parser::And - 64))
			| (1ULL << (CPP14Parser::Or - 64))
			| (1ULL << (CPP14Parser::Tilde - 64))
			| (1ULL << (CPP14Parser::PlusPlus - 64))
			| (1ULL << (CPP14Parser::MinusMinus - 64))
			| (1ULL << (CPP14Parser::Doublecolon - 64))
			| (1ULL << (CPP14Parser::Semi - 64)))) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
			((1ULL << (_la - 129)) & ((1ULL << (CPP14Parser::Ellipsis - 129))
			| (1ULL << (CPP14Parser::Identifier - 129))
			| (1ULL << (CPP14Parser::Integerliteral - 129))
			| (1ULL << (CPP14Parser::Characterliteral - 129))
			| (1ULL << (CPP14Parser::Floatingliteral - 129))
			| (1ULL << (CPP14Parser::Stringliteral - 129))
			| (1ULL << (CPP14Parser::Userdefinedintegerliteral - 129))
			| (1ULL << (CPP14Parser::Userdefinedfloatingliteral - 129))
			| (1ULL << (CPP14Parser::Userdefinedstringliteral - 129))
			| (1ULL << (CPP14Parser::Userdefinedcharacterliteral - 129)))) != 0))
		{
			setState(1062); //951
			statementseq(0,ctx);
		}
		setState(1065);//958
		match(CPP14Parser::RightBrace,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::CompoundstatementContext> CPP14Parser::parsecompoundstatement()
{
	compoundstatement();
	auto result = std::unique_ptr<CompoundstatementContext>(dynamic_cast<CompoundstatementContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- StatementseqContext ------------------------------------------------------------------

CPP14Parser::StatementseqContext::StatementseqContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::StatementContext* CPP14Parser::StatementseqContext::statement()
{
	return getRuleContext<CPP14Parser::StatementContext>(0);//1165
}

CPP14Parser::StatementseqContext* CPP14Parser::StatementseqContext::statementseq()
{
	return getRuleContext<CPP14Parser::StatementseqContext>(0);//1165
}


size_t CPP14Parser::StatementseqContext::getRuleIndex() const
{
	return CPP14Parser::RuleStatementseq;//688
}

void CPP14Parser::StatementseqContext::copyFrom(StatementseqContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::StatementseqContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<StatementseqContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::StatementseqContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::StatementseqContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::StatementseqContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitStatementseq(this);
	else
		return visitor->visitChildren(this);
}


CPP14Parser::StatementseqContext* CPP14Parser::statementseq()
{
	 return statementseq(0, nullptr);//600
}

CPP14Parser::StatementseqContext* CPP14Parser::statementseq(int precedence, antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	antlr4::ParserRuleContext *parentContext = parent;
	size_t parentState = getState();
	auto _localctx = std::make_unique<StatementseqContext>(parentContext, parentState);//610
	auto ctx = _localctx.get();//609
	size_t startState = 104;
	enterRecursionRule(ctx, 104, CPP14Parser::RuleStatementseq, precedence);

		

	auto onExit = finally([=,&_localctx]
{
		unrollRecursionContexts(parentContext, std::move(_localctx));
	});
	try
{
		size_t alt;
		enterOuterAlt(ctx, 1);
		setState(1068); //951
		statement(ctx);
		ctx->stop = _input->LT(-1);
		setState(1074);//865
		_errHandler->sync(this, ctx);
		alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 89, ctx);
		while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
		{
			if (alt == 1)
		{
				if (!_parseListeners.empty())
					triggerExitRuleEvent(ctx);

				auto tmpContext = std::make_unique<StatementseqContext>(parentContext, parentState);
				pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleStatementseq);//1240
				_localctx = std::move(tmpContext);
				ctx = _localctx.get();
				setState(1070);//1002

				if (!(precpred(nullptr, 1))) throw FailedPredicateException(this, "precpred(nullptr, 1)", ctx);
				setState(1071); //951
				statement(ctx); 
			}
			setState(1076);//875
			_errHandler->sync(this, ctx);
			alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 89, ctx);
		}
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		_localctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}
	onExit();
	return ctx;
}

std::unique_ptr< CPP14Parser::StatementseqContext> CPP14Parser::parsestatementseq()
{
	statementseq();
	auto result = std::unique_ptr<StatementseqContext>(dynamic_cast<StatementseqContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}

//----------------- SelectionstatementContext ------------------------------------------------------------------

CPP14Parser::SelectionstatementContext::SelectionstatementContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::SelectionstatementContext::If()
{
	return getToken(CPP14Parser::If, 0);
}

tree::TerminalNode* CPP14Parser::SelectionstatementContext::LeftParen()
{
	return getToken(CPP14Parser::LeftParen, 0);
}

CPP14Parser::ConditionContext* CPP14Parser::SelectionstatementContext::condition()
{
	return getRuleContext<CPP14Parser::ConditionContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::SelectionstatementContext::RightParen()
{
	return getToken(CPP14Parser::RightParen, 0);
}

std::vector<CPP14Parser::StatementContext *> CPP14Parser::SelectionstatementContext::statement()
{
	return getRuleContexts<CPP14Parser::StatementContext>();//1174
}

CPP14Parser::StatementContext* CPP14Parser::SelectionstatementContext::statement(size_t i)
{
	return getRuleContext<CPP14Parser::StatementContext>(i);//1183
}

tree::TerminalNode* CPP14Parser::SelectionstatementContext::Else()
{
	return getToken(CPP14Parser::Else, 0);
}

tree::TerminalNode* CPP14Parser::SelectionstatementContext::Switch()
{
	return getToken(CPP14Parser::Switch, 0);
}


size_t CPP14Parser::SelectionstatementContext::getRuleIndex() const
{
	return CPP14Parser::RuleSelectionstatement;//688
}

void CPP14Parser::SelectionstatementContext::copyFrom(SelectionstatementContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::SelectionstatementContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<SelectionstatementContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::SelectionstatementContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::SelectionstatementContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::SelectionstatementContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitSelectionstatement(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::SelectionstatementContext* CPP14Parser::selectionstatement( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<SelectionstatementContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 106, CPP14Parser::RuleSelectionstatement);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1097);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 90, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(1077);//958
			match(CPP14Parser::If,ctx);
			setState(1078);//958
			match(CPP14Parser::LeftParen,ctx);
			setState(1079); //951
			condition(ctx);
			setState(1080);//958
			match(CPP14Parser::RightParen,ctx);
			setState(1081); //951
			statement(ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(1083);//958
			match(CPP14Parser::If,ctx);
			setState(1084);//958
			match(CPP14Parser::LeftParen,ctx);
			setState(1085); //951
			condition(ctx);
			setState(1086);//958
			match(CPP14Parser::RightParen,ctx);
			setState(1087); //951
			statement(ctx);
			setState(1088);//958
			match(CPP14Parser::Else,ctx);
			setState(1089); //951
			statement(ctx);
			break;
		}

		case 3:
		{
			enterOuterAlt(ctx, 3);
			setState(1091);//958
			match(CPP14Parser::Switch,ctx);
			setState(1092);//958
			match(CPP14Parser::LeftParen,ctx);
			setState(1093); //951
			condition(ctx);
			setState(1094);//958
			match(CPP14Parser::RightParen,ctx);
			setState(1095); //951
			statement(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::SelectionstatementContext> CPP14Parser::parseselectionstatement()
{
	selectionstatement();
	auto result = std::unique_ptr<SelectionstatementContext>(dynamic_cast<SelectionstatementContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- ConditionContext ------------------------------------------------------------------

CPP14Parser::ConditionContext::ConditionContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::ExpressionContext* CPP14Parser::ConditionContext::expression()
{
	return getRuleContext<CPP14Parser::ExpressionContext>(0);//1165
}

CPP14Parser::DeclspecifierseqContext* CPP14Parser::ConditionContext::declspecifierseq()
{
	return getRuleContext<CPP14Parser::DeclspecifierseqContext>(0);//1165
}

CPP14Parser::DeclaratorContext* CPP14Parser::ConditionContext::declarator()
{
	return getRuleContext<CPP14Parser::DeclaratorContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::ConditionContext::Assign()
{
	return getToken(CPP14Parser::Assign, 0);
}

CPP14Parser::InitializerclauseContext* CPP14Parser::ConditionContext::initializerclause()
{
	return getRuleContext<CPP14Parser::InitializerclauseContext>(0);//1165
}

CPP14Parser::AttributespecifierseqContext* CPP14Parser::ConditionContext::attributespecifierseq()
{
	return getRuleContext<CPP14Parser::AttributespecifierseqContext>(0);//1165
}

CPP14Parser::BracedinitlistContext* CPP14Parser::ConditionContext::bracedinitlist()
{
	return getRuleContext<CPP14Parser::BracedinitlistContext>(0);//1165
}


size_t CPP14Parser::ConditionContext::getRuleIndex() const
{
	return CPP14Parser::RuleCondition;//688
}

void CPP14Parser::ConditionContext::copyFrom(ConditionContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::ConditionContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<ConditionContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::ConditionContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::ConditionContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::ConditionContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitCondition(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::ConditionContext* CPP14Parser::condition( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<ConditionContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 108, CPP14Parser::RuleCondition);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1115);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 93, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(1099); //951
			expression(0,ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(1101);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Alignas || _la == CPP14Parser::LeftBracket)
			{
				setState(1100); //951
				attributespecifierseq(0,ctx);
			}
			setState(1103); //951
			declspecifierseq(ctx);
			setState(1104); //951
			declarator(ctx);
			setState(1105);//958
			match(CPP14Parser::Assign,ctx);
			setState(1106); //951
			initializerclause(ctx);
			break;
		}

		case 3:
		{
			enterOuterAlt(ctx, 3);
			setState(1109);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Alignas || _la == CPP14Parser::LeftBracket)
			{
				setState(1108); //951
				attributespecifierseq(0,ctx);
			}
			setState(1111); //951
			declspecifierseq(ctx);
			setState(1112); //951
			declarator(ctx);
			setState(1113); //951
			bracedinitlist(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::ConditionContext> CPP14Parser::parsecondition()
{
	condition();
	auto result = std::unique_ptr<ConditionContext>(dynamic_cast<ConditionContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- IterationstatementContext ------------------------------------------------------------------

CPP14Parser::IterationstatementContext::IterationstatementContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::IterationstatementContext::While()
{
	return getToken(CPP14Parser::While, 0);
}

tree::TerminalNode* CPP14Parser::IterationstatementContext::LeftParen()
{
	return getToken(CPP14Parser::LeftParen, 0);
}

CPP14Parser::ConditionContext* CPP14Parser::IterationstatementContext::condition()
{
	return getRuleContext<CPP14Parser::ConditionContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::IterationstatementContext::RightParen()
{
	return getToken(CPP14Parser::RightParen, 0);
}

CPP14Parser::StatementContext* CPP14Parser::IterationstatementContext::statement()
{
	return getRuleContext<CPP14Parser::StatementContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::IterationstatementContext::Do()
{
	return getToken(CPP14Parser::Do, 0);
}

CPP14Parser::ExpressionContext* CPP14Parser::IterationstatementContext::expression()
{
	return getRuleContext<CPP14Parser::ExpressionContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::IterationstatementContext::Semi()
{
	return getToken(CPP14Parser::Semi, 0);
}

tree::TerminalNode* CPP14Parser::IterationstatementContext::For()
{
	return getToken(CPP14Parser::For, 0);
}

CPP14Parser::ForinitstatementContext* CPP14Parser::IterationstatementContext::forinitstatement()
{
	return getRuleContext<CPP14Parser::ForinitstatementContext>(0);//1165
}

CPP14Parser::ForrangedeclarationContext* CPP14Parser::IterationstatementContext::forrangedeclaration()
{
	return getRuleContext<CPP14Parser::ForrangedeclarationContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::IterationstatementContext::Colon()
{
	return getToken(CPP14Parser::Colon, 0);
}

CPP14Parser::ForrangeinitializerContext* CPP14Parser::IterationstatementContext::forrangeinitializer()
{
	return getRuleContext<CPP14Parser::ForrangeinitializerContext>(0);//1165
}


size_t CPP14Parser::IterationstatementContext::getRuleIndex() const
{
	return CPP14Parser::RuleIterationstatement;//688
}

void CPP14Parser::IterationstatementContext::copyFrom(IterationstatementContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::IterationstatementContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<IterationstatementContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::IterationstatementContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::IterationstatementContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::IterationstatementContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitIterationstatement(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::IterationstatementContext* CPP14Parser::iterationstatement( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<IterationstatementContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 110, CPP14Parser::RuleIterationstatement);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1152);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 96, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(1117);//958
			match(CPP14Parser::While,ctx);
			setState(1118);//958
			match(CPP14Parser::LeftParen,ctx);
			setState(1119); //951
			condition(ctx);
			setState(1120);//958
			match(CPP14Parser::RightParen,ctx);
			setState(1121); //951
			statement(ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(1123);//958
			match(CPP14Parser::Do,ctx);
			setState(1124); //951
			statement(ctx);
			setState(1125);//958
			match(CPP14Parser::While,ctx);
			setState(1126);//958
			match(CPP14Parser::LeftParen,ctx);
			setState(1127); //951
			expression(0,ctx);
			setState(1128);//958
			match(CPP14Parser::RightParen,ctx);
			setState(1129);//958
			match(CPP14Parser::Semi,ctx);
			break;
		}

		case 3:
		{
			enterOuterAlt(ctx, 3);
			setState(1131);//958
			match(CPP14Parser::For,ctx);
			setState(1132);//958
			match(CPP14Parser::LeftParen,ctx);
			setState(1133); //951
			forinitstatement(ctx);
			setState(1135);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if ((((_la & ~ 0x3fULL) == 0) &&
				((1ULL << _la) & ((1ULL << CPP14Parser::T__0)
				| (1ULL << CPP14Parser::T__1)
				| (1ULL << CPP14Parser::Alignas)
				| (1ULL << CPP14Parser::Alignof)
				| (1ULL << CPP14Parser::Auto)
				| (1ULL << CPP14Parser::Bool)
				| (1ULL << CPP14Parser::Char)
				| (1ULL << CPP14Parser::Char16)
				| (1ULL << CPP14Parser::Char32)
				| (1ULL << CPP14Parser::Class)
				| (1ULL << CPP14Parser::Const)
				| (1ULL << CPP14Parser::Constexpr)
				| (1ULL << CPP14Parser::Const_cast)
				| (1ULL << CPP14Parser::Decltype)
				| (1ULL << CPP14Parser::Delete)
				| (1ULL << CPP14Parser::Double)
				| (1ULL << CPP14Parser::Dynamic_cast)
				| (1ULL << CPP14Parser::Enum)
				| (1ULL << CPP14Parser::Explicit)
				| (1ULL << CPP14Parser::Extern)
				| (1ULL << CPP14Parser::False)
				| (1ULL << CPP14Parser::Float)
				| (1ULL << CPP14Parser::Friend)
				| (1ULL << CPP14Parser::Inline)
				| (1ULL << CPP14Parser::Int)
				| (1ULL << CPP14Parser::Long)
				| (1ULL << CPP14Parser::Mutable)
				| (1ULL << CPP14Parser::New)
				| (1ULL << CPP14Parser::Noexcept)
				| (1ULL << CPP14Parser::Nullptr)
				| (1ULL << CPP14Parser::Operator)
				| (1ULL << CPP14Parser::Register)
				| (1ULL << CPP14Parser::Reinterpret_cast)
				| (1ULL << CPP14Parser::Short)
				| (1ULL << CPP14Parser::Signed)
				| (1ULL << CPP14Parser::Sizeof)
				| (1ULL << CPP14Parser::Static))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
				((1ULL << (_la - 64)) & ((1ULL << (CPP14Parser::Static_cast - 64))
				| (1ULL << (CPP14Parser::Struct - 64))
				| (1ULL << (CPP14Parser::This - 64))
				| (1ULL << (CPP14Parser::Thread_local - 64))
				| (1ULL << (CPP14Parser::Throw - 64))
				| (1ULL << (CPP14Parser::True - 64))
				| (1ULL << (CPP14Parser::Typedef - 64))
				| (1ULL << (CPP14Parser::Typeid_ - 64))
				| (1ULL << (CPP14Parser::Typename_ - 64))
				| (1ULL << (CPP14Parser::Union - 64))
				| (1ULL << (CPP14Parser::Unsigned - 64))
				| (1ULL << (CPP14Parser::Virtual - 64))
				| (1ULL << (CPP14Parser::Void - 64))
				| (1ULL << (CPP14Parser::Volatile - 64))
				| (1ULL << (CPP14Parser::Wchar - 64))
				| (1ULL << (CPP14Parser::LeftParen - 64))
				| (1ULL << (CPP14Parser::LeftBracket - 64))
				| (1ULL << (CPP14Parser::Plus - 64))
				| (1ULL << (CPP14Parser::Minus - 64))
				| (1ULL << (CPP14Parser::Star - 64))
				| (1ULL << (CPP14Parser::And - 64))
				| (1ULL << (CPP14Parser::Or - 64))
				| (1ULL << (CPP14Parser::Tilde - 64))
				| (1ULL << (CPP14Parser::PlusPlus - 64))
				| (1ULL << (CPP14Parser::MinusMinus - 64))
				| (1ULL << (CPP14Parser::Doublecolon - 64)))) != 0) || ((((_la - 130) & ~ 0x3fULL) == 0) &&
				((1ULL << (_la - 130)) & ((1ULL << (CPP14Parser::Identifier - 130))
				| (1ULL << (CPP14Parser::Integerliteral - 130))
				| (1ULL << (CPP14Parser::Characterliteral - 130))
				| (1ULL << (CPP14Parser::Floatingliteral - 130))
				| (1ULL << (CPP14Parser::Stringliteral - 130))
				| (1ULL << (CPP14Parser::Userdefinedintegerliteral - 130))
				| (1ULL << (CPP14Parser::Userdefinedfloatingliteral - 130))
				| (1ULL << (CPP14Parser::Userdefinedstringliteral - 130))
				| (1ULL << (CPP14Parser::Userdefinedcharacterliteral - 130)))) != 0))
			{
				setState(1134); //951
				condition(ctx);
			}
			setState(1137);//958
			match(CPP14Parser::Semi,ctx);
			setState(1139);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if ((((_la & ~ 0x3fULL) == 0) &&
				((1ULL << _la) & ((1ULL << CPP14Parser::T__0)
				| (1ULL << CPP14Parser::T__1)
				| (1ULL << CPP14Parser::Alignof)
				| (1ULL << CPP14Parser::Auto)
				| (1ULL << CPP14Parser::Bool)
				| (1ULL << CPP14Parser::Char)
				| (1ULL << CPP14Parser::Char16)
				| (1ULL << CPP14Parser::Char32)
				| (1ULL << CPP14Parser::Const_cast)
				| (1ULL << CPP14Parser::Decltype)
				| (1ULL << CPP14Parser::Delete)
				| (1ULL << CPP14Parser::Double)
				| (1ULL << CPP14Parser::Dynamic_cast)
				| (1ULL << CPP14Parser::False)
				| (1ULL << CPP14Parser::Float)
				| (1ULL << CPP14Parser::Int)
				| (1ULL << CPP14Parser::Long)
				| (1ULL << CPP14Parser::New)
				| (1ULL << CPP14Parser::Noexcept)
				| (1ULL << CPP14Parser::Nullptr)
				| (1ULL << CPP14Parser::Operator)
				| (1ULL << CPP14Parser::Reinterpret_cast)
				| (1ULL << CPP14Parser::Short)
				| (1ULL << CPP14Parser::Signed)
				| (1ULL << CPP14Parser::Sizeof))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
				((1ULL << (_la - 64)) & ((1ULL << (CPP14Parser::Static_cast - 64))
				| (1ULL << (CPP14Parser::This - 64))
				| (1ULL << (CPP14Parser::Throw - 64))
				| (1ULL << (CPP14Parser::True - 64))
				| (1ULL << (CPP14Parser::Typeid_ - 64))
				| (1ULL << (CPP14Parser::Typename_ - 64))
				| (1ULL << (CPP14Parser::Unsigned - 64))
				| (1ULL << (CPP14Parser::Void - 64))
				| (1ULL << (CPP14Parser::Wchar - 64))
				| (1ULL << (CPP14Parser::LeftParen - 64))
				| (1ULL << (CPP14Parser::LeftBracket - 64))
				| (1ULL << (CPP14Parser::Plus - 64))
				| (1ULL << (CPP14Parser::Minus - 64))
				| (1ULL << (CPP14Parser::Star - 64))
				| (1ULL << (CPP14Parser::And - 64))
				| (1ULL << (CPP14Parser::Or - 64))
				| (1ULL << (CPP14Parser::Tilde - 64))
				| (1ULL << (CPP14Parser::PlusPlus - 64))
				| (1ULL << (CPP14Parser::MinusMinus - 64))
				| (1ULL << (CPP14Parser::Doublecolon - 64)))) != 0) || ((((_la - 130) & ~ 0x3fULL) == 0) &&
				((1ULL << (_la - 130)) & ((1ULL << (CPP14Parser::Identifier - 130))
				| (1ULL << (CPP14Parser::Integerliteral - 130))
				| (1ULL << (CPP14Parser::Characterliteral - 130))
				| (1ULL << (CPP14Parser::Floatingliteral - 130))
				| (1ULL << (CPP14Parser::Stringliteral - 130))
				| (1ULL << (CPP14Parser::Userdefinedintegerliteral - 130))
				| (1ULL << (CPP14Parser::Userdefinedfloatingliteral - 130))
				| (1ULL << (CPP14Parser::Userdefinedstringliteral - 130))
				| (1ULL << (CPP14Parser::Userdefinedcharacterliteral - 130)))) != 0))
			{
				setState(1138); //951
				expression(0,ctx);
			}
			setState(1141);//958
			match(CPP14Parser::RightParen,ctx);
			setState(1142); //951
			statement(ctx);
			break;
		}

		case 4:
		{
			enterOuterAlt(ctx, 4);
			setState(1144);//958
			match(CPP14Parser::For,ctx);
			setState(1145);//958
			match(CPP14Parser::LeftParen,ctx);
			setState(1146); //951
			forrangedeclaration(ctx);
			setState(1147);//958
			match(CPP14Parser::Colon,ctx);
			setState(1148); //951
			forrangeinitializer(ctx);
			setState(1149);//958
			match(CPP14Parser::RightParen,ctx);
			setState(1150); //951
			statement(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::IterationstatementContext> CPP14Parser::parseiterationstatement()
{
	iterationstatement();
	auto result = std::unique_ptr<IterationstatementContext>(dynamic_cast<IterationstatementContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- ForinitstatementContext ------------------------------------------------------------------

CPP14Parser::ForinitstatementContext::ForinitstatementContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::ExpressionstatementContext* CPP14Parser::ForinitstatementContext::expressionstatement()
{
	return getRuleContext<CPP14Parser::ExpressionstatementContext>(0);//1165
}

CPP14Parser::SimpledeclarationContext* CPP14Parser::ForinitstatementContext::simpledeclaration()
{
	return getRuleContext<CPP14Parser::SimpledeclarationContext>(0);//1165
}


size_t CPP14Parser::ForinitstatementContext::getRuleIndex() const
{
	return CPP14Parser::RuleForinitstatement;//688
}

void CPP14Parser::ForinitstatementContext::copyFrom(ForinitstatementContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::ForinitstatementContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<ForinitstatementContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::ForinitstatementContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::ForinitstatementContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::ForinitstatementContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitForinitstatement(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::ForinitstatementContext* CPP14Parser::forinitstatement( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<ForinitstatementContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 112, CPP14Parser::RuleForinitstatement);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1156);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 97, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(1154); //951
			expressionstatement(ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(1155); //951
			simpledeclaration(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::ForinitstatementContext> CPP14Parser::parseforinitstatement()
{
	forinitstatement();
	auto result = std::unique_ptr<ForinitstatementContext>(dynamic_cast<ForinitstatementContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- ForrangedeclarationContext ------------------------------------------------------------------

CPP14Parser::ForrangedeclarationContext::ForrangedeclarationContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::DeclspecifierseqContext* CPP14Parser::ForrangedeclarationContext::declspecifierseq()
{
	return getRuleContext<CPP14Parser::DeclspecifierseqContext>(0);//1165
}

CPP14Parser::DeclaratorContext* CPP14Parser::ForrangedeclarationContext::declarator()
{
	return getRuleContext<CPP14Parser::DeclaratorContext>(0);//1165
}

CPP14Parser::AttributespecifierseqContext* CPP14Parser::ForrangedeclarationContext::attributespecifierseq()
{
	return getRuleContext<CPP14Parser::AttributespecifierseqContext>(0);//1165
}


size_t CPP14Parser::ForrangedeclarationContext::getRuleIndex() const
{
	return CPP14Parser::RuleForrangedeclaration;//688
}

void CPP14Parser::ForrangedeclarationContext::copyFrom(ForrangedeclarationContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::ForrangedeclarationContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<ForrangedeclarationContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::ForrangedeclarationContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::ForrangedeclarationContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::ForrangedeclarationContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitForrangedeclaration(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::ForrangedeclarationContext* CPP14Parser::forrangedeclaration( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<ForrangedeclarationContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 114, CPP14Parser::RuleForrangedeclaration);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1159);//788
		_errHandler->sync(this, ctx);

		_la = _input->LA(1);
		if (_la == CPP14Parser::Alignas || _la == CPP14Parser::LeftBracket)
		{
			setState(1158); //951
			attributespecifierseq(0,ctx);
		}
		setState(1161); //951
		declspecifierseq(ctx);
		setState(1162); //951
		declarator(ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::ForrangedeclarationContext> CPP14Parser::parseforrangedeclaration()
{
	forrangedeclaration();
	auto result = std::unique_ptr<ForrangedeclarationContext>(dynamic_cast<ForrangedeclarationContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- ForrangeinitializerContext ------------------------------------------------------------------

CPP14Parser::ForrangeinitializerContext::ForrangeinitializerContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::ExpressionContext* CPP14Parser::ForrangeinitializerContext::expression()
{
	return getRuleContext<CPP14Parser::ExpressionContext>(0);//1165
}

CPP14Parser::BracedinitlistContext* CPP14Parser::ForrangeinitializerContext::bracedinitlist()
{
	return getRuleContext<CPP14Parser::BracedinitlistContext>(0);//1165
}


size_t CPP14Parser::ForrangeinitializerContext::getRuleIndex() const
{
	return CPP14Parser::RuleForrangeinitializer;//688
}

void CPP14Parser::ForrangeinitializerContext::copyFrom(ForrangeinitializerContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::ForrangeinitializerContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<ForrangeinitializerContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::ForrangeinitializerContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::ForrangeinitializerContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::ForrangeinitializerContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitForrangeinitializer(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::ForrangeinitializerContext* CPP14Parser::forrangeinitializer( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<ForrangeinitializerContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 116, CPP14Parser::RuleForrangeinitializer);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1166);//750
		_errHandler->sync(this, ctx);
		switch (_input->LA(1))
		{
			case CPP14Parser::T__0:
			case CPP14Parser::T__1:
			case CPP14Parser::Alignof:
			case CPP14Parser::Auto:
			case CPP14Parser::Bool:
			case CPP14Parser::Char:
			case CPP14Parser::Char16:
			case CPP14Parser::Char32:
			case CPP14Parser::Const_cast:
			case CPP14Parser::Decltype:
			case CPP14Parser::Delete:
			case CPP14Parser::Double:
			case CPP14Parser::Dynamic_cast:
			case CPP14Parser::False:
			case CPP14Parser::Float:
			case CPP14Parser::Int:
			case CPP14Parser::Long:
			case CPP14Parser::New:
			case CPP14Parser::Noexcept:
			case CPP14Parser::Nullptr:
			case CPP14Parser::Operator:
			case CPP14Parser::Reinterpret_cast:
			case CPP14Parser::Short:
			case CPP14Parser::Signed:
			case CPP14Parser::Sizeof:
			case CPP14Parser::Static_cast:
			case CPP14Parser::This:
			case CPP14Parser::Throw:
			case CPP14Parser::True:
			case CPP14Parser::Typeid_:
			case CPP14Parser::Typename_:
			case CPP14Parser::Unsigned:
			case CPP14Parser::Void:
			case CPP14Parser::Wchar:
			case CPP14Parser::LeftParen:
			case CPP14Parser::LeftBracket:
			case CPP14Parser::Plus:
			case CPP14Parser::Minus:
			case CPP14Parser::Star:
			case CPP14Parser::And:
			case CPP14Parser::Or:
			case CPP14Parser::Tilde:
			case CPP14Parser::PlusPlus:
			case CPP14Parser::MinusMinus:
			case CPP14Parser::Doublecolon:
			case CPP14Parser::Identifier:
			case CPP14Parser::Integerliteral:
			case CPP14Parser::Characterliteral:
			case CPP14Parser::Floatingliteral:
			case CPP14Parser::Stringliteral:
			case CPP14Parser::Userdefinedintegerliteral:
			case CPP14Parser::Userdefinedfloatingliteral:
			case CPP14Parser::Userdefinedstringliteral:
			case CPP14Parser::Userdefinedcharacterliteral:
			{
				enterOuterAlt(ctx, 1);
				setState(1164); //951
				expression(0,ctx);
				break;
			}

			case CPP14Parser::LeftBrace:
			{
				enterOuterAlt(ctx, 2);
				setState(1165); //951
				bracedinitlist(ctx);
				break;
			}

		default:
			throw NoViableAltException(this, ctx);
		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::ForrangeinitializerContext> CPP14Parser::parseforrangeinitializer()
{
	forrangeinitializer();
	auto result = std::unique_ptr<ForrangeinitializerContext>(dynamic_cast<ForrangeinitializerContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- JumpstatementContext ------------------------------------------------------------------

CPP14Parser::JumpstatementContext::JumpstatementContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::JumpstatementContext::Break()
{
	return getToken(CPP14Parser::Break, 0);
}

tree::TerminalNode* CPP14Parser::JumpstatementContext::Semi()
{
	return getToken(CPP14Parser::Semi, 0);
}

tree::TerminalNode* CPP14Parser::JumpstatementContext::Continue()
{
	return getToken(CPP14Parser::Continue, 0);
}

tree::TerminalNode* CPP14Parser::JumpstatementContext::Return()
{
	return getToken(CPP14Parser::Return, 0);
}

CPP14Parser::ExpressionContext* CPP14Parser::JumpstatementContext::expression()
{
	return getRuleContext<CPP14Parser::ExpressionContext>(0);//1165
}

CPP14Parser::BracedinitlistContext* CPP14Parser::JumpstatementContext::bracedinitlist()
{
	return getRuleContext<CPP14Parser::BracedinitlistContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::JumpstatementContext::Goto()
{
	return getToken(CPP14Parser::Goto, 0);
}

tree::TerminalNode* CPP14Parser::JumpstatementContext::Identifier()
{
	return getToken(CPP14Parser::Identifier, 0);
}


size_t CPP14Parser::JumpstatementContext::getRuleIndex() const
{
	return CPP14Parser::RuleJumpstatement;//688
}

void CPP14Parser::JumpstatementContext::copyFrom(JumpstatementContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::JumpstatementContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<JumpstatementContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::JumpstatementContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::JumpstatementContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::JumpstatementContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitJumpstatement(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::JumpstatementContext* CPP14Parser::jumpstatement( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<JumpstatementContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 118, CPP14Parser::RuleJumpstatement);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1184);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 101, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(1168);//958
			match(CPP14Parser::Break,ctx);
			setState(1169);//958
			match(CPP14Parser::Semi,ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(1170);//958
			match(CPP14Parser::Continue,ctx);
			setState(1171);//958
			match(CPP14Parser::Semi,ctx);
			break;
		}

		case 3:
		{
			enterOuterAlt(ctx, 3);
			setState(1172);//958
			match(CPP14Parser::Return,ctx);
			setState(1174);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if ((((_la & ~ 0x3fULL) == 0) &&
				((1ULL << _la) & ((1ULL << CPP14Parser::T__0)
				| (1ULL << CPP14Parser::T__1)
				| (1ULL << CPP14Parser::Alignof)
				| (1ULL << CPP14Parser::Auto)
				| (1ULL << CPP14Parser::Bool)
				| (1ULL << CPP14Parser::Char)
				| (1ULL << CPP14Parser::Char16)
				| (1ULL << CPP14Parser::Char32)
				| (1ULL << CPP14Parser::Const_cast)
				| (1ULL << CPP14Parser::Decltype)
				| (1ULL << CPP14Parser::Delete)
				| (1ULL << CPP14Parser::Double)
				| (1ULL << CPP14Parser::Dynamic_cast)
				| (1ULL << CPP14Parser::False)
				| (1ULL << CPP14Parser::Float)
				| (1ULL << CPP14Parser::Int)
				| (1ULL << CPP14Parser::Long)
				| (1ULL << CPP14Parser::New)
				| (1ULL << CPP14Parser::Noexcept)
				| (1ULL << CPP14Parser::Nullptr)
				| (1ULL << CPP14Parser::Operator)
				| (1ULL << CPP14Parser::Reinterpret_cast)
				| (1ULL << CPP14Parser::Short)
				| (1ULL << CPP14Parser::Signed)
				| (1ULL << CPP14Parser::Sizeof))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
				((1ULL << (_la - 64)) & ((1ULL << (CPP14Parser::Static_cast - 64))
				| (1ULL << (CPP14Parser::This - 64))
				| (1ULL << (CPP14Parser::Throw - 64))
				| (1ULL << (CPP14Parser::True - 64))
				| (1ULL << (CPP14Parser::Typeid_ - 64))
				| (1ULL << (CPP14Parser::Typename_ - 64))
				| (1ULL << (CPP14Parser::Unsigned - 64))
				| (1ULL << (CPP14Parser::Void - 64))
				| (1ULL << (CPP14Parser::Wchar - 64))
				| (1ULL << (CPP14Parser::LeftParen - 64))
				| (1ULL << (CPP14Parser::LeftBracket - 64))
				| (1ULL << (CPP14Parser::Plus - 64))
				| (1ULL << (CPP14Parser::Minus - 64))
				| (1ULL << (CPP14Parser::Star - 64))
				| (1ULL << (CPP14Parser::And - 64))
				| (1ULL << (CPP14Parser::Or - 64))
				| (1ULL << (CPP14Parser::Tilde - 64))
				| (1ULL << (CPP14Parser::PlusPlus - 64))
				| (1ULL << (CPP14Parser::MinusMinus - 64))
				| (1ULL << (CPP14Parser::Doublecolon - 64)))) != 0) || ((((_la - 130) & ~ 0x3fULL) == 0) &&
				((1ULL << (_la - 130)) & ((1ULL << (CPP14Parser::Identifier - 130))
				| (1ULL << (CPP14Parser::Integerliteral - 130))
				| (1ULL << (CPP14Parser::Characterliteral - 130))
				| (1ULL << (CPP14Parser::Floatingliteral - 130))
				| (1ULL << (CPP14Parser::Stringliteral - 130))
				| (1ULL << (CPP14Parser::Userdefinedintegerliteral - 130))
				| (1ULL << (CPP14Parser::Userdefinedfloatingliteral - 130))
				| (1ULL << (CPP14Parser::Userdefinedstringliteral - 130))
				| (1ULL << (CPP14Parser::Userdefinedcharacterliteral - 130)))) != 0))
			{
				setState(1173); //951
				expression(0,ctx);
			}
			setState(1176);//958
			match(CPP14Parser::Semi,ctx);
			break;
		}

		case 4:
		{
			enterOuterAlt(ctx, 4);
			setState(1177);//958
			match(CPP14Parser::Return,ctx);
			setState(1178); //951
			bracedinitlist(ctx);
			setState(1179);//958
			match(CPP14Parser::Semi,ctx);
			break;
		}

		case 5:
		{
			enterOuterAlt(ctx, 5);
			setState(1181);//958
			match(CPP14Parser::Goto,ctx);
			setState(1182);//958
			match(CPP14Parser::Identifier,ctx);
			setState(1183);//958
			match(CPP14Parser::Semi,ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::JumpstatementContext> CPP14Parser::parsejumpstatement()
{
	jumpstatement();
	auto result = std::unique_ptr<JumpstatementContext>(dynamic_cast<JumpstatementContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- DeclarationstatementContext ------------------------------------------------------------------

CPP14Parser::DeclarationstatementContext::DeclarationstatementContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::BlockdeclarationContext* CPP14Parser::DeclarationstatementContext::blockdeclaration()
{
	return getRuleContext<CPP14Parser::BlockdeclarationContext>(0);//1165
}


size_t CPP14Parser::DeclarationstatementContext::getRuleIndex() const
{
	return CPP14Parser::RuleDeclarationstatement;//688
}

void CPP14Parser::DeclarationstatementContext::copyFrom(DeclarationstatementContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::DeclarationstatementContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<DeclarationstatementContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::DeclarationstatementContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::DeclarationstatementContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::DeclarationstatementContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitDeclarationstatement(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::DeclarationstatementContext* CPP14Parser::declarationstatement( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<DeclarationstatementContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 120, CPP14Parser::RuleDeclarationstatement);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1186); //951
		blockdeclaration(ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::DeclarationstatementContext> CPP14Parser::parsedeclarationstatement()
{
	declarationstatement();
	auto result = std::unique_ptr<DeclarationstatementContext>(dynamic_cast<DeclarationstatementContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- DeclarationseqContext ------------------------------------------------------------------

CPP14Parser::DeclarationseqContext::DeclarationseqContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

std::vector<CPP14Parser::DeclarationContext *> CPP14Parser::DeclarationseqContext::declaration()
{
	return getRuleContexts<CPP14Parser::DeclarationContext>();//1174
}

CPP14Parser::DeclarationContext* CPP14Parser::DeclarationseqContext::declaration(size_t i)
{
	return getRuleContext<CPP14Parser::DeclarationContext>(i);//1183
}


size_t CPP14Parser::DeclarationseqContext::getRuleIndex() const
{
	return CPP14Parser::RuleDeclarationseq;//688
}

void CPP14Parser::DeclarationseqContext::copyFrom(DeclarationseqContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::DeclarationseqContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<DeclarationseqContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::DeclarationseqContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::DeclarationseqContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::DeclarationseqContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitDeclarationseq(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::DeclarationseqContext* CPP14Parser::declarationseq( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<DeclarationseqContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 122, CPP14Parser::RuleDeclarationseq);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1191);//800
		_errHandler->sync(this, ctx);
		_la = _input->LA(1);
		while (((((_la - 3) & ~ 0x3fULL) == 0) &&
			((1ULL << (_la - 3)) & ((1ULL << (CPP14Parser::T__2 - 3))
			| (1ULL << (CPP14Parser::MultiLineMacro - 3))
			| (1ULL << (CPP14Parser::Directive - 3))
			| (1ULL << (CPP14Parser::Alignas - 3))
			| (1ULL << (CPP14Parser::Asm - 3))
			| (1ULL << (CPP14Parser::Auto - 3))
			| (1ULL << (CPP14Parser::Bool - 3))
			| (1ULL << (CPP14Parser::Char - 3))
			| (1ULL << (CPP14Parser::Char16 - 3))
			| (1ULL << (CPP14Parser::Char32 - 3))
			| (1ULL << (CPP14Parser::Class - 3))
			| (1ULL << (CPP14Parser::Const - 3))
			| (1ULL << (CPP14Parser::Constexpr - 3))
			| (1ULL << (CPP14Parser::Decltype - 3))
			| (1ULL << (CPP14Parser::Double - 3))
			| (1ULL << (CPP14Parser::Enum - 3))
			| (1ULL << (CPP14Parser::Explicit - 3))
			| (1ULL << (CPP14Parser::Extern - 3))
			| (1ULL << (CPP14Parser::Float - 3))
			| (1ULL << (CPP14Parser::Friend - 3))
			| (1ULL << (CPP14Parser::Inline - 3))
			| (1ULL << (CPP14Parser::Int - 3))
			| (1ULL << (CPP14Parser::Long - 3))
			| (1ULL << (CPP14Parser::Mutable - 3))
			| (1ULL << (CPP14Parser::Namespace - 3))
			| (1ULL << (CPP14Parser::Operator - 3))
			| (1ULL << (CPP14Parser::Register - 3))
			| (1ULL << (CPP14Parser::Short - 3))
			| (1ULL << (CPP14Parser::Signed - 3))
			| (1ULL << (CPP14Parser::Static - 3))
			| (1ULL << (CPP14Parser::Static_assert - 3))
			| (1ULL << (CPP14Parser::Struct - 3)))) != 0) || ((((_la - 67) & ~ 0x3fULL) == 0) &&
			((1ULL << (_la - 67)) & ((1ULL << (CPP14Parser::Template - 67))
			| (1ULL << (CPP14Parser::Thread_local - 67))
			| (1ULL << (CPP14Parser::Typedef - 67))
			| (1ULL << (CPP14Parser::Typename_ - 67))
			| (1ULL << (CPP14Parser::Union - 67))
			| (1ULL << (CPP14Parser::Unsigned - 67))
			| (1ULL << (CPP14Parser::Using - 67))
			| (1ULL << (CPP14Parser::Virtual - 67))
			| (1ULL << (CPP14Parser::Void - 67))
			| (1ULL << (CPP14Parser::Volatile - 67))
			| (1ULL << (CPP14Parser::Wchar - 67))
			| (1ULL << (CPP14Parser::LeftParen - 67))
			| (1ULL << (CPP14Parser::LeftBracket - 67))
			| (1ULL << (CPP14Parser::Star - 67))
			| (1ULL << (CPP14Parser::And - 67))
			| (1ULL << (CPP14Parser::Tilde - 67))
			| (1ULL << (CPP14Parser::Doublecolon - 67))
			| (1ULL << (CPP14Parser::Semi - 67))
			| (1ULL << (CPP14Parser::Ellipsis - 67))
			| (1ULL << (CPP14Parser::Identifier - 67)))) != 0))
		{
			setState(1188); //951
			declaration(ctx);
			setState(1193);//806
			_errHandler->sync(this, ctx);
			_la = _input->LA(1);
		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::DeclarationseqContext> CPP14Parser::parsedeclarationseq()
{
	declarationseq();
	auto result = std::unique_ptr<DeclarationseqContext>(dynamic_cast<DeclarationseqContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- DeclarationContext ------------------------------------------------------------------

CPP14Parser::DeclarationContext::DeclarationContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::BlockdeclarationContext* CPP14Parser::DeclarationContext::blockdeclaration()
{
	return getRuleContext<CPP14Parser::BlockdeclarationContext>(0);//1165
}

CPP14Parser::FunctiondefinitionContext* CPP14Parser::DeclarationContext::functiondefinition()
{
	return getRuleContext<CPP14Parser::FunctiondefinitionContext>(0);//1165
}

CPP14Parser::TemplatedeclarationContext* CPP14Parser::DeclarationContext::templatedeclaration()
{
	return getRuleContext<CPP14Parser::TemplatedeclarationContext>(0);//1165
}

CPP14Parser::ExplicitinstantiationContext* CPP14Parser::DeclarationContext::explicitinstantiation()
{
	return getRuleContext<CPP14Parser::ExplicitinstantiationContext>(0);//1165
}

CPP14Parser::ExplicitspecializationContext* CPP14Parser::DeclarationContext::explicitspecialization()
{
	return getRuleContext<CPP14Parser::ExplicitspecializationContext>(0);//1165
}

CPP14Parser::LinkagespecificationContext* CPP14Parser::DeclarationContext::linkagespecification()
{
	return getRuleContext<CPP14Parser::LinkagespecificationContext>(0);//1165
}

CPP14Parser::NamespacedefinitionContext* CPP14Parser::DeclarationContext::namespacedefinition()
{
	return getRuleContext<CPP14Parser::NamespacedefinitionContext>(0);//1165
}

CPP14Parser::EmptydeclarationContext* CPP14Parser::DeclarationContext::emptydeclaration()
{
	return getRuleContext<CPP14Parser::EmptydeclarationContext>(0);//1165
}

CPP14Parser::AttributedeclarationContext* CPP14Parser::DeclarationContext::attributedeclaration()
{
	return getRuleContext<CPP14Parser::AttributedeclarationContext>(0);//1165
}

CPP14Parser::PreprocessorDirectiveContext* CPP14Parser::DeclarationContext::preprocessorDirective()
{
	return getRuleContext<CPP14Parser::PreprocessorDirectiveContext>(0);//1165
}


size_t CPP14Parser::DeclarationContext::getRuleIndex() const
{
	return CPP14Parser::RuleDeclaration;//688
}

void CPP14Parser::DeclarationContext::copyFrom(DeclarationContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::DeclarationContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<DeclarationContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::DeclarationContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::DeclarationContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::DeclarationContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitDeclaration(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::DeclarationContext* CPP14Parser::declaration( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<DeclarationContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 124, CPP14Parser::RuleDeclaration);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1204);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 103, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(1194); //951
			blockdeclaration(ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(1195); //951
			functiondefinition(ctx);
			break;
		}

		case 3:
		{
			enterOuterAlt(ctx, 3);
			setState(1196); //951
			templatedeclaration(ctx);
			break;
		}

		case 4:
		{
			enterOuterAlt(ctx, 4);
			setState(1197); //951
			explicitinstantiation(ctx);
			break;
		}

		case 5:
		{
			enterOuterAlt(ctx, 5);
			setState(1198); //951
			explicitspecialization(ctx);
			break;
		}

		case 6:
		{
			enterOuterAlt(ctx, 6);
			setState(1199); //951
			linkagespecification(ctx);
			break;
		}

		case 7:
		{
			enterOuterAlt(ctx, 7);
			setState(1200); //951
			namespacedefinition(ctx);
			break;
		}

		case 8:
		{
			enterOuterAlt(ctx, 8);
			setState(1201); //951
			emptydeclaration(ctx);
			break;
		}

		case 9:
		{
			enterOuterAlt(ctx, 9);
			setState(1202); //951
			attributedeclaration(ctx);
			break;
		}

		case 10:
		{
			enterOuterAlt(ctx, 10);
			setState(1203); //951
			preprocessorDirective(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::DeclarationContext> CPP14Parser::parsedeclaration()
{
	declaration();
	auto result = std::unique_ptr<DeclarationContext>(dynamic_cast<DeclarationContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- PreprocessorDirectiveContext ------------------------------------------------------------------

CPP14Parser::PreprocessorDirectiveContext::PreprocessorDirectiveContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::PreprocessorDirectiveContext::MultiLineMacro()
{
	return getToken(CPP14Parser::MultiLineMacro, 0);
}

tree::TerminalNode* CPP14Parser::PreprocessorDirectiveContext::Directive()
{
	return getToken(CPP14Parser::Directive, 0);
}


size_t CPP14Parser::PreprocessorDirectiveContext::getRuleIndex() const
{
	return CPP14Parser::RulePreprocessorDirective;//688
}

void CPP14Parser::PreprocessorDirectiveContext::copyFrom(PreprocessorDirectiveContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::PreprocessorDirectiveContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<PreprocessorDirectiveContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::PreprocessorDirectiveContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::PreprocessorDirectiveContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::PreprocessorDirectiveContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitPreprocessorDirective(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::PreprocessorDirectiveContext* CPP14Parser::preprocessorDirective( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<PreprocessorDirectiveContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 126, CPP14Parser::RulePreprocessorDirective);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1206);//970
		_la = _input->LA(1);
		if (!(_la == CPP14Parser::MultiLineMacro

		|| _la == CPP14Parser::Directive))
		{
		_errHandler->recoverInline(this, ctx);
		}
		else
		{
			_errHandler->reportMatch(this);
			consume(ctx);
		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::PreprocessorDirectiveContext> CPP14Parser::parsepreprocessorDirective()
{
	preprocessorDirective();
	auto result = std::unique_ptr<PreprocessorDirectiveContext>(dynamic_cast<PreprocessorDirectiveContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- BlockdeclarationContext ------------------------------------------------------------------

CPP14Parser::BlockdeclarationContext::BlockdeclarationContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::SimpledeclarationContext* CPP14Parser::BlockdeclarationContext::simpledeclaration()
{
	return getRuleContext<CPP14Parser::SimpledeclarationContext>(0);//1165
}

CPP14Parser::AsmdefinitionContext* CPP14Parser::BlockdeclarationContext::asmdefinition()
{
	return getRuleContext<CPP14Parser::AsmdefinitionContext>(0);//1165
}

CPP14Parser::NamespacealiasdefinitionContext* CPP14Parser::BlockdeclarationContext::namespacealiasdefinition()
{
	return getRuleContext<CPP14Parser::NamespacealiasdefinitionContext>(0);//1165
}

CPP14Parser::UsingdeclarationContext* CPP14Parser::BlockdeclarationContext::usingdeclaration()
{
	return getRuleContext<CPP14Parser::UsingdeclarationContext>(0);//1165
}

CPP14Parser::UsingdirectiveContext* CPP14Parser::BlockdeclarationContext::usingdirective()
{
	return getRuleContext<CPP14Parser::UsingdirectiveContext>(0);//1165
}

CPP14Parser::Static_assertdeclarationContext* CPP14Parser::BlockdeclarationContext::static_assertdeclaration()
{
	return getRuleContext<CPP14Parser::Static_assertdeclarationContext>(0);//1165
}

CPP14Parser::AliasdeclarationContext* CPP14Parser::BlockdeclarationContext::aliasdeclaration()
{
	return getRuleContext<CPP14Parser::AliasdeclarationContext>(0);//1165
}

CPP14Parser::OpaqueenumdeclarationContext* CPP14Parser::BlockdeclarationContext::opaqueenumdeclaration()
{
	return getRuleContext<CPP14Parser::OpaqueenumdeclarationContext>(0);//1165
}


size_t CPP14Parser::BlockdeclarationContext::getRuleIndex() const
{
	return CPP14Parser::RuleBlockdeclaration;//688
}

void CPP14Parser::BlockdeclarationContext::copyFrom(BlockdeclarationContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::BlockdeclarationContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<BlockdeclarationContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::BlockdeclarationContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::BlockdeclarationContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::BlockdeclarationContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitBlockdeclaration(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::BlockdeclarationContext* CPP14Parser::blockdeclaration( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<BlockdeclarationContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 128, CPP14Parser::RuleBlockdeclaration);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1216);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 104, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(1208); //951
			simpledeclaration(ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(1209); //951
			asmdefinition(ctx);
			break;
		}

		case 3:
		{
			enterOuterAlt(ctx, 3);
			setState(1210); //951
			namespacealiasdefinition(ctx);
			break;
		}

		case 4:
		{
			enterOuterAlt(ctx, 4);
			setState(1211); //951
			usingdeclaration(ctx);
			break;
		}

		case 5:
		{
			enterOuterAlt(ctx, 5);
			setState(1212); //951
			usingdirective(ctx);
			break;
		}

		case 6:
		{
			enterOuterAlt(ctx, 6);
			setState(1213); //951
			static_assertdeclaration(ctx);
			break;
		}

		case 7:
		{
			enterOuterAlt(ctx, 7);
			setState(1214); //951
			aliasdeclaration(ctx);
			break;
		}

		case 8:
		{
			enterOuterAlt(ctx, 8);
			setState(1215); //951
			opaqueenumdeclaration(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::BlockdeclarationContext> CPP14Parser::parseblockdeclaration()
{
	blockdeclaration();
	auto result = std::unique_ptr<BlockdeclarationContext>(dynamic_cast<BlockdeclarationContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- AliasdeclarationContext ------------------------------------------------------------------

CPP14Parser::AliasdeclarationContext::AliasdeclarationContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::AliasdeclarationContext::Using()
{
	return getToken(CPP14Parser::Using, 0);
}

tree::TerminalNode* CPP14Parser::AliasdeclarationContext::Identifier()
{
	return getToken(CPP14Parser::Identifier, 0);
}

tree::TerminalNode* CPP14Parser::AliasdeclarationContext::Assign()
{
	return getToken(CPP14Parser::Assign, 0);
}

CPP14Parser::ThetypeidContext* CPP14Parser::AliasdeclarationContext::thetypeid()
{
	return getRuleContext<CPP14Parser::ThetypeidContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::AliasdeclarationContext::Semi()
{
	return getToken(CPP14Parser::Semi, 0);
}

CPP14Parser::AttributespecifierseqContext* CPP14Parser::AliasdeclarationContext::attributespecifierseq()
{
	return getRuleContext<CPP14Parser::AttributespecifierseqContext>(0);//1165
}


size_t CPP14Parser::AliasdeclarationContext::getRuleIndex() const
{
	return CPP14Parser::RuleAliasdeclaration;//688
}

void CPP14Parser::AliasdeclarationContext::copyFrom(AliasdeclarationContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::AliasdeclarationContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<AliasdeclarationContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::AliasdeclarationContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::AliasdeclarationContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::AliasdeclarationContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitAliasdeclaration(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::AliasdeclarationContext* CPP14Parser::aliasdeclaration( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<AliasdeclarationContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 130, CPP14Parser::RuleAliasdeclaration);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1218);//958
		match(CPP14Parser::Using,ctx);
		setState(1219);//958
		match(CPP14Parser::Identifier,ctx);
		setState(1221);//788
		_errHandler->sync(this, ctx);

		_la = _input->LA(1);
		if (_la == CPP14Parser::Alignas || _la == CPP14Parser::LeftBracket)
		{
			setState(1220); //951
			attributespecifierseq(0,ctx);
		}
		setState(1223);//958
		match(CPP14Parser::Assign,ctx);
		setState(1224); //951
		thetypeid(ctx);
		setState(1225);//958
		match(CPP14Parser::Semi,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::AliasdeclarationContext> CPP14Parser::parsealiasdeclaration()
{
	aliasdeclaration();
	auto result = std::unique_ptr<AliasdeclarationContext>(dynamic_cast<AliasdeclarationContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- SimpledeclarationContext ------------------------------------------------------------------

CPP14Parser::SimpledeclarationContext::SimpledeclarationContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::SimpledeclarationContext::Semi()
{
	return getToken(CPP14Parser::Semi, 0);
}

CPP14Parser::DeclspecifierseqContext* CPP14Parser::SimpledeclarationContext::declspecifierseq()
{
	return getRuleContext<CPP14Parser::DeclspecifierseqContext>(0);//1165
}

CPP14Parser::InitdeclaratorlistContext* CPP14Parser::SimpledeclarationContext::initdeclaratorlist()
{
	return getRuleContext<CPP14Parser::InitdeclaratorlistContext>(0);//1165
}

CPP14Parser::AttributespecifierseqContext* CPP14Parser::SimpledeclarationContext::attributespecifierseq()
{
	return getRuleContext<CPP14Parser::AttributespecifierseqContext>(0);//1165
}


size_t CPP14Parser::SimpledeclarationContext::getRuleIndex() const
{
	return CPP14Parser::RuleSimpledeclaration;//688
}

void CPP14Parser::SimpledeclarationContext::copyFrom(SimpledeclarationContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::SimpledeclarationContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<SimpledeclarationContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::SimpledeclarationContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::SimpledeclarationContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::SimpledeclarationContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitSimpledeclaration(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::SimpledeclarationContext* CPP14Parser::simpledeclaration( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<SimpledeclarationContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 132, CPP14Parser::RuleSimpledeclaration);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1241);//750
		_errHandler->sync(this, ctx);
		switch (_input->LA(1))
		{
			case CPP14Parser::T__2:
			case CPP14Parser::Auto:
			case CPP14Parser::Bool:
			case CPP14Parser::Char:
			case CPP14Parser::Char16:
			case CPP14Parser::Char32:
			case CPP14Parser::Class:
			case CPP14Parser::Const:
			case CPP14Parser::Constexpr:
			case CPP14Parser::Decltype:
			case CPP14Parser::Double:
			case CPP14Parser::Enum:
			case CPP14Parser::Explicit:
			case CPP14Parser::Extern:
			case CPP14Parser::Float:
			case CPP14Parser::Friend:
			case CPP14Parser::Inline:
			case CPP14Parser::Int:
			case CPP14Parser::Long:
			case CPP14Parser::Mutable:
			case CPP14Parser::Operator:
			case CPP14Parser::Register:
			case CPP14Parser::Short:
			case CPP14Parser::Signed:
			case CPP14Parser::Static:
			case CPP14Parser::Struct:
			case CPP14Parser::Thread_local:
			case CPP14Parser::Typedef:
			case CPP14Parser::Typename_:
			case CPP14Parser::Union:
			case CPP14Parser::Unsigned:
			case CPP14Parser::Virtual:
			case CPP14Parser::Void:
			case CPP14Parser::Volatile:
			case CPP14Parser::Wchar:
			case CPP14Parser::LeftParen:
			case CPP14Parser::Star:
			case CPP14Parser::And:
			case CPP14Parser::Tilde:
			case CPP14Parser::Doublecolon:
			case CPP14Parser::Semi:
			case CPP14Parser::Ellipsis:
			case CPP14Parser::Identifier:
			{
				enterOuterAlt(ctx, 1);
				setState(1228);//848
				_errHandler->sync(this, ctx);

				switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 106, ctx))
				{
				case 1:
				{
					setState(1227); //951
					declspecifierseq(ctx);
					break;
				}

				}
				setState(1231);//788
				_errHandler->sync(this, ctx);

				_la = _input->LA(1);
				if ((((_la & ~ 0x3fULL) == 0) &&
					((1ULL << _la) & ((1ULL << CPP14Parser::T__2)
					| (1ULL << CPP14Parser::Decltype)
					| (1ULL << CPP14Parser::Operator))) != 0) || ((((_la - 84) & ~ 0x3fULL) == 0) &&
					((1ULL << (_la - 84)) & ((1ULL << (CPP14Parser::LeftParen - 84))
					| (1ULL << (CPP14Parser::Star - 84))
					| (1ULL << (CPP14Parser::And - 84))
					| (1ULL << (CPP14Parser::Tilde - 84))
					| (1ULL << (CPP14Parser::Doublecolon - 84))
					| (1ULL << (CPP14Parser::Ellipsis - 84))
					| (1ULL << (CPP14Parser::Identifier - 84)))) != 0))
				{
					setState(1230); //951
					initdeclaratorlist(0,ctx);
				}
				setState(1233);//958
				match(CPP14Parser::Semi,ctx);
				break;
			}

			case CPP14Parser::Alignas:
			case CPP14Parser::LeftBracket:
			{
				enterOuterAlt(ctx, 2);
				setState(1234); //951
				attributespecifierseq(0,ctx);
				setState(1236);//848
				_errHandler->sync(this, ctx);

				switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 108, ctx))
				{
				case 1:
				{
					setState(1235); //951
					declspecifierseq(ctx);
					break;
				}

				}
				setState(1238); //951
				initdeclaratorlist(0,ctx);
				setState(1239);//958
				match(CPP14Parser::Semi,ctx);
				break;
			}

		default:
			throw NoViableAltException(this, ctx);
		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::SimpledeclarationContext> CPP14Parser::parsesimpledeclaration()
{
	simpledeclaration();
	auto result = std::unique_ptr<SimpledeclarationContext>(dynamic_cast<SimpledeclarationContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- Static_assertdeclarationContext ------------------------------------------------------------------

CPP14Parser::Static_assertdeclarationContext::Static_assertdeclarationContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::Static_assertdeclarationContext::Static_assert()
{
	return getToken(CPP14Parser::Static_assert, 0);
}

tree::TerminalNode* CPP14Parser::Static_assertdeclarationContext::LeftParen()
{
	return getToken(CPP14Parser::LeftParen, 0);
}

CPP14Parser::ConstantexpressionContext* CPP14Parser::Static_assertdeclarationContext::constantexpression()
{
	return getRuleContext<CPP14Parser::ConstantexpressionContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::Static_assertdeclarationContext::Comma()
{
	return getToken(CPP14Parser::Comma, 0);
}

tree::TerminalNode* CPP14Parser::Static_assertdeclarationContext::Stringliteral()
{
	return getToken(CPP14Parser::Stringliteral, 0);
}

tree::TerminalNode* CPP14Parser::Static_assertdeclarationContext::RightParen()
{
	return getToken(CPP14Parser::RightParen, 0);
}

tree::TerminalNode* CPP14Parser::Static_assertdeclarationContext::Semi()
{
	return getToken(CPP14Parser::Semi, 0);
}


size_t CPP14Parser::Static_assertdeclarationContext::getRuleIndex() const
{
	return CPP14Parser::RuleStatic_assertdeclaration;//688
}

void CPP14Parser::Static_assertdeclarationContext::copyFrom(Static_assertdeclarationContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::Static_assertdeclarationContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<Static_assertdeclarationContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::Static_assertdeclarationContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::Static_assertdeclarationContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::Static_assertdeclarationContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitStatic_assertdeclaration(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::Static_assertdeclarationContext* CPP14Parser::static_assertdeclaration( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<Static_assertdeclarationContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 134, CPP14Parser::RuleStatic_assertdeclaration);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1243);//958
		match(CPP14Parser::Static_assert,ctx);
		setState(1244);//958
		match(CPP14Parser::LeftParen,ctx);
		setState(1245); //951
		constantexpression(ctx);
		setState(1246);//958
		match(CPP14Parser::Comma,ctx);
		setState(1247);//958
		match(CPP14Parser::Stringliteral,ctx);
		setState(1248);//958
		match(CPP14Parser::RightParen,ctx);
		setState(1249);//958
		match(CPP14Parser::Semi,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::Static_assertdeclarationContext> CPP14Parser::parsestatic_assertdeclaration()
{
	static_assertdeclaration();
	auto result = std::unique_ptr<Static_assertdeclarationContext>(dynamic_cast<Static_assertdeclarationContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- EmptydeclarationContext ------------------------------------------------------------------

CPP14Parser::EmptydeclarationContext::EmptydeclarationContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::EmptydeclarationContext::Semi()
{
	return getToken(CPP14Parser::Semi, 0);
}


size_t CPP14Parser::EmptydeclarationContext::getRuleIndex() const
{
	return CPP14Parser::RuleEmptydeclaration;//688
}

void CPP14Parser::EmptydeclarationContext::copyFrom(EmptydeclarationContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::EmptydeclarationContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<EmptydeclarationContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::EmptydeclarationContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::EmptydeclarationContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::EmptydeclarationContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitEmptydeclaration(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::EmptydeclarationContext* CPP14Parser::emptydeclaration( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<EmptydeclarationContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 136, CPP14Parser::RuleEmptydeclaration);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1251);//958
		match(CPP14Parser::Semi,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::EmptydeclarationContext> CPP14Parser::parseemptydeclaration()
{
	emptydeclaration();
	auto result = std::unique_ptr<EmptydeclarationContext>(dynamic_cast<EmptydeclarationContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- AttributedeclarationContext ------------------------------------------------------------------

CPP14Parser::AttributedeclarationContext::AttributedeclarationContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::AttributespecifierseqContext* CPP14Parser::AttributedeclarationContext::attributespecifierseq()
{
	return getRuleContext<CPP14Parser::AttributespecifierseqContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::AttributedeclarationContext::Semi()
{
	return getToken(CPP14Parser::Semi, 0);
}


size_t CPP14Parser::AttributedeclarationContext::getRuleIndex() const
{
	return CPP14Parser::RuleAttributedeclaration;//688
}

void CPP14Parser::AttributedeclarationContext::copyFrom(AttributedeclarationContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::AttributedeclarationContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<AttributedeclarationContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::AttributedeclarationContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::AttributedeclarationContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::AttributedeclarationContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitAttributedeclaration(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::AttributedeclarationContext* CPP14Parser::attributedeclaration( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<AttributedeclarationContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 138, CPP14Parser::RuleAttributedeclaration);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1253); //951
		attributespecifierseq(0,ctx);
		setState(1254);//958
		match(CPP14Parser::Semi,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::AttributedeclarationContext> CPP14Parser::parseattributedeclaration()
{
	attributedeclaration();
	auto result = std::unique_ptr<AttributedeclarationContext>(dynamic_cast<AttributedeclarationContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- DeclspecifierContext ------------------------------------------------------------------

CPP14Parser::DeclspecifierContext::DeclspecifierContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::StorageclassspecifierContext* CPP14Parser::DeclspecifierContext::storageclassspecifier()
{
	return getRuleContext<CPP14Parser::StorageclassspecifierContext>(0);//1165
}

CPP14Parser::TypespecifierContext* CPP14Parser::DeclspecifierContext::typespecifier()
{
	return getRuleContext<CPP14Parser::TypespecifierContext>(0);//1165
}

CPP14Parser::FunctionspecifierContext* CPP14Parser::DeclspecifierContext::functionspecifier()
{
	return getRuleContext<CPP14Parser::FunctionspecifierContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::DeclspecifierContext::Friend()
{
	return getToken(CPP14Parser::Friend, 0);
}

tree::TerminalNode* CPP14Parser::DeclspecifierContext::Typedef()
{
	return getToken(CPP14Parser::Typedef, 0);
}

tree::TerminalNode* CPP14Parser::DeclspecifierContext::Constexpr()
{
	return getToken(CPP14Parser::Constexpr, 0);
}


size_t CPP14Parser::DeclspecifierContext::getRuleIndex() const
{
	return CPP14Parser::RuleDeclspecifier;//688
}

void CPP14Parser::DeclspecifierContext::copyFrom(DeclspecifierContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::DeclspecifierContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<DeclspecifierContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::DeclspecifierContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::DeclspecifierContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::DeclspecifierContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitDeclspecifier(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::DeclspecifierContext* CPP14Parser::declspecifier( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<DeclspecifierContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 140, CPP14Parser::RuleDeclspecifier);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1262);//750
		_errHandler->sync(this, ctx);
		switch (_input->LA(1))
		{
			case CPP14Parser::Extern:
			case CPP14Parser::Mutable:
			case CPP14Parser::Register:
			case CPP14Parser::Static:
			case CPP14Parser::Thread_local:
			{
				enterOuterAlt(ctx, 1);
				setState(1256); //951
				storageclassspecifier(ctx);
				break;
			}

			case CPP14Parser::Auto:
			case CPP14Parser::Bool:
			case CPP14Parser::Char:
			case CPP14Parser::Char16:
			case CPP14Parser::Char32:
			case CPP14Parser::Class:
			case CPP14Parser::Const:
			case CPP14Parser::Decltype:
			case CPP14Parser::Double:
			case CPP14Parser::Enum:
			case CPP14Parser::Float:
			case CPP14Parser::Int:
			case CPP14Parser::Long:
			case CPP14Parser::Short:
			case CPP14Parser::Signed:
			case CPP14Parser::Struct:
			case CPP14Parser::Typename_:
			case CPP14Parser::Union:
			case CPP14Parser::Unsigned:
			case CPP14Parser::Void:
			case CPP14Parser::Volatile:
			case CPP14Parser::Wchar:
			case CPP14Parser::Doublecolon:
			case CPP14Parser::Identifier:
			{
				enterOuterAlt(ctx, 2);
				setState(1257); //951
				typespecifier(ctx);
				break;
			}

			case CPP14Parser::Explicit:
			case CPP14Parser::Inline:
			case CPP14Parser::Virtual:
			{
				enterOuterAlt(ctx, 3);
				setState(1258); //951
				functionspecifier(ctx);
				break;
			}

			case CPP14Parser::Friend:
			{
				enterOuterAlt(ctx, 4);
				setState(1259);//958
				match(CPP14Parser::Friend,ctx);
				break;
			}

			case CPP14Parser::Typedef:
			{
				enterOuterAlt(ctx, 5);
				setState(1260);//958
				match(CPP14Parser::Typedef,ctx);
				break;
			}

			case CPP14Parser::Constexpr:
			{
				enterOuterAlt(ctx, 6);
				setState(1261);//958
				match(CPP14Parser::Constexpr,ctx);
				break;
			}

		default:
			throw NoViableAltException(this, ctx);
		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::DeclspecifierContext> CPP14Parser::parsedeclspecifier()
{
	declspecifier();
	auto result = std::unique_ptr<DeclspecifierContext>(dynamic_cast<DeclspecifierContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- DeclspecifierseqContext ------------------------------------------------------------------

CPP14Parser::DeclspecifierseqContext::DeclspecifierseqContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::DeclspecifierContext* CPP14Parser::DeclspecifierseqContext::declspecifier()
{
	return getRuleContext<CPP14Parser::DeclspecifierContext>(0);//1165
}

CPP14Parser::AttributespecifierseqContext* CPP14Parser::DeclspecifierseqContext::attributespecifierseq()
{
	return getRuleContext<CPP14Parser::AttributespecifierseqContext>(0);//1165
}

CPP14Parser::DeclspecifierseqContext* CPP14Parser::DeclspecifierseqContext::declspecifierseq()
{
	return getRuleContext<CPP14Parser::DeclspecifierseqContext>(0);//1165
}


size_t CPP14Parser::DeclspecifierseqContext::getRuleIndex() const
{
	return CPP14Parser::RuleDeclspecifierseq;//688
}

void CPP14Parser::DeclspecifierseqContext::copyFrom(DeclspecifierseqContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::DeclspecifierseqContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<DeclspecifierseqContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::DeclspecifierseqContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::DeclspecifierseqContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::DeclspecifierseqContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitDeclspecifierseq(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::DeclspecifierseqContext* CPP14Parser::declspecifierseq( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<DeclspecifierseqContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 142, CPP14Parser::RuleDeclspecifierseq);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1271);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 112, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(1264); //951
			declspecifier(ctx);
			setState(1266);//848
			_errHandler->sync(this, ctx);

			switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 111, ctx))
			{
			case 1:
			{
				setState(1265); //951
				attributespecifierseq(0,ctx);
				break;
			}

			}
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(1268); //951
			declspecifier(ctx);
			setState(1269); //951
			declspecifierseq(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::DeclspecifierseqContext> CPP14Parser::parsedeclspecifierseq()
{
	declspecifierseq();
	auto result = std::unique_ptr<DeclspecifierseqContext>(dynamic_cast<DeclspecifierseqContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- StorageclassspecifierContext ------------------------------------------------------------------

CPP14Parser::StorageclassspecifierContext::StorageclassspecifierContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::StorageclassspecifierContext::Register()
{
	return getToken(CPP14Parser::Register, 0);
}

tree::TerminalNode* CPP14Parser::StorageclassspecifierContext::Static()
{
	return getToken(CPP14Parser::Static, 0);
}

tree::TerminalNode* CPP14Parser::StorageclassspecifierContext::Thread_local()
{
	return getToken(CPP14Parser::Thread_local, 0);
}

tree::TerminalNode* CPP14Parser::StorageclassspecifierContext::Extern()
{
	return getToken(CPP14Parser::Extern, 0);
}

tree::TerminalNode* CPP14Parser::StorageclassspecifierContext::Mutable()
{
	return getToken(CPP14Parser::Mutable, 0);
}


size_t CPP14Parser::StorageclassspecifierContext::getRuleIndex() const
{
	return CPP14Parser::RuleStorageclassspecifier;//688
}

void CPP14Parser::StorageclassspecifierContext::copyFrom(StorageclassspecifierContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::StorageclassspecifierContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<StorageclassspecifierContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::StorageclassspecifierContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::StorageclassspecifierContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::StorageclassspecifierContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitStorageclassspecifier(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::StorageclassspecifierContext* CPP14Parser::storageclassspecifier( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<StorageclassspecifierContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 144, CPP14Parser::RuleStorageclassspecifier);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1273);//970
		_la = _input->LA(1);
		if (!(((((_la - 35) & ~ 0x3fULL) == 0) &&
			((1ULL << (_la - 35)) & ((1ULL << (CPP14Parser::Extern - 35))
			| (1ULL << (CPP14Parser::Mutable - 35))
			| (1ULL << (CPP14Parser::Register - 35))
			| (1ULL << (CPP14Parser::Static - 35))
			| (1ULL << (CPP14Parser::Thread_local - 35)))) != 0)))
		{
		_errHandler->recoverInline(this, ctx);
		}
		else
		{
			_errHandler->reportMatch(this);
			consume(ctx);
		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::StorageclassspecifierContext> CPP14Parser::parsestorageclassspecifier()
{
	storageclassspecifier();
	auto result = std::unique_ptr<StorageclassspecifierContext>(dynamic_cast<StorageclassspecifierContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- FunctionspecifierContext ------------------------------------------------------------------

CPP14Parser::FunctionspecifierContext::FunctionspecifierContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::FunctionspecifierContext::Inline()
{
	return getToken(CPP14Parser::Inline, 0);
}

tree::TerminalNode* CPP14Parser::FunctionspecifierContext::Virtual()
{
	return getToken(CPP14Parser::Virtual, 0);
}

tree::TerminalNode* CPP14Parser::FunctionspecifierContext::Explicit()
{
	return getToken(CPP14Parser::Explicit, 0);
}


size_t CPP14Parser::FunctionspecifierContext::getRuleIndex() const
{
	return CPP14Parser::RuleFunctionspecifier;//688
}

void CPP14Parser::FunctionspecifierContext::copyFrom(FunctionspecifierContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::FunctionspecifierContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<FunctionspecifierContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::FunctionspecifierContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::FunctionspecifierContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::FunctionspecifierContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitFunctionspecifier(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::FunctionspecifierContext* CPP14Parser::functionspecifier( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<FunctionspecifierContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 146, CPP14Parser::RuleFunctionspecifier);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1275);//970
		_la = _input->LA(1);
		if (!(((((_la - 33) & ~ 0x3fULL) == 0) &&
			((1ULL << (_la - 33)) & ((1ULL << (CPP14Parser::Explicit - 33))
			| (1ULL << (CPP14Parser::Inline - 33))
			| (1ULL << (CPP14Parser::Virtual - 33)))) != 0)))
		{
		_errHandler->recoverInline(this, ctx);
		}
		else
		{
			_errHandler->reportMatch(this);
			consume(ctx);
		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::FunctionspecifierContext> CPP14Parser::parsefunctionspecifier()
{
	functionspecifier();
	auto result = std::unique_ptr<FunctionspecifierContext>(dynamic_cast<FunctionspecifierContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- TypedefnameContext ------------------------------------------------------------------

CPP14Parser::TypedefnameContext::TypedefnameContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::TypedefnameContext::Identifier()
{
	return getToken(CPP14Parser::Identifier, 0);
}


size_t CPP14Parser::TypedefnameContext::getRuleIndex() const
{
	return CPP14Parser::RuleTypedefname;//688
}

void CPP14Parser::TypedefnameContext::copyFrom(TypedefnameContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::TypedefnameContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<TypedefnameContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::TypedefnameContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::TypedefnameContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::TypedefnameContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitTypedefname(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::TypedefnameContext* CPP14Parser::typedefname( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<TypedefnameContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 148, CPP14Parser::RuleTypedefname);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1277);//958
		match(CPP14Parser::Identifier,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::TypedefnameContext> CPP14Parser::parsetypedefname()
{
	typedefname();
	auto result = std::unique_ptr<TypedefnameContext>(dynamic_cast<TypedefnameContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- TypespecifierContext ------------------------------------------------------------------

CPP14Parser::TypespecifierContext::TypespecifierContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::TrailingtypespecifierContext* CPP14Parser::TypespecifierContext::trailingtypespecifier()
{
	return getRuleContext<CPP14Parser::TrailingtypespecifierContext>(0);//1165
}

CPP14Parser::ClassspecifierContext* CPP14Parser::TypespecifierContext::classspecifier()
{
	return getRuleContext<CPP14Parser::ClassspecifierContext>(0);//1165
}

CPP14Parser::EnumspecifierContext* CPP14Parser::TypespecifierContext::enumspecifier()
{
	return getRuleContext<CPP14Parser::EnumspecifierContext>(0);//1165
}


size_t CPP14Parser::TypespecifierContext::getRuleIndex() const
{
	return CPP14Parser::RuleTypespecifier;//688
}

void CPP14Parser::TypespecifierContext::copyFrom(TypespecifierContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::TypespecifierContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<TypespecifierContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::TypespecifierContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::TypespecifierContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::TypespecifierContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitTypespecifier(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::TypespecifierContext* CPP14Parser::typespecifier( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<TypespecifierContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 150, CPP14Parser::RuleTypespecifier);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1282);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 113, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(1279); //951
			trailingtypespecifier(ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(1280); //951
			classspecifier(ctx);
			break;
		}

		case 3:
		{
			enterOuterAlt(ctx, 3);
			setState(1281); //951
			enumspecifier(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::TypespecifierContext> CPP14Parser::parsetypespecifier()
{
	typespecifier();
	auto result = std::unique_ptr<TypespecifierContext>(dynamic_cast<TypespecifierContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- TrailingtypespecifierContext ------------------------------------------------------------------

CPP14Parser::TrailingtypespecifierContext::TrailingtypespecifierContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::SimpletypespecifierContext* CPP14Parser::TrailingtypespecifierContext::simpletypespecifier()
{
	return getRuleContext<CPP14Parser::SimpletypespecifierContext>(0);//1165
}

CPP14Parser::ElaboratedtypespecifierContext* CPP14Parser::TrailingtypespecifierContext::elaboratedtypespecifier()
{
	return getRuleContext<CPP14Parser::ElaboratedtypespecifierContext>(0);//1165
}

CPP14Parser::TypenamespecifierContext* CPP14Parser::TrailingtypespecifierContext::typenamespecifier()
{
	return getRuleContext<CPP14Parser::TypenamespecifierContext>(0);//1165
}

CPP14Parser::CvqualifierContext* CPP14Parser::TrailingtypespecifierContext::cvqualifier()
{
	return getRuleContext<CPP14Parser::CvqualifierContext>(0);//1165
}


size_t CPP14Parser::TrailingtypespecifierContext::getRuleIndex() const
{
	return CPP14Parser::RuleTrailingtypespecifier;//688
}

void CPP14Parser::TrailingtypespecifierContext::copyFrom(TrailingtypespecifierContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::TrailingtypespecifierContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<TrailingtypespecifierContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::TrailingtypespecifierContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::TrailingtypespecifierContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::TrailingtypespecifierContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitTrailingtypespecifier(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::TrailingtypespecifierContext* CPP14Parser::trailingtypespecifier( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<TrailingtypespecifierContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 152, CPP14Parser::RuleTrailingtypespecifier);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1288);//750
		_errHandler->sync(this, ctx);
		switch (_input->LA(1))
		{
			case CPP14Parser::Auto:
			case CPP14Parser::Bool:
			case CPP14Parser::Char:
			case CPP14Parser::Char16:
			case CPP14Parser::Char32:
			case CPP14Parser::Decltype:
			case CPP14Parser::Double:
			case CPP14Parser::Float:
			case CPP14Parser::Int:
			case CPP14Parser::Long:
			case CPP14Parser::Short:
			case CPP14Parser::Signed:
			case CPP14Parser::Unsigned:
			case CPP14Parser::Void:
			case CPP14Parser::Wchar:
			case CPP14Parser::Doublecolon:
			case CPP14Parser::Identifier:
			{
				enterOuterAlt(ctx, 1);
				setState(1284); //951
				simpletypespecifier(ctx);
				break;
			}

			case CPP14Parser::Class:
			case CPP14Parser::Enum:
			case CPP14Parser::Struct:
			case CPP14Parser::Union:
			{
				enterOuterAlt(ctx, 2);
				setState(1285); //951
				elaboratedtypespecifier(ctx);
				break;
			}

			case CPP14Parser::Typename_:
			{
				enterOuterAlt(ctx, 3);
				setState(1286); //951
				typenamespecifier(ctx);
				break;
			}

			case CPP14Parser::Const:
			case CPP14Parser::Volatile:
			{
				enterOuterAlt(ctx, 4);
				setState(1287); //951
				cvqualifier(ctx);
				break;
			}

		default:
			throw NoViableAltException(this, ctx);
		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::TrailingtypespecifierContext> CPP14Parser::parsetrailingtypespecifier()
{
	trailingtypespecifier();
	auto result = std::unique_ptr<TrailingtypespecifierContext>(dynamic_cast<TrailingtypespecifierContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- TypespecifierseqContext ------------------------------------------------------------------

CPP14Parser::TypespecifierseqContext::TypespecifierseqContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::TypespecifierContext* CPP14Parser::TypespecifierseqContext::typespecifier()
{
	return getRuleContext<CPP14Parser::TypespecifierContext>(0);//1165
}

CPP14Parser::AttributespecifierseqContext* CPP14Parser::TypespecifierseqContext::attributespecifierseq()
{
	return getRuleContext<CPP14Parser::AttributespecifierseqContext>(0);//1165
}

CPP14Parser::TypespecifierseqContext* CPP14Parser::TypespecifierseqContext::typespecifierseq()
{
	return getRuleContext<CPP14Parser::TypespecifierseqContext>(0);//1165
}


size_t CPP14Parser::TypespecifierseqContext::getRuleIndex() const
{
	return CPP14Parser::RuleTypespecifierseq;//688
}

void CPP14Parser::TypespecifierseqContext::copyFrom(TypespecifierseqContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::TypespecifierseqContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<TypespecifierseqContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::TypespecifierseqContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::TypespecifierseqContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::TypespecifierseqContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitTypespecifierseq(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::TypespecifierseqContext* CPP14Parser::typespecifierseq( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<TypespecifierseqContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 154, CPP14Parser::RuleTypespecifierseq);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1297);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 116, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(1290); //951
			typespecifier(ctx);
			setState(1292);//848
			_errHandler->sync(this, ctx);

			switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 115, ctx))
			{
			case 1:
			{
				setState(1291); //951
				attributespecifierseq(0,ctx);
				break;
			}

			}
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(1294); //951
			typespecifier(ctx);
			setState(1295); //951
			typespecifierseq(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::TypespecifierseqContext> CPP14Parser::parsetypespecifierseq()
{
	typespecifierseq();
	auto result = std::unique_ptr<TypespecifierseqContext>(dynamic_cast<TypespecifierseqContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- TrailingtypespecifierseqContext ------------------------------------------------------------------

CPP14Parser::TrailingtypespecifierseqContext::TrailingtypespecifierseqContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::TrailingtypespecifierContext* CPP14Parser::TrailingtypespecifierseqContext::trailingtypespecifier()
{
	return getRuleContext<CPP14Parser::TrailingtypespecifierContext>(0);//1165
}

CPP14Parser::AttributespecifierseqContext* CPP14Parser::TrailingtypespecifierseqContext::attributespecifierseq()
{
	return getRuleContext<CPP14Parser::AttributespecifierseqContext>(0);//1165
}

CPP14Parser::TrailingtypespecifierseqContext* CPP14Parser::TrailingtypespecifierseqContext::trailingtypespecifierseq()
{
	return getRuleContext<CPP14Parser::TrailingtypespecifierseqContext>(0);//1165
}


size_t CPP14Parser::TrailingtypespecifierseqContext::getRuleIndex() const
{
	return CPP14Parser::RuleTrailingtypespecifierseq;//688
}

void CPP14Parser::TrailingtypespecifierseqContext::copyFrom(TrailingtypespecifierseqContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::TrailingtypespecifierseqContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<TrailingtypespecifierseqContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::TrailingtypespecifierseqContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::TrailingtypespecifierseqContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::TrailingtypespecifierseqContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitTrailingtypespecifierseq(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::TrailingtypespecifierseqContext* CPP14Parser::trailingtypespecifierseq( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<TrailingtypespecifierseqContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 156, CPP14Parser::RuleTrailingtypespecifierseq);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1306);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 118, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(1299); //951
			trailingtypespecifier(ctx);
			setState(1301);//848
			_errHandler->sync(this, ctx);

			switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 117, ctx))
			{
			case 1:
			{
				setState(1300); //951
				attributespecifierseq(0,ctx);
				break;
			}

			}
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(1303); //951
			trailingtypespecifier(ctx);
			setState(1304); //951
			trailingtypespecifierseq(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::TrailingtypespecifierseqContext> CPP14Parser::parsetrailingtypespecifierseq()
{
	trailingtypespecifierseq();
	auto result = std::unique_ptr<TrailingtypespecifierseqContext>(dynamic_cast<TrailingtypespecifierseqContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- SimpletypespecifierContext ------------------------------------------------------------------

CPP14Parser::SimpletypespecifierContext::SimpletypespecifierContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::ThetypenameContext* CPP14Parser::SimpletypespecifierContext::thetypename()
{
	return getRuleContext<CPP14Parser::ThetypenameContext>(0);//1165
}

CPP14Parser::NestednamespecifierContext* CPP14Parser::SimpletypespecifierContext::nestednamespecifier()
{
	return getRuleContext<CPP14Parser::NestednamespecifierContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::SimpletypespecifierContext::Template()
{
	return getToken(CPP14Parser::Template, 0);
}

CPP14Parser::SimpletemplateidContext* CPP14Parser::SimpletypespecifierContext::simpletemplateid()
{
	return getRuleContext<CPP14Parser::SimpletemplateidContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::SimpletypespecifierContext::Char()
{
	return getToken(CPP14Parser::Char, 0);
}

tree::TerminalNode* CPP14Parser::SimpletypespecifierContext::Char16()
{
	return getToken(CPP14Parser::Char16, 0);
}

tree::TerminalNode* CPP14Parser::SimpletypespecifierContext::Char32()
{
	return getToken(CPP14Parser::Char32, 0);
}

tree::TerminalNode* CPP14Parser::SimpletypespecifierContext::Wchar()
{
	return getToken(CPP14Parser::Wchar, 0);
}

tree::TerminalNode* CPP14Parser::SimpletypespecifierContext::Bool()
{
	return getToken(CPP14Parser::Bool, 0);
}

tree::TerminalNode* CPP14Parser::SimpletypespecifierContext::Short()
{
	return getToken(CPP14Parser::Short, 0);
}

tree::TerminalNode* CPP14Parser::SimpletypespecifierContext::Int()
{
	return getToken(CPP14Parser::Int, 0);
}

tree::TerminalNode* CPP14Parser::SimpletypespecifierContext::Long()
{
	return getToken(CPP14Parser::Long, 0);
}

tree::TerminalNode* CPP14Parser::SimpletypespecifierContext::Signed()
{
	return getToken(CPP14Parser::Signed, 0);
}

tree::TerminalNode* CPP14Parser::SimpletypespecifierContext::Unsigned()
{
	return getToken(CPP14Parser::Unsigned, 0);
}

tree::TerminalNode* CPP14Parser::SimpletypespecifierContext::Float()
{
	return getToken(CPP14Parser::Float, 0);
}

tree::TerminalNode* CPP14Parser::SimpletypespecifierContext::Double()
{
	return getToken(CPP14Parser::Double, 0);
}

tree::TerminalNode* CPP14Parser::SimpletypespecifierContext::Void()
{
	return getToken(CPP14Parser::Void, 0);
}

tree::TerminalNode* CPP14Parser::SimpletypespecifierContext::Auto()
{
	return getToken(CPP14Parser::Auto, 0);
}

CPP14Parser::DecltypespecifierContext* CPP14Parser::SimpletypespecifierContext::decltypespecifier()
{
	return getRuleContext<CPP14Parser::DecltypespecifierContext>(0);//1165
}


size_t CPP14Parser::SimpletypespecifierContext::getRuleIndex() const
{
	return CPP14Parser::RuleSimpletypespecifier;//688
}

void CPP14Parser::SimpletypespecifierContext::copyFrom(SimpletypespecifierContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::SimpletypespecifierContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<SimpletypespecifierContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::SimpletypespecifierContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::SimpletypespecifierContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::SimpletypespecifierContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitSimpletypespecifier(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::SimpletypespecifierContext* CPP14Parser::simpletypespecifier( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<SimpletypespecifierContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 158, CPP14Parser::RuleSimpletypespecifier);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1331);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 120, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(1309);//848
			_errHandler->sync(this, ctx);

			switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 119, ctx))
			{
			case 1:
			{
				setState(1308); //951
				nestednamespecifier(0,ctx);
				break;
			}

			}
			setState(1311); //951
			thetypename(ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(1312); //951
			nestednamespecifier(0,ctx);
			setState(1313);//958
			match(CPP14Parser::Template,ctx);
			setState(1314); //951
			simpletemplateid(ctx);
			break;
		}

		case 3:
		{
			enterOuterAlt(ctx, 3);
			setState(1316);//958
			match(CPP14Parser::Char,ctx);
			break;
		}

		case 4:
		{
			enterOuterAlt(ctx, 4);
			setState(1317);//958
			match(CPP14Parser::Char16,ctx);
			break;
		}

		case 5:
		{
			enterOuterAlt(ctx, 5);
			setState(1318);//958
			match(CPP14Parser::Char32,ctx);
			break;
		}

		case 6:
		{
			enterOuterAlt(ctx, 6);
			setState(1319);//958
			match(CPP14Parser::Wchar,ctx);
			break;
		}

		case 7:
		{
			enterOuterAlt(ctx, 7);
			setState(1320);//958
			match(CPP14Parser::Bool,ctx);
			break;
		}

		case 8:
		{
			enterOuterAlt(ctx, 8);
			setState(1321);//958
			match(CPP14Parser::Short,ctx);
			break;
		}

		case 9:
		{
			enterOuterAlt(ctx, 9);
			setState(1322);//958
			match(CPP14Parser::Int,ctx);
			break;
		}

		case 10:
		{
			enterOuterAlt(ctx, 10);
			setState(1323);//958
			match(CPP14Parser::Long,ctx);
			break;
		}

		case 11:
		{
			enterOuterAlt(ctx, 11);
			setState(1324);//958
			match(CPP14Parser::Signed,ctx);
			break;
		}

		case 12:
		{
			enterOuterAlt(ctx, 12);
			setState(1325);//958
			match(CPP14Parser::Unsigned,ctx);
			break;
		}

		case 13:
		{
			enterOuterAlt(ctx, 13);
			setState(1326);//958
			match(CPP14Parser::Float,ctx);
			break;
		}

		case 14:
		{
			enterOuterAlt(ctx, 14);
			setState(1327);//958
			match(CPP14Parser::Double,ctx);
			break;
		}

		case 15:
		{
			enterOuterAlt(ctx, 15);
			setState(1328);//958
			match(CPP14Parser::Void,ctx);
			break;
		}

		case 16:
		{
			enterOuterAlt(ctx, 16);
			setState(1329);//958
			match(CPP14Parser::Auto,ctx);
			break;
		}

		case 17:
		{
			enterOuterAlt(ctx, 17);
			setState(1330); //951
			decltypespecifier(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::SimpletypespecifierContext> CPP14Parser::parsesimpletypespecifier()
{
	simpletypespecifier();
	auto result = std::unique_ptr<SimpletypespecifierContext>(dynamic_cast<SimpletypespecifierContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- ThetypenameContext ------------------------------------------------------------------

CPP14Parser::ThetypenameContext::ThetypenameContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::ClassnameContext* CPP14Parser::ThetypenameContext::classname()
{
	return getRuleContext<CPP14Parser::ClassnameContext>(0);//1165
}

CPP14Parser::EnumnameContext* CPP14Parser::ThetypenameContext::enumname()
{
	return getRuleContext<CPP14Parser::EnumnameContext>(0);//1165
}

CPP14Parser::TypedefnameContext* CPP14Parser::ThetypenameContext::typedefname()
{
	return getRuleContext<CPP14Parser::TypedefnameContext>(0);//1165
}

CPP14Parser::SimpletemplateidContext* CPP14Parser::ThetypenameContext::simpletemplateid()
{
	return getRuleContext<CPP14Parser::SimpletemplateidContext>(0);//1165
}


size_t CPP14Parser::ThetypenameContext::getRuleIndex() const
{
	return CPP14Parser::RuleThetypename;//688
}

void CPP14Parser::ThetypenameContext::copyFrom(ThetypenameContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::ThetypenameContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<ThetypenameContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::ThetypenameContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::ThetypenameContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::ThetypenameContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitThetypename(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::ThetypenameContext* CPP14Parser::thetypename( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<ThetypenameContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 160, CPP14Parser::RuleThetypename);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1337);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 121, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(1333); //951
			classname(ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(1334); //951
			enumname(ctx);
			break;
		}

		case 3:
		{
			enterOuterAlt(ctx, 3);
			setState(1335); //951
			typedefname(ctx);
			break;
		}

		case 4:
		{
			enterOuterAlt(ctx, 4);
			setState(1336); //951
			simpletemplateid(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::ThetypenameContext> CPP14Parser::parsethetypename()
{
	thetypename();
	auto result = std::unique_ptr<ThetypenameContext>(dynamic_cast<ThetypenameContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- DecltypespecifierContext ------------------------------------------------------------------

CPP14Parser::DecltypespecifierContext::DecltypespecifierContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::DecltypespecifierContext::Decltype()
{
	return getToken(CPP14Parser::Decltype, 0);
}

tree::TerminalNode* CPP14Parser::DecltypespecifierContext::LeftParen()
{
	return getToken(CPP14Parser::LeftParen, 0);
}

CPP14Parser::ExpressionContext* CPP14Parser::DecltypespecifierContext::expression()
{
	return getRuleContext<CPP14Parser::ExpressionContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::DecltypespecifierContext::RightParen()
{
	return getToken(CPP14Parser::RightParen, 0);
}

tree::TerminalNode* CPP14Parser::DecltypespecifierContext::Auto()
{
	return getToken(CPP14Parser::Auto, 0);
}


size_t CPP14Parser::DecltypespecifierContext::getRuleIndex() const
{
	return CPP14Parser::RuleDecltypespecifier;//688
}

void CPP14Parser::DecltypespecifierContext::copyFrom(DecltypespecifierContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::DecltypespecifierContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<DecltypespecifierContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::DecltypespecifierContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::DecltypespecifierContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::DecltypespecifierContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitDecltypespecifier(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::DecltypespecifierContext* CPP14Parser::decltypespecifier( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<DecltypespecifierContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 162, CPP14Parser::RuleDecltypespecifier);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1348);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 122, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(1339);//958
			match(CPP14Parser::Decltype,ctx);
			setState(1340);//958
			match(CPP14Parser::LeftParen,ctx);
			setState(1341); //951
			expression(0,ctx);
			setState(1342);//958
			match(CPP14Parser::RightParen,ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(1344);//958
			match(CPP14Parser::Decltype,ctx);
			setState(1345);//958
			match(CPP14Parser::LeftParen,ctx);
			setState(1346);//958
			match(CPP14Parser::Auto,ctx);
			setState(1347);//958
			match(CPP14Parser::RightParen,ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::DecltypespecifierContext> CPP14Parser::parsedecltypespecifier()
{
	decltypespecifier();
	auto result = std::unique_ptr<DecltypespecifierContext>(dynamic_cast<DecltypespecifierContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- ElaboratedtypespecifierContext ------------------------------------------------------------------

CPP14Parser::ElaboratedtypespecifierContext::ElaboratedtypespecifierContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::ClasskeyContext* CPP14Parser::ElaboratedtypespecifierContext::classkey()
{
	return getRuleContext<CPP14Parser::ClasskeyContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::ElaboratedtypespecifierContext::Identifier()
{
	return getToken(CPP14Parser::Identifier, 0);
}

CPP14Parser::AttributespecifierseqContext* CPP14Parser::ElaboratedtypespecifierContext::attributespecifierseq()
{
	return getRuleContext<CPP14Parser::AttributespecifierseqContext>(0);//1165
}

CPP14Parser::NestednamespecifierContext* CPP14Parser::ElaboratedtypespecifierContext::nestednamespecifier()
{
	return getRuleContext<CPP14Parser::NestednamespecifierContext>(0);//1165
}

CPP14Parser::SimpletemplateidContext* CPP14Parser::ElaboratedtypespecifierContext::simpletemplateid()
{
	return getRuleContext<CPP14Parser::SimpletemplateidContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::ElaboratedtypespecifierContext::Template()
{
	return getToken(CPP14Parser::Template, 0);
}

tree::TerminalNode* CPP14Parser::ElaboratedtypespecifierContext::Enum()
{
	return getToken(CPP14Parser::Enum, 0);
}


size_t CPP14Parser::ElaboratedtypespecifierContext::getRuleIndex() const
{
	return CPP14Parser::RuleElaboratedtypespecifier;//688
}

void CPP14Parser::ElaboratedtypespecifierContext::copyFrom(ElaboratedtypespecifierContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::ElaboratedtypespecifierContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<ElaboratedtypespecifierContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::ElaboratedtypespecifierContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::ElaboratedtypespecifierContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::ElaboratedtypespecifierContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitElaboratedtypespecifier(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::ElaboratedtypespecifierContext* CPP14Parser::elaboratedtypespecifier( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<ElaboratedtypespecifierContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 164, CPP14Parser::RuleElaboratedtypespecifier);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1374);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 127, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(1350); //951
			classkey(ctx);
			setState(1352);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Alignas || _la == CPP14Parser::LeftBracket)
			{
				setState(1351); //951
				attributespecifierseq(0,ctx);
			}
			setState(1355);//848
			_errHandler->sync(this, ctx);

			switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 124, ctx))
			{
			case 1:
			{
				setState(1354); //951
				nestednamespecifier(0,ctx);
				break;
			}

			}
			setState(1357);//958
			match(CPP14Parser::Identifier,ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(1359); //951
			classkey(ctx);
			setState(1360); //951
			simpletemplateid(ctx);
			break;
		}

		case 3:
		{
			enterOuterAlt(ctx, 3);
			setState(1362); //951
			classkey(ctx);
			setState(1363); //951
			nestednamespecifier(0,ctx);
			setState(1365);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Template)
			{
				setState(1364);//958
				match(CPP14Parser::Template,ctx);
			}
			setState(1367); //951
			simpletemplateid(ctx);
			break;
		}

		case 4:
		{
			enterOuterAlt(ctx, 4);
			setState(1369);//958
			match(CPP14Parser::Enum,ctx);
			setState(1371);//848
			_errHandler->sync(this, ctx);

			switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 126, ctx))
			{
			case 1:
			{
				setState(1370); //951
				nestednamespecifier(0,ctx);
				break;
			}

			}
			setState(1373);//958
			match(CPP14Parser::Identifier,ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::ElaboratedtypespecifierContext> CPP14Parser::parseelaboratedtypespecifier()
{
	elaboratedtypespecifier();
	auto result = std::unique_ptr<ElaboratedtypespecifierContext>(dynamic_cast<ElaboratedtypespecifierContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- EnumnameContext ------------------------------------------------------------------

CPP14Parser::EnumnameContext::EnumnameContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::EnumnameContext::Identifier()
{
	return getToken(CPP14Parser::Identifier, 0);
}


size_t CPP14Parser::EnumnameContext::getRuleIndex() const
{
	return CPP14Parser::RuleEnumname;//688
}

void CPP14Parser::EnumnameContext::copyFrom(EnumnameContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::EnumnameContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<EnumnameContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::EnumnameContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::EnumnameContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::EnumnameContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitEnumname(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::EnumnameContext* CPP14Parser::enumname( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<EnumnameContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 166, CPP14Parser::RuleEnumname);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1376);//958
		match(CPP14Parser::Identifier,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::EnumnameContext> CPP14Parser::parseenumname()
{
	enumname();
	auto result = std::unique_ptr<EnumnameContext>(dynamic_cast<EnumnameContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- EnumspecifierContext ------------------------------------------------------------------

CPP14Parser::EnumspecifierContext::EnumspecifierContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::EnumheadContext* CPP14Parser::EnumspecifierContext::enumhead()
{
	return getRuleContext<CPP14Parser::EnumheadContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::EnumspecifierContext::LeftBrace()
{
	return getToken(CPP14Parser::LeftBrace, 0);
}

tree::TerminalNode* CPP14Parser::EnumspecifierContext::RightBrace()
{
	return getToken(CPP14Parser::RightBrace, 0);
}

CPP14Parser::EnumeratorlistContext* CPP14Parser::EnumspecifierContext::enumeratorlist()
{
	return getRuleContext<CPP14Parser::EnumeratorlistContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::EnumspecifierContext::Comma()
{
	return getToken(CPP14Parser::Comma, 0);
}


size_t CPP14Parser::EnumspecifierContext::getRuleIndex() const
{
	return CPP14Parser::RuleEnumspecifier;//688
}

void CPP14Parser::EnumspecifierContext::copyFrom(EnumspecifierContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::EnumspecifierContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<EnumspecifierContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::EnumspecifierContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::EnumspecifierContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::EnumspecifierContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitEnumspecifier(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::EnumspecifierContext* CPP14Parser::enumspecifier( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<EnumspecifierContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 168, CPP14Parser::RuleEnumspecifier);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1391);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 129, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(1378); //951
			enumhead(ctx);
			setState(1379);//958
			match(CPP14Parser::LeftBrace,ctx);
			setState(1381);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Identifier)
			{
				setState(1380); //951
				enumeratorlist(0,ctx);
			}
			setState(1383);//958
			match(CPP14Parser::RightBrace,ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(1385); //951
			enumhead(ctx);
			setState(1386);//958
			match(CPP14Parser::LeftBrace,ctx);
			setState(1387); //951
			enumeratorlist(0,ctx);
			setState(1388);//958
			match(CPP14Parser::Comma,ctx);
			setState(1389);//958
			match(CPP14Parser::RightBrace,ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::EnumspecifierContext> CPP14Parser::parseenumspecifier()
{
	enumspecifier();
	auto result = std::unique_ptr<EnumspecifierContext>(dynamic_cast<EnumspecifierContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- EnumheadContext ------------------------------------------------------------------

CPP14Parser::EnumheadContext::EnumheadContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::EnumkeyContext* CPP14Parser::EnumheadContext::enumkey()
{
	return getRuleContext<CPP14Parser::EnumkeyContext>(0);//1165
}

CPP14Parser::AttributespecifierseqContext* CPP14Parser::EnumheadContext::attributespecifierseq()
{
	return getRuleContext<CPP14Parser::AttributespecifierseqContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::EnumheadContext::Identifier()
{
	return getToken(CPP14Parser::Identifier, 0);
}

CPP14Parser::EnumbaseContext* CPP14Parser::EnumheadContext::enumbase()
{
	return getRuleContext<CPP14Parser::EnumbaseContext>(0);//1165
}

CPP14Parser::NestednamespecifierContext* CPP14Parser::EnumheadContext::nestednamespecifier()
{
	return getRuleContext<CPP14Parser::NestednamespecifierContext>(0);//1165
}


size_t CPP14Parser::EnumheadContext::getRuleIndex() const
{
	return CPP14Parser::RuleEnumhead;//688
}

void CPP14Parser::EnumheadContext::copyFrom(EnumheadContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::EnumheadContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<EnumheadContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::EnumheadContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::EnumheadContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::EnumheadContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitEnumhead(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::EnumheadContext* CPP14Parser::enumhead( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<EnumheadContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 170, CPP14Parser::RuleEnumhead);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1412);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 135, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(1393); //951
			enumkey(ctx);
			setState(1395);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Alignas || _la == CPP14Parser::LeftBracket)
			{
				setState(1394); //951
				attributespecifierseq(0,ctx);
			}
			setState(1398);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Identifier)
			{
				setState(1397);//958
				match(CPP14Parser::Identifier,ctx);
			}
			setState(1401);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Colon)
			{
				setState(1400); //951
				enumbase(ctx);
			}
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(1403); //951
			enumkey(ctx);
			setState(1405);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Alignas || _la == CPP14Parser::LeftBracket)
			{
				setState(1404); //951
				attributespecifierseq(0,ctx);
			}
			setState(1407); //951
			nestednamespecifier(0,ctx);
			setState(1408);//958
			match(CPP14Parser::Identifier,ctx);
			setState(1410);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Colon)
			{
				setState(1409); //951
				enumbase(ctx);
			}
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::EnumheadContext> CPP14Parser::parseenumhead()
{
	enumhead();
	auto result = std::unique_ptr<EnumheadContext>(dynamic_cast<EnumheadContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- OpaqueenumdeclarationContext ------------------------------------------------------------------

CPP14Parser::OpaqueenumdeclarationContext::OpaqueenumdeclarationContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::EnumkeyContext* CPP14Parser::OpaqueenumdeclarationContext::enumkey()
{
	return getRuleContext<CPP14Parser::EnumkeyContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::OpaqueenumdeclarationContext::Identifier()
{
	return getToken(CPP14Parser::Identifier, 0);
}

tree::TerminalNode* CPP14Parser::OpaqueenumdeclarationContext::Semi()
{
	return getToken(CPP14Parser::Semi, 0);
}

CPP14Parser::AttributespecifierseqContext* CPP14Parser::OpaqueenumdeclarationContext::attributespecifierseq()
{
	return getRuleContext<CPP14Parser::AttributespecifierseqContext>(0);//1165
}

CPP14Parser::EnumbaseContext* CPP14Parser::OpaqueenumdeclarationContext::enumbase()
{
	return getRuleContext<CPP14Parser::EnumbaseContext>(0);//1165
}


size_t CPP14Parser::OpaqueenumdeclarationContext::getRuleIndex() const
{
	return CPP14Parser::RuleOpaqueenumdeclaration;//688
}

void CPP14Parser::OpaqueenumdeclarationContext::copyFrom(OpaqueenumdeclarationContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::OpaqueenumdeclarationContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<OpaqueenumdeclarationContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::OpaqueenumdeclarationContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::OpaqueenumdeclarationContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::OpaqueenumdeclarationContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitOpaqueenumdeclaration(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::OpaqueenumdeclarationContext* CPP14Parser::opaqueenumdeclaration( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<OpaqueenumdeclarationContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 172, CPP14Parser::RuleOpaqueenumdeclaration);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1414); //951
		enumkey(ctx);
		setState(1416);//788
		_errHandler->sync(this, ctx);

		_la = _input->LA(1);
		if (_la == CPP14Parser::Alignas || _la == CPP14Parser::LeftBracket)
		{
			setState(1415); //951
			attributespecifierseq(0,ctx);
		}
		setState(1418);//958
		match(CPP14Parser::Identifier,ctx);
		setState(1420);//788
		_errHandler->sync(this, ctx);

		_la = _input->LA(1);
		if (_la == CPP14Parser::Colon)
		{
			setState(1419); //951
			enumbase(ctx);
		}
		setState(1422);//958
		match(CPP14Parser::Semi,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::OpaqueenumdeclarationContext> CPP14Parser::parseopaqueenumdeclaration()
{
	opaqueenumdeclaration();
	auto result = std::unique_ptr<OpaqueenumdeclarationContext>(dynamic_cast<OpaqueenumdeclarationContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- EnumkeyContext ------------------------------------------------------------------

CPP14Parser::EnumkeyContext::EnumkeyContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::EnumkeyContext::Enum()
{
	return getToken(CPP14Parser::Enum, 0);
}

tree::TerminalNode* CPP14Parser::EnumkeyContext::Class()
{
	return getToken(CPP14Parser::Class, 0);
}

tree::TerminalNode* CPP14Parser::EnumkeyContext::Struct()
{
	return getToken(CPP14Parser::Struct, 0);
}


size_t CPP14Parser::EnumkeyContext::getRuleIndex() const
{
	return CPP14Parser::RuleEnumkey;//688
}

void CPP14Parser::EnumkeyContext::copyFrom(EnumkeyContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::EnumkeyContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<EnumkeyContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::EnumkeyContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::EnumkeyContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::EnumkeyContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitEnumkey(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::EnumkeyContext* CPP14Parser::enumkey( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<EnumkeyContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 174, CPP14Parser::RuleEnumkey);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1429);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 138, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(1424);//958
			match(CPP14Parser::Enum,ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(1425);//958
			match(CPP14Parser::Enum,ctx);
			setState(1426);//958
			match(CPP14Parser::Class,ctx);
			break;
		}

		case 3:
		{
			enterOuterAlt(ctx, 3);
			setState(1427);//958
			match(CPP14Parser::Enum,ctx);
			setState(1428);//958
			match(CPP14Parser::Struct,ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::EnumkeyContext> CPP14Parser::parseenumkey()
{
	enumkey();
	auto result = std::unique_ptr<EnumkeyContext>(dynamic_cast<EnumkeyContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- EnumbaseContext ------------------------------------------------------------------

CPP14Parser::EnumbaseContext::EnumbaseContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::EnumbaseContext::Colon()
{
	return getToken(CPP14Parser::Colon, 0);
}

CPP14Parser::TypespecifierseqContext* CPP14Parser::EnumbaseContext::typespecifierseq()
{
	return getRuleContext<CPP14Parser::TypespecifierseqContext>(0);//1165
}


size_t CPP14Parser::EnumbaseContext::getRuleIndex() const
{
	return CPP14Parser::RuleEnumbase;//688
}

void CPP14Parser::EnumbaseContext::copyFrom(EnumbaseContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::EnumbaseContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<EnumbaseContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::EnumbaseContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::EnumbaseContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::EnumbaseContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitEnumbase(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::EnumbaseContext* CPP14Parser::enumbase( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<EnumbaseContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 176, CPP14Parser::RuleEnumbase);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1431);//958
		match(CPP14Parser::Colon,ctx);
		setState(1432); //951
		typespecifierseq(ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::EnumbaseContext> CPP14Parser::parseenumbase()
{
	enumbase();
	auto result = std::unique_ptr<EnumbaseContext>(dynamic_cast<EnumbaseContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- EnumeratorlistContext ------------------------------------------------------------------

CPP14Parser::EnumeratorlistContext::EnumeratorlistContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::EnumeratordefinitionContext* CPP14Parser::EnumeratorlistContext::enumeratordefinition()
{
	return getRuleContext<CPP14Parser::EnumeratordefinitionContext>(0);//1165
}

CPP14Parser::EnumeratorlistContext* CPP14Parser::EnumeratorlistContext::enumeratorlist()
{
	return getRuleContext<CPP14Parser::EnumeratorlistContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::EnumeratorlistContext::Comma()
{
	return getToken(CPP14Parser::Comma, 0);
}


size_t CPP14Parser::EnumeratorlistContext::getRuleIndex() const
{
	return CPP14Parser::RuleEnumeratorlist;//688
}

void CPP14Parser::EnumeratorlistContext::copyFrom(EnumeratorlistContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::EnumeratorlistContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<EnumeratorlistContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::EnumeratorlistContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::EnumeratorlistContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::EnumeratorlistContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitEnumeratorlist(this);
	else
		return visitor->visitChildren(this);
}


CPP14Parser::EnumeratorlistContext* CPP14Parser::enumeratorlist()
{
	 return enumeratorlist(0, nullptr);//600
}

CPP14Parser::EnumeratorlistContext* CPP14Parser::enumeratorlist(int precedence, antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	antlr4::ParserRuleContext *parentContext = parent;
	size_t parentState = getState();
	auto _localctx = std::make_unique<EnumeratorlistContext>(parentContext, parentState);//610
	auto ctx = _localctx.get();//609
	size_t startState = 178;
	enterRecursionRule(ctx, 178, CPP14Parser::RuleEnumeratorlist, precedence);

		

	auto onExit = finally([=,&_localctx]
{
		unrollRecursionContexts(parentContext, std::move(_localctx));
	});
	try
{
		size_t alt;
		enterOuterAlt(ctx, 1);
		setState(1435); //951
		enumeratordefinition(ctx);
		ctx->stop = _input->LT(-1);
		setState(1442);//865
		_errHandler->sync(this, ctx);
		alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 139, ctx);
		while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
		{
			if (alt == 1)
		{
				if (!_parseListeners.empty())
					triggerExitRuleEvent(ctx);

				auto tmpContext = std::make_unique<EnumeratorlistContext>(parentContext, parentState);
				pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleEnumeratorlist);//1240
				_localctx = std::move(tmpContext);
				ctx = _localctx.get();
				setState(1437);//1002

				if (!(precpred(nullptr, 1))) throw FailedPredicateException(this, "precpred(nullptr, 1)", ctx);
				setState(1438);//958
				match(CPP14Parser::Comma,ctx);
				setState(1439); //951
				enumeratordefinition(ctx); 
			}
			setState(1444);//875
			_errHandler->sync(this, ctx);
			alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 139, ctx);
		}
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		_localctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}
	onExit();
	return ctx;
}

std::unique_ptr< CPP14Parser::EnumeratorlistContext> CPP14Parser::parseenumeratorlist()
{
	enumeratorlist();
	auto result = std::unique_ptr<EnumeratorlistContext>(dynamic_cast<EnumeratorlistContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}

//----------------- EnumeratordefinitionContext ------------------------------------------------------------------

CPP14Parser::EnumeratordefinitionContext::EnumeratordefinitionContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::EnumeratorContext* CPP14Parser::EnumeratordefinitionContext::enumerator()
{
	return getRuleContext<CPP14Parser::EnumeratorContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::EnumeratordefinitionContext::Assign()
{
	return getToken(CPP14Parser::Assign, 0);
}

CPP14Parser::ConstantexpressionContext* CPP14Parser::EnumeratordefinitionContext::constantexpression()
{
	return getRuleContext<CPP14Parser::ConstantexpressionContext>(0);//1165
}


size_t CPP14Parser::EnumeratordefinitionContext::getRuleIndex() const
{
	return CPP14Parser::RuleEnumeratordefinition;//688
}

void CPP14Parser::EnumeratordefinitionContext::copyFrom(EnumeratordefinitionContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::EnumeratordefinitionContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<EnumeratordefinitionContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::EnumeratordefinitionContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::EnumeratordefinitionContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::EnumeratordefinitionContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitEnumeratordefinition(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::EnumeratordefinitionContext* CPP14Parser::enumeratordefinition( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<EnumeratordefinitionContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 180, CPP14Parser::RuleEnumeratordefinition);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1450);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 140, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(1445); //951
			enumerator(ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(1446); //951
			enumerator(ctx);
			setState(1447);//958
			match(CPP14Parser::Assign,ctx);
			setState(1448); //951
			constantexpression(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::EnumeratordefinitionContext> CPP14Parser::parseenumeratordefinition()
{
	enumeratordefinition();
	auto result = std::unique_ptr<EnumeratordefinitionContext>(dynamic_cast<EnumeratordefinitionContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- EnumeratorContext ------------------------------------------------------------------

CPP14Parser::EnumeratorContext::EnumeratorContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::EnumeratorContext::Identifier()
{
	return getToken(CPP14Parser::Identifier, 0);
}


size_t CPP14Parser::EnumeratorContext::getRuleIndex() const
{
	return CPP14Parser::RuleEnumerator;//688
}

void CPP14Parser::EnumeratorContext::copyFrom(EnumeratorContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::EnumeratorContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<EnumeratorContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::EnumeratorContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::EnumeratorContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::EnumeratorContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitEnumerator(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::EnumeratorContext* CPP14Parser::enumerator( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<EnumeratorContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 182, CPP14Parser::RuleEnumerator);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1452);//958
		match(CPP14Parser::Identifier,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::EnumeratorContext> CPP14Parser::parseenumerator()
{
	enumerator();
	auto result = std::unique_ptr<EnumeratorContext>(dynamic_cast<EnumeratorContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- NamespacenameContext ------------------------------------------------------------------

CPP14Parser::NamespacenameContext::NamespacenameContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::OriginalnamespacenameContext* CPP14Parser::NamespacenameContext::originalnamespacename()
{
	return getRuleContext<CPP14Parser::OriginalnamespacenameContext>(0);//1165
}

CPP14Parser::NamespacealiasContext* CPP14Parser::NamespacenameContext::namespacealias()
{
	return getRuleContext<CPP14Parser::NamespacealiasContext>(0);//1165
}


size_t CPP14Parser::NamespacenameContext::getRuleIndex() const
{
	return CPP14Parser::RuleNamespacename;//688
}

void CPP14Parser::NamespacenameContext::copyFrom(NamespacenameContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::NamespacenameContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<NamespacenameContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::NamespacenameContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::NamespacenameContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::NamespacenameContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitNamespacename(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::NamespacenameContext* CPP14Parser::namespacename( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<NamespacenameContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 184, CPP14Parser::RuleNamespacename);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1456);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 141, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(1454); //951
			originalnamespacename(ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(1455); //951
			namespacealias(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::NamespacenameContext> CPP14Parser::parsenamespacename()
{
	namespacename();
	auto result = std::unique_ptr<NamespacenameContext>(dynamic_cast<NamespacenameContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- OriginalnamespacenameContext ------------------------------------------------------------------

CPP14Parser::OriginalnamespacenameContext::OriginalnamespacenameContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::OriginalnamespacenameContext::Identifier()
{
	return getToken(CPP14Parser::Identifier, 0);
}


size_t CPP14Parser::OriginalnamespacenameContext::getRuleIndex() const
{
	return CPP14Parser::RuleOriginalnamespacename;//688
}

void CPP14Parser::OriginalnamespacenameContext::copyFrom(OriginalnamespacenameContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::OriginalnamespacenameContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<OriginalnamespacenameContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::OriginalnamespacenameContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::OriginalnamespacenameContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::OriginalnamespacenameContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitOriginalnamespacename(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::OriginalnamespacenameContext* CPP14Parser::originalnamespacename( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<OriginalnamespacenameContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 186, CPP14Parser::RuleOriginalnamespacename);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1458);//958
		match(CPP14Parser::Identifier,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::OriginalnamespacenameContext> CPP14Parser::parseoriginalnamespacename()
{
	originalnamespacename();
	auto result = std::unique_ptr<OriginalnamespacenameContext>(dynamic_cast<OriginalnamespacenameContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- NamespacedefinitionContext ------------------------------------------------------------------

CPP14Parser::NamespacedefinitionContext::NamespacedefinitionContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::NamednamespacedefinitionContext* CPP14Parser::NamespacedefinitionContext::namednamespacedefinition()
{
	return getRuleContext<CPP14Parser::NamednamespacedefinitionContext>(0);//1165
}

CPP14Parser::UnnamednamespacedefinitionContext* CPP14Parser::NamespacedefinitionContext::unnamednamespacedefinition()
{
	return getRuleContext<CPP14Parser::UnnamednamespacedefinitionContext>(0);//1165
}


size_t CPP14Parser::NamespacedefinitionContext::getRuleIndex() const
{
	return CPP14Parser::RuleNamespacedefinition;//688
}

void CPP14Parser::NamespacedefinitionContext::copyFrom(NamespacedefinitionContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::NamespacedefinitionContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<NamespacedefinitionContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::NamespacedefinitionContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::NamespacedefinitionContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::NamespacedefinitionContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitNamespacedefinition(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::NamespacedefinitionContext* CPP14Parser::namespacedefinition( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<NamespacedefinitionContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 188, CPP14Parser::RuleNamespacedefinition);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1462);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 142, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(1460); //951
			namednamespacedefinition(ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(1461); //951
			unnamednamespacedefinition(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::NamespacedefinitionContext> CPP14Parser::parsenamespacedefinition()
{
	namespacedefinition();
	auto result = std::unique_ptr<NamespacedefinitionContext>(dynamic_cast<NamespacedefinitionContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- NamednamespacedefinitionContext ------------------------------------------------------------------

CPP14Parser::NamednamespacedefinitionContext::NamednamespacedefinitionContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::OriginalnamespacedefinitionContext* CPP14Parser::NamednamespacedefinitionContext::originalnamespacedefinition()
{
	return getRuleContext<CPP14Parser::OriginalnamespacedefinitionContext>(0);//1165
}

CPP14Parser::ExtensionnamespacedefinitionContext* CPP14Parser::NamednamespacedefinitionContext::extensionnamespacedefinition()
{
	return getRuleContext<CPP14Parser::ExtensionnamespacedefinitionContext>(0);//1165
}


size_t CPP14Parser::NamednamespacedefinitionContext::getRuleIndex() const
{
	return CPP14Parser::RuleNamednamespacedefinition;//688
}

void CPP14Parser::NamednamespacedefinitionContext::copyFrom(NamednamespacedefinitionContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::NamednamespacedefinitionContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<NamednamespacedefinitionContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::NamednamespacedefinitionContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::NamednamespacedefinitionContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::NamednamespacedefinitionContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitNamednamespacedefinition(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::NamednamespacedefinitionContext* CPP14Parser::namednamespacedefinition( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<NamednamespacedefinitionContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 190, CPP14Parser::RuleNamednamespacedefinition);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1466);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 143, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(1464); //951
			originalnamespacedefinition(ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(1465); //951
			extensionnamespacedefinition(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::NamednamespacedefinitionContext> CPP14Parser::parsenamednamespacedefinition()
{
	namednamespacedefinition();
	auto result = std::unique_ptr<NamednamespacedefinitionContext>(dynamic_cast<NamednamespacedefinitionContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- OriginalnamespacedefinitionContext ------------------------------------------------------------------

CPP14Parser::OriginalnamespacedefinitionContext::OriginalnamespacedefinitionContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::OriginalnamespacedefinitionContext::Namespace()
{
	return getToken(CPP14Parser::Namespace, 0);
}

tree::TerminalNode* CPP14Parser::OriginalnamespacedefinitionContext::Identifier()
{
	return getToken(CPP14Parser::Identifier, 0);
}

tree::TerminalNode* CPP14Parser::OriginalnamespacedefinitionContext::LeftBrace()
{
	return getToken(CPP14Parser::LeftBrace, 0);
}

CPP14Parser::NamespacebodyContext* CPP14Parser::OriginalnamespacedefinitionContext::namespacebody()
{
	return getRuleContext<CPP14Parser::NamespacebodyContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::OriginalnamespacedefinitionContext::RightBrace()
{
	return getToken(CPP14Parser::RightBrace, 0);
}

tree::TerminalNode* CPP14Parser::OriginalnamespacedefinitionContext::Inline()
{
	return getToken(CPP14Parser::Inline, 0);
}


size_t CPP14Parser::OriginalnamespacedefinitionContext::getRuleIndex() const
{
	return CPP14Parser::RuleOriginalnamespacedefinition;//688
}

void CPP14Parser::OriginalnamespacedefinitionContext::copyFrom(OriginalnamespacedefinitionContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::OriginalnamespacedefinitionContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<OriginalnamespacedefinitionContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::OriginalnamespacedefinitionContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::OriginalnamespacedefinitionContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::OriginalnamespacedefinitionContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitOriginalnamespacedefinition(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::OriginalnamespacedefinitionContext* CPP14Parser::originalnamespacedefinition( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<OriginalnamespacedefinitionContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 192, CPP14Parser::RuleOriginalnamespacedefinition);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1469);//788
		_errHandler->sync(this, ctx);

		_la = _input->LA(1);
		if (_la == CPP14Parser::Inline)
		{
			setState(1468);//958
			match(CPP14Parser::Inline,ctx);
		}
		setState(1471);//958
		match(CPP14Parser::Namespace,ctx);
		setState(1472);//958
		match(CPP14Parser::Identifier,ctx);
		setState(1473);//958
		match(CPP14Parser::LeftBrace,ctx);
		setState(1474); //951
		namespacebody(ctx);
		setState(1475);//958
		match(CPP14Parser::RightBrace,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::OriginalnamespacedefinitionContext> CPP14Parser::parseoriginalnamespacedefinition()
{
	originalnamespacedefinition();
	auto result = std::unique_ptr<OriginalnamespacedefinitionContext>(dynamic_cast<OriginalnamespacedefinitionContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- ExtensionnamespacedefinitionContext ------------------------------------------------------------------

CPP14Parser::ExtensionnamespacedefinitionContext::ExtensionnamespacedefinitionContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::ExtensionnamespacedefinitionContext::Namespace()
{
	return getToken(CPP14Parser::Namespace, 0);
}

CPP14Parser::OriginalnamespacenameContext* CPP14Parser::ExtensionnamespacedefinitionContext::originalnamespacename()
{
	return getRuleContext<CPP14Parser::OriginalnamespacenameContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::ExtensionnamespacedefinitionContext::LeftBrace()
{
	return getToken(CPP14Parser::LeftBrace, 0);
}

CPP14Parser::NamespacebodyContext* CPP14Parser::ExtensionnamespacedefinitionContext::namespacebody()
{
	return getRuleContext<CPP14Parser::NamespacebodyContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::ExtensionnamespacedefinitionContext::RightBrace()
{
	return getToken(CPP14Parser::RightBrace, 0);
}

tree::TerminalNode* CPP14Parser::ExtensionnamespacedefinitionContext::Inline()
{
	return getToken(CPP14Parser::Inline, 0);
}


size_t CPP14Parser::ExtensionnamespacedefinitionContext::getRuleIndex() const
{
	return CPP14Parser::RuleExtensionnamespacedefinition;//688
}

void CPP14Parser::ExtensionnamespacedefinitionContext::copyFrom(ExtensionnamespacedefinitionContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::ExtensionnamespacedefinitionContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<ExtensionnamespacedefinitionContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::ExtensionnamespacedefinitionContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::ExtensionnamespacedefinitionContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::ExtensionnamespacedefinitionContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitExtensionnamespacedefinition(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::ExtensionnamespacedefinitionContext* CPP14Parser::extensionnamespacedefinition( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<ExtensionnamespacedefinitionContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 194, CPP14Parser::RuleExtensionnamespacedefinition);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1478);//788
		_errHandler->sync(this, ctx);

		_la = _input->LA(1);
		if (_la == CPP14Parser::Inline)
		{
			setState(1477);//958
			match(CPP14Parser::Inline,ctx);
		}
		setState(1480);//958
		match(CPP14Parser::Namespace,ctx);
		setState(1481); //951
		originalnamespacename(ctx);
		setState(1482);//958
		match(CPP14Parser::LeftBrace,ctx);
		setState(1483); //951
		namespacebody(ctx);
		setState(1484);//958
		match(CPP14Parser::RightBrace,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::ExtensionnamespacedefinitionContext> CPP14Parser::parseextensionnamespacedefinition()
{
	extensionnamespacedefinition();
	auto result = std::unique_ptr<ExtensionnamespacedefinitionContext>(dynamic_cast<ExtensionnamespacedefinitionContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- UnnamednamespacedefinitionContext ------------------------------------------------------------------

CPP14Parser::UnnamednamespacedefinitionContext::UnnamednamespacedefinitionContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::UnnamednamespacedefinitionContext::Namespace()
{
	return getToken(CPP14Parser::Namespace, 0);
}

tree::TerminalNode* CPP14Parser::UnnamednamespacedefinitionContext::LeftBrace()
{
	return getToken(CPP14Parser::LeftBrace, 0);
}

CPP14Parser::NamespacebodyContext* CPP14Parser::UnnamednamespacedefinitionContext::namespacebody()
{
	return getRuleContext<CPP14Parser::NamespacebodyContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::UnnamednamespacedefinitionContext::RightBrace()
{
	return getToken(CPP14Parser::RightBrace, 0);
}

tree::TerminalNode* CPP14Parser::UnnamednamespacedefinitionContext::Inline()
{
	return getToken(CPP14Parser::Inline, 0);
}


size_t CPP14Parser::UnnamednamespacedefinitionContext::getRuleIndex() const
{
	return CPP14Parser::RuleUnnamednamespacedefinition;//688
}

void CPP14Parser::UnnamednamespacedefinitionContext::copyFrom(UnnamednamespacedefinitionContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::UnnamednamespacedefinitionContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<UnnamednamespacedefinitionContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::UnnamednamespacedefinitionContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::UnnamednamespacedefinitionContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::UnnamednamespacedefinitionContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitUnnamednamespacedefinition(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::UnnamednamespacedefinitionContext* CPP14Parser::unnamednamespacedefinition( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<UnnamednamespacedefinitionContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 196, CPP14Parser::RuleUnnamednamespacedefinition);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1487);//788
		_errHandler->sync(this, ctx);

		_la = _input->LA(1);
		if (_la == CPP14Parser::Inline)
		{
			setState(1486);//958
			match(CPP14Parser::Inline,ctx);
		}
		setState(1489);//958
		match(CPP14Parser::Namespace,ctx);
		setState(1490);//958
		match(CPP14Parser::LeftBrace,ctx);
		setState(1491); //951
		namespacebody(ctx);
		setState(1492);//958
		match(CPP14Parser::RightBrace,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::UnnamednamespacedefinitionContext> CPP14Parser::parseunnamednamespacedefinition()
{
	unnamednamespacedefinition();
	auto result = std::unique_ptr<UnnamednamespacedefinitionContext>(dynamic_cast<UnnamednamespacedefinitionContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- NamespacebodyContext ------------------------------------------------------------------

CPP14Parser::NamespacebodyContext::NamespacebodyContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::DeclarationseqContext* CPP14Parser::NamespacebodyContext::declarationseq()
{
	return getRuleContext<CPP14Parser::DeclarationseqContext>(0);//1165
}


size_t CPP14Parser::NamespacebodyContext::getRuleIndex() const
{
	return CPP14Parser::RuleNamespacebody;//688
}

void CPP14Parser::NamespacebodyContext::copyFrom(NamespacebodyContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::NamespacebodyContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<NamespacebodyContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::NamespacebodyContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::NamespacebodyContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::NamespacebodyContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitNamespacebody(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::NamespacebodyContext* CPP14Parser::namespacebody( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<NamespacebodyContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 198, CPP14Parser::RuleNamespacebody);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1495);//848
		_errHandler->sync(this, ctx);

		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 147, ctx))
		{
		case 1:
		{
			setState(1494); //951
			declarationseq(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::NamespacebodyContext> CPP14Parser::parsenamespacebody()
{
	namespacebody();
	auto result = std::unique_ptr<NamespacebodyContext>(dynamic_cast<NamespacebodyContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- NamespacealiasContext ------------------------------------------------------------------

CPP14Parser::NamespacealiasContext::NamespacealiasContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::NamespacealiasContext::Identifier()
{
	return getToken(CPP14Parser::Identifier, 0);
}


size_t CPP14Parser::NamespacealiasContext::getRuleIndex() const
{
	return CPP14Parser::RuleNamespacealias;//688
}

void CPP14Parser::NamespacealiasContext::copyFrom(NamespacealiasContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::NamespacealiasContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<NamespacealiasContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::NamespacealiasContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::NamespacealiasContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::NamespacealiasContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitNamespacealias(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::NamespacealiasContext* CPP14Parser::namespacealias( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<NamespacealiasContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 200, CPP14Parser::RuleNamespacealias);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1497);//958
		match(CPP14Parser::Identifier,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::NamespacealiasContext> CPP14Parser::parsenamespacealias()
{
	namespacealias();
	auto result = std::unique_ptr<NamespacealiasContext>(dynamic_cast<NamespacealiasContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- NamespacealiasdefinitionContext ------------------------------------------------------------------

CPP14Parser::NamespacealiasdefinitionContext::NamespacealiasdefinitionContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::NamespacealiasdefinitionContext::Namespace()
{
	return getToken(CPP14Parser::Namespace, 0);
}

tree::TerminalNode* CPP14Parser::NamespacealiasdefinitionContext::Identifier()
{
	return getToken(CPP14Parser::Identifier, 0);
}

tree::TerminalNode* CPP14Parser::NamespacealiasdefinitionContext::Assign()
{
	return getToken(CPP14Parser::Assign, 0);
}

CPP14Parser::QualifiednamespacespecifierContext* CPP14Parser::NamespacealiasdefinitionContext::qualifiednamespacespecifier()
{
	return getRuleContext<CPP14Parser::QualifiednamespacespecifierContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::NamespacealiasdefinitionContext::Semi()
{
	return getToken(CPP14Parser::Semi, 0);
}


size_t CPP14Parser::NamespacealiasdefinitionContext::getRuleIndex() const
{
	return CPP14Parser::RuleNamespacealiasdefinition;//688
}

void CPP14Parser::NamespacealiasdefinitionContext::copyFrom(NamespacealiasdefinitionContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::NamespacealiasdefinitionContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<NamespacealiasdefinitionContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::NamespacealiasdefinitionContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::NamespacealiasdefinitionContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::NamespacealiasdefinitionContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitNamespacealiasdefinition(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::NamespacealiasdefinitionContext* CPP14Parser::namespacealiasdefinition( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<NamespacealiasdefinitionContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 202, CPP14Parser::RuleNamespacealiasdefinition);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1499);//958
		match(CPP14Parser::Namespace,ctx);
		setState(1500);//958
		match(CPP14Parser::Identifier,ctx);
		setState(1501);//958
		match(CPP14Parser::Assign,ctx);
		setState(1502); //951
		qualifiednamespacespecifier(ctx);
		setState(1503);//958
		match(CPP14Parser::Semi,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::NamespacealiasdefinitionContext> CPP14Parser::parsenamespacealiasdefinition()
{
	namespacealiasdefinition();
	auto result = std::unique_ptr<NamespacealiasdefinitionContext>(dynamic_cast<NamespacealiasdefinitionContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- QualifiednamespacespecifierContext ------------------------------------------------------------------

CPP14Parser::QualifiednamespacespecifierContext::QualifiednamespacespecifierContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::NamespacenameContext* CPP14Parser::QualifiednamespacespecifierContext::namespacename()
{
	return getRuleContext<CPP14Parser::NamespacenameContext>(0);//1165
}

CPP14Parser::NestednamespecifierContext* CPP14Parser::QualifiednamespacespecifierContext::nestednamespecifier()
{
	return getRuleContext<CPP14Parser::NestednamespecifierContext>(0);//1165
}


size_t CPP14Parser::QualifiednamespacespecifierContext::getRuleIndex() const
{
	return CPP14Parser::RuleQualifiednamespacespecifier;//688
}

void CPP14Parser::QualifiednamespacespecifierContext::copyFrom(QualifiednamespacespecifierContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::QualifiednamespacespecifierContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<QualifiednamespacespecifierContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::QualifiednamespacespecifierContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::QualifiednamespacespecifierContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::QualifiednamespacespecifierContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitQualifiednamespacespecifier(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::QualifiednamespacespecifierContext* CPP14Parser::qualifiednamespacespecifier( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<QualifiednamespacespecifierContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 204, CPP14Parser::RuleQualifiednamespacespecifier);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1506);//848
		_errHandler->sync(this, ctx);

		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 148, ctx))
		{
		case 1:
		{
			setState(1505); //951
			nestednamespecifier(0,ctx);
			break;
		}

		}
		setState(1508); //951
		namespacename(ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::QualifiednamespacespecifierContext> CPP14Parser::parsequalifiednamespacespecifier()
{
	qualifiednamespacespecifier();
	auto result = std::unique_ptr<QualifiednamespacespecifierContext>(dynamic_cast<QualifiednamespacespecifierContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- UsingdeclarationContext ------------------------------------------------------------------

CPP14Parser::UsingdeclarationContext::UsingdeclarationContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::UsingdeclarationContext::Using()
{
	return getToken(CPP14Parser::Using, 0);
}

CPP14Parser::NestednamespecifierContext* CPP14Parser::UsingdeclarationContext::nestednamespecifier()
{
	return getRuleContext<CPP14Parser::NestednamespecifierContext>(0);//1165
}

CPP14Parser::UnqualifiedidContext* CPP14Parser::UsingdeclarationContext::unqualifiedid()
{
	return getRuleContext<CPP14Parser::UnqualifiedidContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::UsingdeclarationContext::Semi()
{
	return getToken(CPP14Parser::Semi, 0);
}

tree::TerminalNode* CPP14Parser::UsingdeclarationContext::Typename_()
{
	return getToken(CPP14Parser::Typename_, 0);
}

tree::TerminalNode* CPP14Parser::UsingdeclarationContext::Doublecolon()
{
	return getToken(CPP14Parser::Doublecolon, 0);
}


size_t CPP14Parser::UsingdeclarationContext::getRuleIndex() const
{
	return CPP14Parser::RuleUsingdeclaration;//688
}

void CPP14Parser::UsingdeclarationContext::copyFrom(UsingdeclarationContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::UsingdeclarationContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<UsingdeclarationContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::UsingdeclarationContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::UsingdeclarationContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::UsingdeclarationContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitUsingdeclaration(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::UsingdeclarationContext* CPP14Parser::usingdeclaration( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<UsingdeclarationContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 206, CPP14Parser::RuleUsingdeclaration);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1523);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 150, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(1510);//958
			match(CPP14Parser::Using,ctx);
			setState(1512);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Typename_)
			{
				setState(1511);//958
				match(CPP14Parser::Typename_,ctx);
			}
			setState(1514); //951
			nestednamespecifier(0,ctx);
			setState(1515); //951
			unqualifiedid(ctx);
			setState(1516);//958
			match(CPP14Parser::Semi,ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(1518);//958
			match(CPP14Parser::Using,ctx);
			setState(1519);//958
			match(CPP14Parser::Doublecolon,ctx);
			setState(1520); //951
			unqualifiedid(ctx);
			setState(1521);//958
			match(CPP14Parser::Semi,ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::UsingdeclarationContext> CPP14Parser::parseusingdeclaration()
{
	usingdeclaration();
	auto result = std::unique_ptr<UsingdeclarationContext>(dynamic_cast<UsingdeclarationContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- UsingdirectiveContext ------------------------------------------------------------------

CPP14Parser::UsingdirectiveContext::UsingdirectiveContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::UsingdirectiveContext::Using()
{
	return getToken(CPP14Parser::Using, 0);
}

tree::TerminalNode* CPP14Parser::UsingdirectiveContext::Namespace()
{
	return getToken(CPP14Parser::Namespace, 0);
}

CPP14Parser::NamespacenameContext* CPP14Parser::UsingdirectiveContext::namespacename()
{
	return getRuleContext<CPP14Parser::NamespacenameContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::UsingdirectiveContext::Semi()
{
	return getToken(CPP14Parser::Semi, 0);
}

CPP14Parser::AttributespecifierseqContext* CPP14Parser::UsingdirectiveContext::attributespecifierseq()
{
	return getRuleContext<CPP14Parser::AttributespecifierseqContext>(0);//1165
}

CPP14Parser::NestednamespecifierContext* CPP14Parser::UsingdirectiveContext::nestednamespecifier()
{
	return getRuleContext<CPP14Parser::NestednamespecifierContext>(0);//1165
}


size_t CPP14Parser::UsingdirectiveContext::getRuleIndex() const
{
	return CPP14Parser::RuleUsingdirective;//688
}

void CPP14Parser::UsingdirectiveContext::copyFrom(UsingdirectiveContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::UsingdirectiveContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<UsingdirectiveContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::UsingdirectiveContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::UsingdirectiveContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::UsingdirectiveContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitUsingdirective(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::UsingdirectiveContext* CPP14Parser::usingdirective( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<UsingdirectiveContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 208, CPP14Parser::RuleUsingdirective);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1526);//788
		_errHandler->sync(this, ctx);

		_la = _input->LA(1);
		if (_la == CPP14Parser::Alignas || _la == CPP14Parser::LeftBracket)
		{
			setState(1525); //951
			attributespecifierseq(0,ctx);
		}
		setState(1528);//958
		match(CPP14Parser::Using,ctx);
		setState(1529);//958
		match(CPP14Parser::Namespace,ctx);
		setState(1531);//848
		_errHandler->sync(this, ctx);

		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 152, ctx))
		{
		case 1:
		{
			setState(1530); //951
			nestednamespecifier(0,ctx);
			break;
		}

		}
		setState(1533); //951
		namespacename(ctx);
		setState(1534);//958
		match(CPP14Parser::Semi,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::UsingdirectiveContext> CPP14Parser::parseusingdirective()
{
	usingdirective();
	auto result = std::unique_ptr<UsingdirectiveContext>(dynamic_cast<UsingdirectiveContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- AsmdefinitionContext ------------------------------------------------------------------

CPP14Parser::AsmdefinitionContext::AsmdefinitionContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::AsmdefinitionContext::Asm()
{
	return getToken(CPP14Parser::Asm, 0);
}

tree::TerminalNode* CPP14Parser::AsmdefinitionContext::LeftParen()
{
	return getToken(CPP14Parser::LeftParen, 0);
}

tree::TerminalNode* CPP14Parser::AsmdefinitionContext::Stringliteral()
{
	return getToken(CPP14Parser::Stringliteral, 0);
}

tree::TerminalNode* CPP14Parser::AsmdefinitionContext::RightParen()
{
	return getToken(CPP14Parser::RightParen, 0);
}

tree::TerminalNode* CPP14Parser::AsmdefinitionContext::Semi()
{
	return getToken(CPP14Parser::Semi, 0);
}


size_t CPP14Parser::AsmdefinitionContext::getRuleIndex() const
{
	return CPP14Parser::RuleAsmdefinition;//688
}

void CPP14Parser::AsmdefinitionContext::copyFrom(AsmdefinitionContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::AsmdefinitionContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<AsmdefinitionContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::AsmdefinitionContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::AsmdefinitionContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::AsmdefinitionContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitAsmdefinition(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::AsmdefinitionContext* CPP14Parser::asmdefinition( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<AsmdefinitionContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 210, CPP14Parser::RuleAsmdefinition);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1536);//958
		match(CPP14Parser::Asm,ctx);
		setState(1537);//958
		match(CPP14Parser::LeftParen,ctx);
		setState(1538);//958
		match(CPP14Parser::Stringliteral,ctx);
		setState(1539);//958
		match(CPP14Parser::RightParen,ctx);
		setState(1540);//958
		match(CPP14Parser::Semi,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::AsmdefinitionContext> CPP14Parser::parseasmdefinition()
{
	asmdefinition();
	auto result = std::unique_ptr<AsmdefinitionContext>(dynamic_cast<AsmdefinitionContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- LinkagespecificationContext ------------------------------------------------------------------

CPP14Parser::LinkagespecificationContext::LinkagespecificationContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::LinkagespecificationContext::Extern()
{
	return getToken(CPP14Parser::Extern, 0);
}

tree::TerminalNode* CPP14Parser::LinkagespecificationContext::Stringliteral()
{
	return getToken(CPP14Parser::Stringliteral, 0);
}

tree::TerminalNode* CPP14Parser::LinkagespecificationContext::LeftBrace()
{
	return getToken(CPP14Parser::LeftBrace, 0);
}

tree::TerminalNode* CPP14Parser::LinkagespecificationContext::RightBrace()
{
	return getToken(CPP14Parser::RightBrace, 0);
}

CPP14Parser::DeclarationseqContext* CPP14Parser::LinkagespecificationContext::declarationseq()
{
	return getRuleContext<CPP14Parser::DeclarationseqContext>(0);//1165
}

CPP14Parser::DeclarationContext* CPP14Parser::LinkagespecificationContext::declaration()
{
	return getRuleContext<CPP14Parser::DeclarationContext>(0);//1165
}


size_t CPP14Parser::LinkagespecificationContext::getRuleIndex() const
{
	return CPP14Parser::RuleLinkagespecification;//688
}

void CPP14Parser::LinkagespecificationContext::copyFrom(LinkagespecificationContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::LinkagespecificationContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<LinkagespecificationContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::LinkagespecificationContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::LinkagespecificationContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::LinkagespecificationContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitLinkagespecification(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::LinkagespecificationContext* CPP14Parser::linkagespecification( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<LinkagespecificationContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 212, CPP14Parser::RuleLinkagespecification);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1552);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 154, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(1542);//958
			match(CPP14Parser::Extern,ctx);
			setState(1543);//958
			match(CPP14Parser::Stringliteral,ctx);
			setState(1544);//958
			match(CPP14Parser::LeftBrace,ctx);
			setState(1546);//848
			_errHandler->sync(this, ctx);

			switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 153, ctx))
			{
			case 1:
			{
				setState(1545); //951
				declarationseq(ctx);
				break;
			}

			}
			setState(1548);//958
			match(CPP14Parser::RightBrace,ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(1549);//958
			match(CPP14Parser::Extern,ctx);
			setState(1550);//958
			match(CPP14Parser::Stringliteral,ctx);
			setState(1551); //951
			declaration(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::LinkagespecificationContext> CPP14Parser::parselinkagespecification()
{
	linkagespecification();
	auto result = std::unique_ptr<LinkagespecificationContext>(dynamic_cast<LinkagespecificationContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- AttributespecifierseqContext ------------------------------------------------------------------

CPP14Parser::AttributespecifierseqContext::AttributespecifierseqContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::AttributespecifierContext* CPP14Parser::AttributespecifierseqContext::attributespecifier()
{
	return getRuleContext<CPP14Parser::AttributespecifierContext>(0);//1165
}

CPP14Parser::AttributespecifierseqContext* CPP14Parser::AttributespecifierseqContext::attributespecifierseq()
{
	return getRuleContext<CPP14Parser::AttributespecifierseqContext>(0);//1165
}


size_t CPP14Parser::AttributespecifierseqContext::getRuleIndex() const
{
	return CPP14Parser::RuleAttributespecifierseq;//688
}

void CPP14Parser::AttributespecifierseqContext::copyFrom(AttributespecifierseqContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::AttributespecifierseqContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<AttributespecifierseqContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::AttributespecifierseqContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::AttributespecifierseqContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::AttributespecifierseqContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitAttributespecifierseq(this);
	else
		return visitor->visitChildren(this);
}


CPP14Parser::AttributespecifierseqContext* CPP14Parser::attributespecifierseq()
{
	 return attributespecifierseq(0, nullptr);//600
}

CPP14Parser::AttributespecifierseqContext* CPP14Parser::attributespecifierseq(int precedence, antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	antlr4::ParserRuleContext *parentContext = parent;
	size_t parentState = getState();
	auto _localctx = std::make_unique<AttributespecifierseqContext>(parentContext, parentState);//610
	auto ctx = _localctx.get();//609
	size_t startState = 214;
	enterRecursionRule(ctx, 214, CPP14Parser::RuleAttributespecifierseq, precedence);

		

	auto onExit = finally([=,&_localctx]
{
		unrollRecursionContexts(parentContext, std::move(_localctx));
	});
	try
{
		size_t alt;
		enterOuterAlt(ctx, 1);
		setState(1555); //951
		attributespecifier(ctx);
		ctx->stop = _input->LT(-1);
		setState(1561);//865
		_errHandler->sync(this, ctx);
		alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 155, ctx);
		while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
		{
			if (alt == 1)
		{
				if (!_parseListeners.empty())
					triggerExitRuleEvent(ctx);

				auto tmpContext = std::make_unique<AttributespecifierseqContext>(parentContext, parentState);
				pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleAttributespecifierseq);//1240
				_localctx = std::move(tmpContext);
				ctx = _localctx.get();
				setState(1557);//1002

				if (!(precpred(nullptr, 1))) throw FailedPredicateException(this, "precpred(nullptr, 1)", ctx);
				setState(1558); //951
				attributespecifier(ctx); 
			}
			setState(1563);//875
			_errHandler->sync(this, ctx);
			alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 155, ctx);
		}
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		_localctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}
	onExit();
	return ctx;
}

std::unique_ptr< CPP14Parser::AttributespecifierseqContext> CPP14Parser::parseattributespecifierseq()
{
	attributespecifierseq();
	auto result = std::unique_ptr<AttributespecifierseqContext>(dynamic_cast<AttributespecifierseqContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}

//----------------- AttributespecifierContext ------------------------------------------------------------------

CPP14Parser::AttributespecifierContext::AttributespecifierContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

std::vector<tree::TerminalNode *> CPP14Parser::AttributespecifierContext::LeftBracket()
{
	return getTokens(CPP14Parser::LeftBracket);
}

tree::TerminalNode* CPP14Parser::AttributespecifierContext::LeftBracket(size_t i)
{
	return getToken(CPP14Parser::LeftBracket, i);
}

CPP14Parser::AttributelistContext* CPP14Parser::AttributespecifierContext::attributelist()
{
	return getRuleContext<CPP14Parser::AttributelistContext>(0);//1165
}

std::vector<tree::TerminalNode *> CPP14Parser::AttributespecifierContext::RightBracket()
{
	return getTokens(CPP14Parser::RightBracket);
}

tree::TerminalNode* CPP14Parser::AttributespecifierContext::RightBracket(size_t i)
{
	return getToken(CPP14Parser::RightBracket, i);
}

CPP14Parser::AlignmentspecifierContext* CPP14Parser::AttributespecifierContext::alignmentspecifier()
{
	return getRuleContext<CPP14Parser::AlignmentspecifierContext>(0);//1165
}


size_t CPP14Parser::AttributespecifierContext::getRuleIndex() const
{
	return CPP14Parser::RuleAttributespecifier;//688
}

void CPP14Parser::AttributespecifierContext::copyFrom(AttributespecifierContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::AttributespecifierContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<AttributespecifierContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::AttributespecifierContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::AttributespecifierContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::AttributespecifierContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitAttributespecifier(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::AttributespecifierContext* CPP14Parser::attributespecifier( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<AttributespecifierContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 216, CPP14Parser::RuleAttributespecifier);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1571);//750
		_errHandler->sync(this, ctx);
		switch (_input->LA(1))
		{
			case CPP14Parser::LeftBracket:
			{
				enterOuterAlt(ctx, 1);
				setState(1564);//958
				match(CPP14Parser::LeftBracket,ctx);
				setState(1565);//958
				match(CPP14Parser::LeftBracket,ctx);
				setState(1566); //951
				attributelist(0,ctx);
				setState(1567);//958
				match(CPP14Parser::RightBracket,ctx);
				setState(1568);//958
				match(CPP14Parser::RightBracket,ctx);
				break;
			}

			case CPP14Parser::Alignas:
			{
				enterOuterAlt(ctx, 2);
				setState(1570); //951
				alignmentspecifier(ctx);
				break;
			}

		default:
			throw NoViableAltException(this, ctx);
		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::AttributespecifierContext> CPP14Parser::parseattributespecifier()
{
	attributespecifier();
	auto result = std::unique_ptr<AttributespecifierContext>(dynamic_cast<AttributespecifierContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- AlignmentspecifierContext ------------------------------------------------------------------

CPP14Parser::AlignmentspecifierContext::AlignmentspecifierContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::AlignmentspecifierContext::Alignas()
{
	return getToken(CPP14Parser::Alignas, 0);
}

tree::TerminalNode* CPP14Parser::AlignmentspecifierContext::LeftParen()
{
	return getToken(CPP14Parser::LeftParen, 0);
}

CPP14Parser::ThetypeidContext* CPP14Parser::AlignmentspecifierContext::thetypeid()
{
	return getRuleContext<CPP14Parser::ThetypeidContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::AlignmentspecifierContext::RightParen()
{
	return getToken(CPP14Parser::RightParen, 0);
}

tree::TerminalNode* CPP14Parser::AlignmentspecifierContext::Ellipsis()
{
	return getToken(CPP14Parser::Ellipsis, 0);
}

CPP14Parser::ConstantexpressionContext* CPP14Parser::AlignmentspecifierContext::constantexpression()
{
	return getRuleContext<CPP14Parser::ConstantexpressionContext>(0);//1165
}


size_t CPP14Parser::AlignmentspecifierContext::getRuleIndex() const
{
	return CPP14Parser::RuleAlignmentspecifier;//688
}

void CPP14Parser::AlignmentspecifierContext::copyFrom(AlignmentspecifierContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::AlignmentspecifierContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<AlignmentspecifierContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::AlignmentspecifierContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::AlignmentspecifierContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::AlignmentspecifierContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitAlignmentspecifier(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::AlignmentspecifierContext* CPP14Parser::alignmentspecifier( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<AlignmentspecifierContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 218, CPP14Parser::RuleAlignmentspecifier);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1589);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 159, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(1573);//958
			match(CPP14Parser::Alignas,ctx);
			setState(1574);//958
			match(CPP14Parser::LeftParen,ctx);
			setState(1575); //951
			thetypeid(ctx);
			setState(1577);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Ellipsis)
			{
				setState(1576);//958
				match(CPP14Parser::Ellipsis,ctx);
			}
			setState(1579);//958
			match(CPP14Parser::RightParen,ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(1581);//958
			match(CPP14Parser::Alignas,ctx);
			setState(1582);//958
			match(CPP14Parser::LeftParen,ctx);
			setState(1583); //951
			constantexpression(ctx);
			setState(1585);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Ellipsis)
			{
				setState(1584);//958
				match(CPP14Parser::Ellipsis,ctx);
			}
			setState(1587);//958
			match(CPP14Parser::RightParen,ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::AlignmentspecifierContext> CPP14Parser::parsealignmentspecifier()
{
	alignmentspecifier();
	auto result = std::unique_ptr<AlignmentspecifierContext>(dynamic_cast<AlignmentspecifierContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- AttributelistContext ------------------------------------------------------------------

CPP14Parser::AttributelistContext::AttributelistContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::AttributeContext* CPP14Parser::AttributelistContext::attribute()
{
	return getRuleContext<CPP14Parser::AttributeContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::AttributelistContext::Ellipsis()
{
	return getToken(CPP14Parser::Ellipsis, 0);
}

CPP14Parser::AttributelistContext* CPP14Parser::AttributelistContext::attributelist()
{
	return getRuleContext<CPP14Parser::AttributelistContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::AttributelistContext::Comma()
{
	return getToken(CPP14Parser::Comma, 0);
}


size_t CPP14Parser::AttributelistContext::getRuleIndex() const
{
	return CPP14Parser::RuleAttributelist;//688
}

void CPP14Parser::AttributelistContext::copyFrom(AttributelistContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::AttributelistContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<AttributelistContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::AttributelistContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::AttributelistContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::AttributelistContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitAttributelist(this);
	else
		return visitor->visitChildren(this);
}


CPP14Parser::AttributelistContext* CPP14Parser::attributelist()
{
	 return attributelist(0, nullptr);//600
}

CPP14Parser::AttributelistContext* CPP14Parser::attributelist(int precedence, antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	antlr4::ParserRuleContext *parentContext = parent;
	size_t parentState = getState();
	auto _localctx = std::make_unique<AttributelistContext>(parentContext, parentState);//610
	auto ctx = _localctx.get();//609
	size_t startState = 220;
	enterRecursionRule(ctx, 220, CPP14Parser::RuleAttributelist, precedence);

		

	auto onExit = finally([=,&_localctx]
{
		unrollRecursionContexts(parentContext, std::move(_localctx));
	});
	try
{
		size_t alt;
		enterOuterAlt(ctx, 1);
		setState(1598);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 161, ctx))
		{
		case 1:
		{
			setState(1593);//848
			_errHandler->sync(this, ctx);

			switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 160, ctx))
			{
			case 1:
			{
				setState(1592); //951
				attribute(ctx);
				break;
			}

			}
			break;
		}

		case 2:
		{
			setState(1595); //951
			attribute(ctx);
			setState(1596);//958
			match(CPP14Parser::Ellipsis,ctx);
			break;
		}

		}
		ctx->stop = _input->LT(-1);
		setState(1612);//865
		_errHandler->sync(this, ctx);
		alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 164, ctx);
		while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
		{
			if (alt == 1)
		{
				if (!_parseListeners.empty())
					triggerExitRuleEvent(ctx);

				setState(1610);//830
				_errHandler->sync(this, ctx);
				switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 163, ctx))
				{
				case 1:
				{
					auto tmpContext = std::make_unique<AttributelistContext>(parentContext, parentState);
					pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleAttributelist);//1240
					_localctx = std::move(tmpContext);
					ctx = _localctx.get();
					setState(1600);//1002

					if (!(precpred(nullptr, 3))) throw FailedPredicateException(this, "precpred(nullptr, 3)", ctx);
					setState(1601);//958
					match(CPP14Parser::Comma,ctx);
					setState(1603);//848
					_errHandler->sync(this, ctx);

					switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 162, ctx))
					{
					case 1:
					{
						setState(1602); //951
						attribute(ctx);
						break;
					}

					}
					break;
				}

				case 2:
				{
					auto tmpContext = std::make_unique<AttributelistContext>(parentContext, parentState);
					pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleAttributelist);//1240
					_localctx = std::move(tmpContext);
					ctx = _localctx.get();
					setState(1605);//1002

					if (!(precpred(nullptr, 1))) throw FailedPredicateException(this, "precpred(nullptr, 1)", ctx);
					setState(1606);//958
					match(CPP14Parser::Comma,ctx);
					setState(1607); //951
					attribute(ctx);
					setState(1608);//958
					match(CPP14Parser::Ellipsis,ctx);
					break;
				}

				} 
			}
			setState(1614);//875
			_errHandler->sync(this, ctx);
			alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 164, ctx);
		}
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		_localctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}
	onExit();
	return ctx;
}

std::unique_ptr< CPP14Parser::AttributelistContext> CPP14Parser::parseattributelist()
{
	attributelist();
	auto result = std::unique_ptr<AttributelistContext>(dynamic_cast<AttributelistContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}

//----------------- AttributeContext ------------------------------------------------------------------

CPP14Parser::AttributeContext::AttributeContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::AttributetokenContext* CPP14Parser::AttributeContext::attributetoken()
{
	return getRuleContext<CPP14Parser::AttributetokenContext>(0);//1165
}

CPP14Parser::AttributeargumentclauseContext* CPP14Parser::AttributeContext::attributeargumentclause()
{
	return getRuleContext<CPP14Parser::AttributeargumentclauseContext>(0);//1165
}


size_t CPP14Parser::AttributeContext::getRuleIndex() const
{
	return CPP14Parser::RuleAttribute;//688
}

void CPP14Parser::AttributeContext::copyFrom(AttributeContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::AttributeContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<AttributeContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::AttributeContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::AttributeContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::AttributeContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitAttribute(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::AttributeContext* CPP14Parser::attribute( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<AttributeContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 222, CPP14Parser::RuleAttribute);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1615); //951
		attributetoken(ctx);
		setState(1617);//848
		_errHandler->sync(this, ctx);

		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 165, ctx))
		{
		case 1:
		{
			setState(1616); //951
			attributeargumentclause(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::AttributeContext> CPP14Parser::parseattribute()
{
	attribute();
	auto result = std::unique_ptr<AttributeContext>(dynamic_cast<AttributeContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- AttributetokenContext ------------------------------------------------------------------

CPP14Parser::AttributetokenContext::AttributetokenContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::AttributetokenContext::Identifier()
{
	return getToken(CPP14Parser::Identifier, 0);
}

CPP14Parser::AttributescopedtokenContext* CPP14Parser::AttributetokenContext::attributescopedtoken()
{
	return getRuleContext<CPP14Parser::AttributescopedtokenContext>(0);//1165
}


size_t CPP14Parser::AttributetokenContext::getRuleIndex() const
{
	return CPP14Parser::RuleAttributetoken;//688
}

void CPP14Parser::AttributetokenContext::copyFrom(AttributetokenContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::AttributetokenContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<AttributetokenContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::AttributetokenContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::AttributetokenContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::AttributetokenContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitAttributetoken(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::AttributetokenContext* CPP14Parser::attributetoken( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<AttributetokenContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 224, CPP14Parser::RuleAttributetoken);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1621);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 166, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(1619);//958
			match(CPP14Parser::Identifier,ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(1620); //951
			attributescopedtoken(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::AttributetokenContext> CPP14Parser::parseattributetoken()
{
	attributetoken();
	auto result = std::unique_ptr<AttributetokenContext>(dynamic_cast<AttributetokenContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- AttributescopedtokenContext ------------------------------------------------------------------

CPP14Parser::AttributescopedtokenContext::AttributescopedtokenContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::AttributenamespaceContext* CPP14Parser::AttributescopedtokenContext::attributenamespace()
{
	return getRuleContext<CPP14Parser::AttributenamespaceContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::AttributescopedtokenContext::Doublecolon()
{
	return getToken(CPP14Parser::Doublecolon, 0);
}

tree::TerminalNode* CPP14Parser::AttributescopedtokenContext::Identifier()
{
	return getToken(CPP14Parser::Identifier, 0);
}


size_t CPP14Parser::AttributescopedtokenContext::getRuleIndex() const
{
	return CPP14Parser::RuleAttributescopedtoken;//688
}

void CPP14Parser::AttributescopedtokenContext::copyFrom(AttributescopedtokenContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::AttributescopedtokenContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<AttributescopedtokenContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::AttributescopedtokenContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::AttributescopedtokenContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::AttributescopedtokenContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitAttributescopedtoken(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::AttributescopedtokenContext* CPP14Parser::attributescopedtoken( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<AttributescopedtokenContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 226, CPP14Parser::RuleAttributescopedtoken);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1623); //951
		attributenamespace(ctx);
		setState(1624);//958
		match(CPP14Parser::Doublecolon,ctx);
		setState(1625);//958
		match(CPP14Parser::Identifier,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::AttributescopedtokenContext> CPP14Parser::parseattributescopedtoken()
{
	attributescopedtoken();
	auto result = std::unique_ptr<AttributescopedtokenContext>(dynamic_cast<AttributescopedtokenContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- AttributenamespaceContext ------------------------------------------------------------------

CPP14Parser::AttributenamespaceContext::AttributenamespaceContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::AttributenamespaceContext::Identifier()
{
	return getToken(CPP14Parser::Identifier, 0);
}


size_t CPP14Parser::AttributenamespaceContext::getRuleIndex() const
{
	return CPP14Parser::RuleAttributenamespace;//688
}

void CPP14Parser::AttributenamespaceContext::copyFrom(AttributenamespaceContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::AttributenamespaceContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<AttributenamespaceContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::AttributenamespaceContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::AttributenamespaceContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::AttributenamespaceContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitAttributenamespace(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::AttributenamespaceContext* CPP14Parser::attributenamespace( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<AttributenamespaceContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 228, CPP14Parser::RuleAttributenamespace);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1627);//958
		match(CPP14Parser::Identifier,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::AttributenamespaceContext> CPP14Parser::parseattributenamespace()
{
	attributenamespace();
	auto result = std::unique_ptr<AttributenamespaceContext>(dynamic_cast<AttributenamespaceContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- AttributeargumentclauseContext ------------------------------------------------------------------

CPP14Parser::AttributeargumentclauseContext::AttributeargumentclauseContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::AttributeargumentclauseContext::LeftParen()
{
	return getToken(CPP14Parser::LeftParen, 0);
}

CPP14Parser::BalancedtokenseqContext* CPP14Parser::AttributeargumentclauseContext::balancedtokenseq()
{
	return getRuleContext<CPP14Parser::BalancedtokenseqContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::AttributeargumentclauseContext::RightParen()
{
	return getToken(CPP14Parser::RightParen, 0);
}


size_t CPP14Parser::AttributeargumentclauseContext::getRuleIndex() const
{
	return CPP14Parser::RuleAttributeargumentclause;//688
}

void CPP14Parser::AttributeargumentclauseContext::copyFrom(AttributeargumentclauseContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::AttributeargumentclauseContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<AttributeargumentclauseContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::AttributeargumentclauseContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::AttributeargumentclauseContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::AttributeargumentclauseContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitAttributeargumentclause(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::AttributeargumentclauseContext* CPP14Parser::attributeargumentclause( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<AttributeargumentclauseContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 230, CPP14Parser::RuleAttributeargumentclause);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1629);//958
		match(CPP14Parser::LeftParen,ctx);
		setState(1630); //951
		balancedtokenseq(0,ctx);
		setState(1631);//958
		match(CPP14Parser::RightParen,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::AttributeargumentclauseContext> CPP14Parser::parseattributeargumentclause()
{
	attributeargumentclause();
	auto result = std::unique_ptr<AttributeargumentclauseContext>(dynamic_cast<AttributeargumentclauseContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- BalancedtokenseqContext ------------------------------------------------------------------

CPP14Parser::BalancedtokenseqContext::BalancedtokenseqContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::BalancedtokenContext* CPP14Parser::BalancedtokenseqContext::balancedtoken()
{
	return getRuleContext<CPP14Parser::BalancedtokenContext>(0);//1165
}

CPP14Parser::BalancedtokenseqContext* CPP14Parser::BalancedtokenseqContext::balancedtokenseq()
{
	return getRuleContext<CPP14Parser::BalancedtokenseqContext>(0);//1165
}


size_t CPP14Parser::BalancedtokenseqContext::getRuleIndex() const
{
	return CPP14Parser::RuleBalancedtokenseq;//688
}

void CPP14Parser::BalancedtokenseqContext::copyFrom(BalancedtokenseqContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::BalancedtokenseqContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<BalancedtokenseqContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::BalancedtokenseqContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::BalancedtokenseqContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::BalancedtokenseqContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitBalancedtokenseq(this);
	else
		return visitor->visitChildren(this);
}


CPP14Parser::BalancedtokenseqContext* CPP14Parser::balancedtokenseq()
{
	 return balancedtokenseq(0, nullptr);//600
}

CPP14Parser::BalancedtokenseqContext* CPP14Parser::balancedtokenseq(int precedence, antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	antlr4::ParserRuleContext *parentContext = parent;
	size_t parentState = getState();
	auto _localctx = std::make_unique<BalancedtokenseqContext>(parentContext, parentState);//610
	auto ctx = _localctx.get();//609
	size_t startState = 232;
	enterRecursionRule(ctx, 232, CPP14Parser::RuleBalancedtokenseq, precedence);

		

	auto onExit = finally([=,&_localctx]
{
		unrollRecursionContexts(parentContext, std::move(_localctx));
	});
	try
{
		size_t alt;
		enterOuterAlt(ctx, 1);
		setState(1635);//848
		_errHandler->sync(this, ctx);

		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 167, ctx))
		{
		case 1:
		{
			setState(1634); //951
			balancedtoken(ctx);
			break;
		}

		}
		ctx->stop = _input->LT(-1);
		setState(1641);//865
		_errHandler->sync(this, ctx);
		alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 168, ctx);
		while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
		{
			if (alt == 1)
		{
				if (!_parseListeners.empty())
					triggerExitRuleEvent(ctx);

				auto tmpContext = std::make_unique<BalancedtokenseqContext>(parentContext, parentState);
				pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleBalancedtokenseq);//1240
				_localctx = std::move(tmpContext);
				ctx = _localctx.get();
				setState(1637);//1002

				if (!(precpred(nullptr, 1))) throw FailedPredicateException(this, "precpred(nullptr, 1)", ctx);
				setState(1638); //951
				balancedtoken(ctx); 
			}
			setState(1643);//875
			_errHandler->sync(this, ctx);
			alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 168, ctx);
		}
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		_localctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}
	onExit();
	return ctx;
}

std::unique_ptr< CPP14Parser::BalancedtokenseqContext> CPP14Parser::parsebalancedtokenseq()
{
	balancedtokenseq();
	auto result = std::unique_ptr<BalancedtokenseqContext>(dynamic_cast<BalancedtokenseqContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}

//----------------- BalancedtokenContext ------------------------------------------------------------------

CPP14Parser::BalancedtokenContext::BalancedtokenContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

std::vector<tree::TerminalNode *> CPP14Parser::BalancedtokenContext::LeftParen()
{
	return getTokens(CPP14Parser::LeftParen);
}

tree::TerminalNode* CPP14Parser::BalancedtokenContext::LeftParen(size_t i)
{
	return getToken(CPP14Parser::LeftParen, i);
}

CPP14Parser::BalancedtokenseqContext* CPP14Parser::BalancedtokenContext::balancedtokenseq()
{
	return getRuleContext<CPP14Parser::BalancedtokenseqContext>(0);//1165
}

std::vector<tree::TerminalNode *> CPP14Parser::BalancedtokenContext::RightParen()
{
	return getTokens(CPP14Parser::RightParen);
}

tree::TerminalNode* CPP14Parser::BalancedtokenContext::RightParen(size_t i)
{
	return getToken(CPP14Parser::RightParen, i);
}

std::vector<tree::TerminalNode *> CPP14Parser::BalancedtokenContext::LeftBracket()
{
	return getTokens(CPP14Parser::LeftBracket);
}

tree::TerminalNode* CPP14Parser::BalancedtokenContext::LeftBracket(size_t i)
{
	return getToken(CPP14Parser::LeftBracket, i);
}

std::vector<tree::TerminalNode *> CPP14Parser::BalancedtokenContext::RightBracket()
{
	return getTokens(CPP14Parser::RightBracket);
}

tree::TerminalNode* CPP14Parser::BalancedtokenContext::RightBracket(size_t i)
{
	return getToken(CPP14Parser::RightBracket, i);
}

std::vector<tree::TerminalNode *> CPP14Parser::BalancedtokenContext::LeftBrace()
{
	return getTokens(CPP14Parser::LeftBrace);
}

tree::TerminalNode* CPP14Parser::BalancedtokenContext::LeftBrace(size_t i)
{
	return getToken(CPP14Parser::LeftBrace, i);
}

std::vector<tree::TerminalNode *> CPP14Parser::BalancedtokenContext::RightBrace()
{
	return getTokens(CPP14Parser::RightBrace);
}

tree::TerminalNode* CPP14Parser::BalancedtokenContext::RightBrace(size_t i)
{
	return getToken(CPP14Parser::RightBrace, i);
}


size_t CPP14Parser::BalancedtokenContext::getRuleIndex() const
{
	return CPP14Parser::RuleBalancedtoken;//688
}

void CPP14Parser::BalancedtokenContext::copyFrom(BalancedtokenContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::BalancedtokenContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<BalancedtokenContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::BalancedtokenContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::BalancedtokenContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::BalancedtokenContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitBalancedtoken(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::BalancedtokenContext* CPP14Parser::balancedtoken( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<BalancedtokenContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 234, CPP14Parser::RuleBalancedtoken);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		size_t alt;
		setState(1661);//750
		_errHandler->sync(this, ctx);
		switch (_input->LA(1))
		{
			case CPP14Parser::LeftParen:
			{
				enterOuterAlt(ctx, 1);
				setState(1644);//958
				match(CPP14Parser::LeftParen,ctx);
				setState(1645); //951
				balancedtokenseq(0,ctx);
				setState(1646);//958
				match(CPP14Parser::RightParen,ctx);
				break;
			}

			case CPP14Parser::LeftBracket:
			{
				enterOuterAlt(ctx, 2);
				setState(1648);//958
				match(CPP14Parser::LeftBracket,ctx);
				setState(1649); //951
				balancedtokenseq(0,ctx);
				setState(1650);//958
				match(CPP14Parser::RightBracket,ctx);
				break;
			}

			case CPP14Parser::LeftBrace:
			{
				enterOuterAlt(ctx, 3);
				setState(1652);//958
				match(CPP14Parser::LeftBrace,ctx);
				setState(1653); //951
				balancedtokenseq(0,ctx);
				setState(1654);//958
				match(CPP14Parser::RightBrace,ctx);
				break;
			}

			case CPP14Parser::T__0:
			case CPP14Parser::T__1:
			case CPP14Parser::T__2:
			case CPP14Parser::T__3:
			case CPP14Parser::T__4:
			case CPP14Parser::T__5:
			case CPP14Parser::MultiLineMacro:
			case CPP14Parser::Directive:
			case CPP14Parser::Alignas:
			case CPP14Parser::Alignof:
			case CPP14Parser::Asm:
			case CPP14Parser::Auto:
			case CPP14Parser::Bool:
			case CPP14Parser::Break:
			case CPP14Parser::Case:
			case CPP14Parser::Catch:
			case CPP14Parser::Char:
			case CPP14Parser::Char16:
			case CPP14Parser::Char32:
			case CPP14Parser::Class:
			case CPP14Parser::Const:
			case CPP14Parser::Constexpr:
			case CPP14Parser::Const_cast:
			case CPP14Parser::Continue:
			case CPP14Parser::Decltype:
			case CPP14Parser::Default:
			case CPP14Parser::Delete:
			case CPP14Parser::Do:
			case CPP14Parser::Double:
			case CPP14Parser::Dynamic_cast:
			case CPP14Parser::Else:
			case CPP14Parser::Enum:
			case CPP14Parser::Explicit:
			case CPP14Parser::Export:
			case CPP14Parser::Extern:
			case CPP14Parser::False:
			case CPP14Parser::Final:
			case CPP14Parser::Float:
			case CPP14Parser::For:
			case CPP14Parser::Friend:
			case CPP14Parser::Goto:
			case CPP14Parser::If:
			case CPP14Parser::Inline:
			case CPP14Parser::Int:
			case CPP14Parser::Long:
			case CPP14Parser::Mutable:
			case CPP14Parser::Namespace:
			case CPP14Parser::New:
			case CPP14Parser::Noexcept:
			case CPP14Parser::Nullptr:
			case CPP14Parser::Operator:
			case CPP14Parser::Override:
			case CPP14Parser::Private:
			case CPP14Parser::Protected:
			case CPP14Parser::Public:
			case CPP14Parser::Register:
			case CPP14Parser::Reinterpret_cast:
			case CPP14Parser::Return:
			case CPP14Parser::Short:
			case CPP14Parser::Signed:
			case CPP14Parser::Sizeof:
			case CPP14Parser::Static:
			case CPP14Parser::Static_assert:
			case CPP14Parser::Static_cast:
			case CPP14Parser::Struct:
			case CPP14Parser::Switch:
			case CPP14Parser::Template:
			case CPP14Parser::This:
			case CPP14Parser::Thread_local:
			case CPP14Parser::Throw:
			case CPP14Parser::True:
			case CPP14Parser::Try:
			case CPP14Parser::Typedef:
			case CPP14Parser::Typeid_:
			case CPP14Parser::Typename_:
			case CPP14Parser::Union:
			case CPP14Parser::Unsigned:
			case CPP14Parser::Using:
			case CPP14Parser::Virtual:
			case CPP14Parser::Void:
			case CPP14Parser::Volatile:
			case CPP14Parser::Wchar:
			case CPP14Parser::While:
			case CPP14Parser::Plus:
			case CPP14Parser::Minus:
			case CPP14Parser::Star:
			case CPP14Parser::Div:
			case CPP14Parser::Mod:
			case CPP14Parser::Caret:
			case CPP14Parser::And:
			case CPP14Parser::Or:
			case CPP14Parser::Tilde:
			case CPP14Parser::Not:
			case CPP14Parser::Assign:
			case CPP14Parser::Less:
			case CPP14Parser::PlusAssign:
			case CPP14Parser::MinusAssign:
			case CPP14Parser::StarAssign:
			case CPP14Parser::DivAssign:
			case CPP14Parser::ModAssign:
			case CPP14Parser::XorAssign:
			case CPP14Parser::AndAssign:
			case CPP14Parser::OrAssign:
			case CPP14Parser::LeftShift:
			case CPP14Parser::LeftShiftAssign:
			case CPP14Parser::Equal:
			case CPP14Parser::NotEqual:
			case CPP14Parser::LessEqual:
			case CPP14Parser::GreaterEqual:
			case CPP14Parser::AndAnd:
			case CPP14Parser::OrOr:
			case CPP14Parser::PlusPlus:
			case CPP14Parser::MinusMinus:
			case CPP14Parser::Comma:
			case CPP14Parser::ArrowStar:
			case CPP14Parser::Arrow:
			case CPP14Parser::Question:
			case CPP14Parser::Colon:
			case CPP14Parser::Doublecolon:
			case CPP14Parser::Semi:
			case CPP14Parser::Dot:
			case CPP14Parser::DotStar:
			case CPP14Parser::Ellipsis:
			case CPP14Parser::Identifier:
			case CPP14Parser::Integerliteral:
			case CPP14Parser::Decimalliteral:
			case CPP14Parser::Octalliteral:
			case CPP14Parser::Hexadecimalliteral:
			case CPP14Parser::Binaryliteral:
			case CPP14Parser::Integersuffix:
			case CPP14Parser::Characterliteral:
			case CPP14Parser::Floatingliteral:
			case CPP14Parser::Stringliteral:
			case CPP14Parser::Userdefinedintegerliteral:
			case CPP14Parser::Userdefinedfloatingliteral:
			case CPP14Parser::Userdefinedstringliteral:
			case CPP14Parser::Userdefinedcharacterliteral:
			case CPP14Parser::Whitespace:
			case CPP14Parser::Newline:
			case CPP14Parser::BlockComment:
			case CPP14Parser::LineComment:
			case CPP14Parser::GreaterThan:
			{
				enterOuterAlt(ctx, 4);
				setState(1657); //883
				_errHandler->sync(this, ctx);
				alt = 1;
				do
				{
					switch (alt)
				{
						case 1:
						{
									setState(1656);//970
									_la = _input->LA(1);
									if (_la == 0 || _la == Token::EOF || (((((_la - 84) & ~ 0x3fULL) == 0) &&
										((1ULL << (_la - 84)) & ((1ULL << (CPP14Parser::LeftParen - 84))
										| (1ULL << (CPP14Parser::RightParen - 84))
										| (1ULL << (CPP14Parser::LeftBracket - 84))
										| (1ULL << (CPP14Parser::RightBracket - 84))
										| (1ULL << (CPP14Parser::LeftBrace - 84))
										| (1ULL << (CPP14Parser::RightBrace - 84)))) != 0)))
									{
									_errHandler->recoverInline(this, ctx);
									}
									else
									{
										_errHandler->reportMatch(this);
										consume(ctx);
									}
									break;
								}

					default:
						throw NoViableAltException(this, ctx);
					}
					setState(1659); //900
					_errHandler->sync(this, ctx);
					alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 169, ctx);
				} while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
				break;
			}

		default:
			throw NoViableAltException(this, ctx);
		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::BalancedtokenContext> CPP14Parser::parsebalancedtoken()
{
	balancedtoken();
	auto result = std::unique_ptr<BalancedtokenContext>(dynamic_cast<BalancedtokenContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- InitdeclaratorlistContext ------------------------------------------------------------------

CPP14Parser::InitdeclaratorlistContext::InitdeclaratorlistContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::InitdeclaratorContext* CPP14Parser::InitdeclaratorlistContext::initdeclarator()
{
	return getRuleContext<CPP14Parser::InitdeclaratorContext>(0);//1165
}

CPP14Parser::InitdeclaratorlistContext* CPP14Parser::InitdeclaratorlistContext::initdeclaratorlist()
{
	return getRuleContext<CPP14Parser::InitdeclaratorlistContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::InitdeclaratorlistContext::Comma()
{
	return getToken(CPP14Parser::Comma, 0);
}


size_t CPP14Parser::InitdeclaratorlistContext::getRuleIndex() const
{
	return CPP14Parser::RuleInitdeclaratorlist;//688
}

void CPP14Parser::InitdeclaratorlistContext::copyFrom(InitdeclaratorlistContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::InitdeclaratorlistContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<InitdeclaratorlistContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::InitdeclaratorlistContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::InitdeclaratorlistContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::InitdeclaratorlistContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitInitdeclaratorlist(this);
	else
		return visitor->visitChildren(this);
}


CPP14Parser::InitdeclaratorlistContext* CPP14Parser::initdeclaratorlist()
{
	 return initdeclaratorlist(0, nullptr);//600
}

CPP14Parser::InitdeclaratorlistContext* CPP14Parser::initdeclaratorlist(int precedence, antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	antlr4::ParserRuleContext *parentContext = parent;
	size_t parentState = getState();
	auto _localctx = std::make_unique<InitdeclaratorlistContext>(parentContext, parentState);//610
	auto ctx = _localctx.get();//609
	size_t startState = 236;
	enterRecursionRule(ctx, 236, CPP14Parser::RuleInitdeclaratorlist, precedence);

		

	auto onExit = finally([=,&_localctx]
{
		unrollRecursionContexts(parentContext, std::move(_localctx));
	});
	try
{
		size_t alt;
		enterOuterAlt(ctx, 1);
		setState(1664); //951
		initdeclarator(ctx);
		ctx->stop = _input->LT(-1);
		setState(1671);//865
		_errHandler->sync(this, ctx);
		alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 171, ctx);
		while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
		{
			if (alt == 1)
		{
				if (!_parseListeners.empty())
					triggerExitRuleEvent(ctx);

				auto tmpContext = std::make_unique<InitdeclaratorlistContext>(parentContext, parentState);
				pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleInitdeclaratorlist);//1240
				_localctx = std::move(tmpContext);
				ctx = _localctx.get();
				setState(1666);//1002

				if (!(precpred(nullptr, 1))) throw FailedPredicateException(this, "precpred(nullptr, 1)", ctx);
				setState(1667);//958
				match(CPP14Parser::Comma,ctx);
				setState(1668); //951
				initdeclarator(ctx); 
			}
			setState(1673);//875
			_errHandler->sync(this, ctx);
			alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 171, ctx);
		}
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		_localctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}
	onExit();
	return ctx;
}

std::unique_ptr< CPP14Parser::InitdeclaratorlistContext> CPP14Parser::parseinitdeclaratorlist()
{
	initdeclaratorlist();
	auto result = std::unique_ptr<InitdeclaratorlistContext>(dynamic_cast<InitdeclaratorlistContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}

//----------------- InitdeclaratorContext ------------------------------------------------------------------

CPP14Parser::InitdeclaratorContext::InitdeclaratorContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::DeclaratorContext* CPP14Parser::InitdeclaratorContext::declarator()
{
	return getRuleContext<CPP14Parser::DeclaratorContext>(0);//1165
}

CPP14Parser::InitializerContext* CPP14Parser::InitdeclaratorContext::initializer()
{
	return getRuleContext<CPP14Parser::InitializerContext>(0);//1165
}


size_t CPP14Parser::InitdeclaratorContext::getRuleIndex() const
{
	return CPP14Parser::RuleInitdeclarator;//688
}

void CPP14Parser::InitdeclaratorContext::copyFrom(InitdeclaratorContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::InitdeclaratorContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<InitdeclaratorContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::InitdeclaratorContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::InitdeclaratorContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::InitdeclaratorContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitInitdeclarator(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::InitdeclaratorContext* CPP14Parser::initdeclarator( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<InitdeclaratorContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 238, CPP14Parser::RuleInitdeclarator);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1674); //951
		declarator(ctx);
		setState(1676);//848
		_errHandler->sync(this, ctx);

		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 172, ctx))
		{
		case 1:
		{
			setState(1675); //951
			initializer(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::InitdeclaratorContext> CPP14Parser::parseinitdeclarator()
{
	initdeclarator();
	auto result = std::unique_ptr<InitdeclaratorContext>(dynamic_cast<InitdeclaratorContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- DeclaratorContext ------------------------------------------------------------------

CPP14Parser::DeclaratorContext::DeclaratorContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::PtrdeclaratorContext* CPP14Parser::DeclaratorContext::ptrdeclarator()
{
	return getRuleContext<CPP14Parser::PtrdeclaratorContext>(0);//1165
}

CPP14Parser::NoptrdeclaratorContext* CPP14Parser::DeclaratorContext::noptrdeclarator()
{
	return getRuleContext<CPP14Parser::NoptrdeclaratorContext>(0);//1165
}

CPP14Parser::ParametersandqualifiersContext* CPP14Parser::DeclaratorContext::parametersandqualifiers()
{
	return getRuleContext<CPP14Parser::ParametersandqualifiersContext>(0);//1165
}

CPP14Parser::TrailingreturntypeContext* CPP14Parser::DeclaratorContext::trailingreturntype()
{
	return getRuleContext<CPP14Parser::TrailingreturntypeContext>(0);//1165
}


size_t CPP14Parser::DeclaratorContext::getRuleIndex() const
{
	return CPP14Parser::RuleDeclarator;//688
}

void CPP14Parser::DeclaratorContext::copyFrom(DeclaratorContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::DeclaratorContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<DeclaratorContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::DeclaratorContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::DeclaratorContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::DeclaratorContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitDeclarator(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::DeclaratorContext* CPP14Parser::declarator( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<DeclaratorContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 240, CPP14Parser::RuleDeclarator);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1683);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 173, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(1678); //951
			ptrdeclarator(ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(1679); //951
			noptrdeclarator(0,ctx);
			setState(1680); //951
			parametersandqualifiers(ctx);
			setState(1681); //951
			trailingreturntype(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::DeclaratorContext> CPP14Parser::parsedeclarator()
{
	declarator();
	auto result = std::unique_ptr<DeclaratorContext>(dynamic_cast<DeclaratorContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- PtrdeclaratorContext ------------------------------------------------------------------

CPP14Parser::PtrdeclaratorContext::PtrdeclaratorContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::NoptrdeclaratorContext* CPP14Parser::PtrdeclaratorContext::noptrdeclarator()
{
	return getRuleContext<CPP14Parser::NoptrdeclaratorContext>(0);//1165
}

CPP14Parser::PtroperatorContext* CPP14Parser::PtrdeclaratorContext::ptroperator()
{
	return getRuleContext<CPP14Parser::PtroperatorContext>(0);//1165
}

CPP14Parser::PtrdeclaratorContext* CPP14Parser::PtrdeclaratorContext::ptrdeclarator()
{
	return getRuleContext<CPP14Parser::PtrdeclaratorContext>(0);//1165
}


size_t CPP14Parser::PtrdeclaratorContext::getRuleIndex() const
{
	return CPP14Parser::RulePtrdeclarator;//688
}

void CPP14Parser::PtrdeclaratorContext::copyFrom(PtrdeclaratorContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::PtrdeclaratorContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<PtrdeclaratorContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::PtrdeclaratorContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::PtrdeclaratorContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::PtrdeclaratorContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitPtrdeclarator(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::PtrdeclaratorContext* CPP14Parser::ptrdeclarator( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<PtrdeclaratorContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 242, CPP14Parser::RulePtrdeclarator);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1689);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 174, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(1685); //951
			noptrdeclarator(0,ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(1686); //951
			ptroperator(ctx);
			setState(1687); //951
			ptrdeclarator(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::PtrdeclaratorContext> CPP14Parser::parseptrdeclarator()
{
	ptrdeclarator();
	auto result = std::unique_ptr<PtrdeclaratorContext>(dynamic_cast<PtrdeclaratorContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- NoptrdeclaratorContext ------------------------------------------------------------------

CPP14Parser::NoptrdeclaratorContext::NoptrdeclaratorContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::DeclaratoridContext* CPP14Parser::NoptrdeclaratorContext::declaratorid()
{
	return getRuleContext<CPP14Parser::DeclaratoridContext>(0);//1165
}

CPP14Parser::AttributespecifierseqContext* CPP14Parser::NoptrdeclaratorContext::attributespecifierseq()
{
	return getRuleContext<CPP14Parser::AttributespecifierseqContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::NoptrdeclaratorContext::LeftParen()
{
	return getToken(CPP14Parser::LeftParen, 0);
}

CPP14Parser::PtrdeclaratorContext* CPP14Parser::NoptrdeclaratorContext::ptrdeclarator()
{
	return getRuleContext<CPP14Parser::PtrdeclaratorContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::NoptrdeclaratorContext::RightParen()
{
	return getToken(CPP14Parser::RightParen, 0);
}

CPP14Parser::NoptrdeclaratorContext* CPP14Parser::NoptrdeclaratorContext::noptrdeclarator()
{
	return getRuleContext<CPP14Parser::NoptrdeclaratorContext>(0);//1165
}

CPP14Parser::ParametersandqualifiersContext* CPP14Parser::NoptrdeclaratorContext::parametersandqualifiers()
{
	return getRuleContext<CPP14Parser::ParametersandqualifiersContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::NoptrdeclaratorContext::LeftBracket()
{
	return getToken(CPP14Parser::LeftBracket, 0);
}

tree::TerminalNode* CPP14Parser::NoptrdeclaratorContext::RightBracket()
{
	return getToken(CPP14Parser::RightBracket, 0);
}

CPP14Parser::ConstantexpressionContext* CPP14Parser::NoptrdeclaratorContext::constantexpression()
{
	return getRuleContext<CPP14Parser::ConstantexpressionContext>(0);//1165
}


size_t CPP14Parser::NoptrdeclaratorContext::getRuleIndex() const
{
	return CPP14Parser::RuleNoptrdeclarator;//688
}

void CPP14Parser::NoptrdeclaratorContext::copyFrom(NoptrdeclaratorContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::NoptrdeclaratorContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<NoptrdeclaratorContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::NoptrdeclaratorContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::NoptrdeclaratorContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::NoptrdeclaratorContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitNoptrdeclarator(this);
	else
		return visitor->visitChildren(this);
}


CPP14Parser::NoptrdeclaratorContext* CPP14Parser::noptrdeclarator()
{
	 return noptrdeclarator(0, nullptr);//600
}

CPP14Parser::NoptrdeclaratorContext* CPP14Parser::noptrdeclarator(int precedence, antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	antlr4::ParserRuleContext *parentContext = parent;
	size_t parentState = getState();
	auto _localctx = std::make_unique<NoptrdeclaratorContext>(parentContext, parentState);//610
	auto ctx = _localctx.get();//609
	size_t startState = 244;
	enterRecursionRule(ctx, 244, CPP14Parser::RuleNoptrdeclarator, precedence);

		size_t _la = 0;

	auto onExit = finally([=,&_localctx]
{
		unrollRecursionContexts(parentContext, std::move(_localctx));
	});
	try
{
		size_t alt;
		enterOuterAlt(ctx, 1);
		setState(1700);//750
		_errHandler->sync(this, ctx);
		switch (_input->LA(1))
		{
			case CPP14Parser::Decltype:
			case CPP14Parser::Operator:
			case CPP14Parser::Tilde:
			case CPP14Parser::Doublecolon:
			case CPP14Parser::Ellipsis:
			case CPP14Parser::Identifier:
			{
				setState(1692); //951
				declaratorid(ctx);
				setState(1694);//848
				_errHandler->sync(this, ctx);

				switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 175, ctx))
				{
				case 1:
				{
					setState(1693); //951
					attributespecifierseq(0,ctx);
					break;
				}

				}
				break;
			}

			case CPP14Parser::LeftParen:
			{
				setState(1696);//958
				match(CPP14Parser::LeftParen,ctx);
				setState(1697); //951
				ptrdeclarator(ctx);
				setState(1698);//958
				match(CPP14Parser::RightParen,ctx);
				break;
			}

		default:
			throw NoViableAltException(this, ctx);
		}
		ctx->stop = _input->LT(-1);
		setState(1715);//865
		_errHandler->sync(this, ctx);
		alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 180, ctx);
		while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
		{
			if (alt == 1)
		{
				if (!_parseListeners.empty())
					triggerExitRuleEvent(ctx);

				setState(1713);//830
				_errHandler->sync(this, ctx);
				switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 179, ctx))
				{
				case 1:
				{
					auto tmpContext = std::make_unique<NoptrdeclaratorContext>(parentContext, parentState);
					pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleNoptrdeclarator);//1240
					_localctx = std::move(tmpContext);
					ctx = _localctx.get();
					setState(1702);//1002

					if (!(precpred(nullptr, 3))) throw FailedPredicateException(this, "precpred(nullptr, 3)", ctx);
					setState(1703); //951
					parametersandqualifiers(ctx);
					break;
				}

				case 2:
				{
					auto tmpContext = std::make_unique<NoptrdeclaratorContext>(parentContext, parentState);
					pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleNoptrdeclarator);//1240
					_localctx = std::move(tmpContext);
					ctx = _localctx.get();
					setState(1704);//1002

					if (!(precpred(nullptr, 2))) throw FailedPredicateException(this, "precpred(nullptr, 2)", ctx);
					setState(1705);//958
					match(CPP14Parser::LeftBracket,ctx);
					setState(1707);//788
					_errHandler->sync(this, ctx);

					_la = _input->LA(1);
					if ((((_la & ~ 0x3fULL) == 0) &&
						((1ULL << _la) & ((1ULL << CPP14Parser::T__0)
						| (1ULL << CPP14Parser::T__1)
						| (1ULL << CPP14Parser::Alignof)
						| (1ULL << CPP14Parser::Auto)
						| (1ULL << CPP14Parser::Bool)
						| (1ULL << CPP14Parser::Char)
						| (1ULL << CPP14Parser::Char16)
						| (1ULL << CPP14Parser::Char32)
						| (1ULL << CPP14Parser::Const_cast)
						| (1ULL << CPP14Parser::Decltype)
						| (1ULL << CPP14Parser::Delete)
						| (1ULL << CPP14Parser::Double)
						| (1ULL << CPP14Parser::Dynamic_cast)
						| (1ULL << CPP14Parser::False)
						| (1ULL << CPP14Parser::Float)
						| (1ULL << CPP14Parser::Int)
						| (1ULL << CPP14Parser::Long)
						| (1ULL << CPP14Parser::New)
						| (1ULL << CPP14Parser::Noexcept)
						| (1ULL << CPP14Parser::Nullptr)
						| (1ULL << CPP14Parser::Operator)
						| (1ULL << CPP14Parser::Reinterpret_cast)
						| (1ULL << CPP14Parser::Short)
						| (1ULL << CPP14Parser::Signed)
						| (1ULL << CPP14Parser::Sizeof))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
						((1ULL << (_la - 64)) & ((1ULL << (CPP14Parser::Static_cast - 64))
						| (1ULL << (CPP14Parser::This - 64))
						| (1ULL << (CPP14Parser::True - 64))
						| (1ULL << (CPP14Parser::Typeid_ - 64))
						| (1ULL << (CPP14Parser::Typename_ - 64))
						| (1ULL << (CPP14Parser::Unsigned - 64))
						| (1ULL << (CPP14Parser::Void - 64))
						| (1ULL << (CPP14Parser::Wchar - 64))
						| (1ULL << (CPP14Parser::LeftParen - 64))
						| (1ULL << (CPP14Parser::LeftBracket - 64))
						| (1ULL << (CPP14Parser::Plus - 64))
						| (1ULL << (CPP14Parser::Minus - 64))
						| (1ULL << (CPP14Parser::Star - 64))
						| (1ULL << (CPP14Parser::And - 64))
						| (1ULL << (CPP14Parser::Or - 64))
						| (1ULL << (CPP14Parser::Tilde - 64))
						| (1ULL << (CPP14Parser::PlusPlus - 64))
						| (1ULL << (CPP14Parser::MinusMinus - 64))
						| (1ULL << (CPP14Parser::Doublecolon - 64)))) != 0) || ((((_la - 130) & ~ 0x3fULL) == 0) &&
						((1ULL << (_la - 130)) & ((1ULL << (CPP14Parser::Identifier - 130))
						| (1ULL << (CPP14Parser::Integerliteral - 130))
						| (1ULL << (CPP14Parser::Characterliteral - 130))
						| (1ULL << (CPP14Parser::Floatingliteral - 130))
						| (1ULL << (CPP14Parser::Stringliteral - 130))
						| (1ULL << (CPP14Parser::Userdefinedintegerliteral - 130))
						| (1ULL << (CPP14Parser::Userdefinedfloatingliteral - 130))
						| (1ULL << (CPP14Parser::Userdefinedstringliteral - 130))
						| (1ULL << (CPP14Parser::Userdefinedcharacterliteral - 130)))) != 0))
					{
						setState(1706); //951
						constantexpression(ctx);
					}
					setState(1709);//958
					match(CPP14Parser::RightBracket,ctx);
					setState(1711);//848
					_errHandler->sync(this, ctx);

					switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 178, ctx))
					{
					case 1:
					{
						setState(1710); //951
						attributespecifierseq(0,ctx);
						break;
					}

					}
					break;
				}

				} 
			}
			setState(1717);//875
			_errHandler->sync(this, ctx);
			alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 180, ctx);
		}
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		_localctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}
	onExit();
	return ctx;
}

std::unique_ptr< CPP14Parser::NoptrdeclaratorContext> CPP14Parser::parsenoptrdeclarator()
{
	noptrdeclarator();
	auto result = std::unique_ptr<NoptrdeclaratorContext>(dynamic_cast<NoptrdeclaratorContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}

//----------------- ParametersandqualifiersContext ------------------------------------------------------------------

CPP14Parser::ParametersandqualifiersContext::ParametersandqualifiersContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::ParametersandqualifiersContext::LeftParen()
{
	return getToken(CPP14Parser::LeftParen, 0);
}

CPP14Parser::ParameterdeclarationclauseContext* CPP14Parser::ParametersandqualifiersContext::parameterdeclarationclause()
{
	return getRuleContext<CPP14Parser::ParameterdeclarationclauseContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::ParametersandqualifiersContext::RightParen()
{
	return getToken(CPP14Parser::RightParen, 0);
}

CPP14Parser::CvqualifierseqContext* CPP14Parser::ParametersandqualifiersContext::cvqualifierseq()
{
	return getRuleContext<CPP14Parser::CvqualifierseqContext>(0);//1165
}

CPP14Parser::RefqualifierContext* CPP14Parser::ParametersandqualifiersContext::refqualifier()
{
	return getRuleContext<CPP14Parser::RefqualifierContext>(0);//1165
}

CPP14Parser::ExceptionspecificationContext* CPP14Parser::ParametersandqualifiersContext::exceptionspecification()
{
	return getRuleContext<CPP14Parser::ExceptionspecificationContext>(0);//1165
}

CPP14Parser::AttributespecifierseqContext* CPP14Parser::ParametersandqualifiersContext::attributespecifierseq()
{
	return getRuleContext<CPP14Parser::AttributespecifierseqContext>(0);//1165
}


size_t CPP14Parser::ParametersandqualifiersContext::getRuleIndex() const
{
	return CPP14Parser::RuleParametersandqualifiers;//688
}

void CPP14Parser::ParametersandqualifiersContext::copyFrom(ParametersandqualifiersContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::ParametersandqualifiersContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<ParametersandqualifiersContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::ParametersandqualifiersContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::ParametersandqualifiersContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::ParametersandqualifiersContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitParametersandqualifiers(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::ParametersandqualifiersContext* CPP14Parser::parametersandqualifiers( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<ParametersandqualifiersContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 246, CPP14Parser::RuleParametersandqualifiers);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1718);//958
		match(CPP14Parser::LeftParen,ctx);
		setState(1719); //951
		parameterdeclarationclause(ctx);
		setState(1720);//958
		match(CPP14Parser::RightParen,ctx);
		setState(1722);//848
		_errHandler->sync(this, ctx);

		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 181, ctx))
		{
		case 1:
		{
			setState(1721); //951
			cvqualifierseq(ctx);
			break;
		}

		}
		setState(1725);//848
		_errHandler->sync(this, ctx);

		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 182, ctx))
		{
		case 1:
		{
			setState(1724); //951
			refqualifier(ctx);
			break;
		}

		}
		setState(1728);//848
		_errHandler->sync(this, ctx);

		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 183, ctx))
		{
		case 1:
		{
			setState(1727); //951
			exceptionspecification(ctx);
			break;
		}

		}
		setState(1731);//848
		_errHandler->sync(this, ctx);

		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 184, ctx))
		{
		case 1:
		{
			setState(1730); //951
			attributespecifierseq(0,ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::ParametersandqualifiersContext> CPP14Parser::parseparametersandqualifiers()
{
	parametersandqualifiers();
	auto result = std::unique_ptr<ParametersandqualifiersContext>(dynamic_cast<ParametersandqualifiersContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- TrailingreturntypeContext ------------------------------------------------------------------

CPP14Parser::TrailingreturntypeContext::TrailingreturntypeContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::TrailingreturntypeContext::Arrow()
{
	return getToken(CPP14Parser::Arrow, 0);
}

CPP14Parser::TrailingtypespecifierseqContext* CPP14Parser::TrailingreturntypeContext::trailingtypespecifierseq()
{
	return getRuleContext<CPP14Parser::TrailingtypespecifierseqContext>(0);//1165
}

CPP14Parser::AbstractdeclaratorContext* CPP14Parser::TrailingreturntypeContext::abstractdeclarator()
{
	return getRuleContext<CPP14Parser::AbstractdeclaratorContext>(0);//1165
}


size_t CPP14Parser::TrailingreturntypeContext::getRuleIndex() const
{
	return CPP14Parser::RuleTrailingreturntype;//688
}

void CPP14Parser::TrailingreturntypeContext::copyFrom(TrailingreturntypeContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::TrailingreturntypeContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<TrailingreturntypeContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::TrailingreturntypeContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::TrailingreturntypeContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::TrailingreturntypeContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitTrailingreturntype(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::TrailingreturntypeContext* CPP14Parser::trailingreturntype( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<TrailingreturntypeContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 248, CPP14Parser::RuleTrailingreturntype);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1733);//958
		match(CPP14Parser::Arrow,ctx);
		setState(1734); //951
		trailingtypespecifierseq(ctx);
		setState(1736);//848
		_errHandler->sync(this, ctx);

		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 185, ctx))
		{
		case 1:
		{
			setState(1735); //951
			abstractdeclarator(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::TrailingreturntypeContext> CPP14Parser::parsetrailingreturntype()
{
	trailingreturntype();
	auto result = std::unique_ptr<TrailingreturntypeContext>(dynamic_cast<TrailingreturntypeContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- PtroperatorContext ------------------------------------------------------------------

CPP14Parser::PtroperatorContext::PtroperatorContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::PtroperatorContext::Star()
{
	return getToken(CPP14Parser::Star, 0);
}

CPP14Parser::AttributespecifierseqContext* CPP14Parser::PtroperatorContext::attributespecifierseq()
{
	return getRuleContext<CPP14Parser::AttributespecifierseqContext>(0);//1165
}

CPP14Parser::CvqualifierseqContext* CPP14Parser::PtroperatorContext::cvqualifierseq()
{
	return getRuleContext<CPP14Parser::CvqualifierseqContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::PtroperatorContext::And()
{
	return getToken(CPP14Parser::And, 0);
}

CPP14Parser::NestednamespecifierContext* CPP14Parser::PtroperatorContext::nestednamespecifier()
{
	return getRuleContext<CPP14Parser::NestednamespecifierContext>(0);//1165
}


size_t CPP14Parser::PtroperatorContext::getRuleIndex() const
{
	return CPP14Parser::RulePtroperator;//688
}

void CPP14Parser::PtroperatorContext::copyFrom(PtroperatorContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::PtroperatorContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<PtroperatorContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::PtroperatorContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::PtroperatorContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::PtroperatorContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitPtroperator(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::PtroperatorContext* CPP14Parser::ptroperator( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<PtroperatorContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 250, CPP14Parser::RulePtroperator);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1761);//750
		_errHandler->sync(this, ctx);
		switch (_input->LA(1))
		{
			case CPP14Parser::Star:
			{
				enterOuterAlt(ctx, 1);
				setState(1738);//958
				match(CPP14Parser::Star,ctx);
				setState(1740);//848
				_errHandler->sync(this, ctx);

				switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 186, ctx))
				{
				case 1:
				{
					setState(1739); //951
					attributespecifierseq(0,ctx);
					break;
				}

				}
				setState(1743);//848
				_errHandler->sync(this, ctx);

				switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 187, ctx))
				{
				case 1:
				{
					setState(1742); //951
					cvqualifierseq(ctx);
					break;
				}

				}
				break;
			}

			case CPP14Parser::And:
			{
				enterOuterAlt(ctx, 2);
				setState(1745);//958
				match(CPP14Parser::And,ctx);
				setState(1747);//848
				_errHandler->sync(this, ctx);

				switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 188, ctx))
				{
				case 1:
				{
					setState(1746); //951
					attributespecifierseq(0,ctx);
					break;
				}

				}
				break;
			}

			case CPP14Parser::T__2:
			{
				enterOuterAlt(ctx, 3);
				setState(1749);//958
				match(CPP14Parser::T__2,ctx);
				setState(1751);//848
				_errHandler->sync(this, ctx);

				switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 189, ctx))
				{
				case 1:
				{
					setState(1750); //951
					attributespecifierseq(0,ctx);
					break;
				}

				}
				break;
			}

			case CPP14Parser::Decltype:
			case CPP14Parser::Doublecolon:
			case CPP14Parser::Identifier:
			{
				enterOuterAlt(ctx, 4);
				setState(1753); //951
				nestednamespecifier(0,ctx);
				setState(1754);//958
				match(CPP14Parser::Star,ctx);
				setState(1756);//848
				_errHandler->sync(this, ctx);

				switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 190, ctx))
				{
				case 1:
				{
					setState(1755); //951
					attributespecifierseq(0,ctx);
					break;
				}

				}
				setState(1759);//848
				_errHandler->sync(this, ctx);

				switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 191, ctx))
				{
				case 1:
				{
					setState(1758); //951
					cvqualifierseq(ctx);
					break;
				}

				}
				break;
			}

		default:
			throw NoViableAltException(this, ctx);
		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::PtroperatorContext> CPP14Parser::parseptroperator()
{
	ptroperator();
	auto result = std::unique_ptr<PtroperatorContext>(dynamic_cast<PtroperatorContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- CvqualifierseqContext ------------------------------------------------------------------

CPP14Parser::CvqualifierseqContext::CvqualifierseqContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::CvqualifierContext* CPP14Parser::CvqualifierseqContext::cvqualifier()
{
	return getRuleContext<CPP14Parser::CvqualifierContext>(0);//1165
}

CPP14Parser::CvqualifierseqContext* CPP14Parser::CvqualifierseqContext::cvqualifierseq()
{
	return getRuleContext<CPP14Parser::CvqualifierseqContext>(0);//1165
}


size_t CPP14Parser::CvqualifierseqContext::getRuleIndex() const
{
	return CPP14Parser::RuleCvqualifierseq;//688
}

void CPP14Parser::CvqualifierseqContext::copyFrom(CvqualifierseqContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::CvqualifierseqContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<CvqualifierseqContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::CvqualifierseqContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::CvqualifierseqContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::CvqualifierseqContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitCvqualifierseq(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::CvqualifierseqContext* CPP14Parser::cvqualifierseq( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<CvqualifierseqContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 252, CPP14Parser::RuleCvqualifierseq);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1763); //951
		cvqualifier(ctx);
		setState(1765);//848
		_errHandler->sync(this, ctx);

		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 193, ctx))
		{
		case 1:
		{
			setState(1764); //951
			cvqualifierseq(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::CvqualifierseqContext> CPP14Parser::parsecvqualifierseq()
{
	cvqualifierseq();
	auto result = std::unique_ptr<CvqualifierseqContext>(dynamic_cast<CvqualifierseqContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- CvqualifierContext ------------------------------------------------------------------

CPP14Parser::CvqualifierContext::CvqualifierContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::CvqualifierContext::Const()
{
	return getToken(CPP14Parser::Const, 0);
}

tree::TerminalNode* CPP14Parser::CvqualifierContext::Volatile()
{
	return getToken(CPP14Parser::Volatile, 0);
}


size_t CPP14Parser::CvqualifierContext::getRuleIndex() const
{
	return CPP14Parser::RuleCvqualifier;//688
}

void CPP14Parser::CvqualifierContext::copyFrom(CvqualifierContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::CvqualifierContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<CvqualifierContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::CvqualifierContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::CvqualifierContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::CvqualifierContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitCvqualifier(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::CvqualifierContext* CPP14Parser::cvqualifier( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<CvqualifierContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 254, CPP14Parser::RuleCvqualifier);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1767);//970
		_la = _input->LA(1);
		if (!(_la == CPP14Parser::Const

		|| _la == CPP14Parser::Volatile))
		{
		_errHandler->recoverInline(this, ctx);
		}
		else
		{
			_errHandler->reportMatch(this);
			consume(ctx);
		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::CvqualifierContext> CPP14Parser::parsecvqualifier()
{
	cvqualifier();
	auto result = std::unique_ptr<CvqualifierContext>(dynamic_cast<CvqualifierContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- RefqualifierContext ------------------------------------------------------------------

CPP14Parser::RefqualifierContext::RefqualifierContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::RefqualifierContext::And()
{
	return getToken(CPP14Parser::And, 0);
}


size_t CPP14Parser::RefqualifierContext::getRuleIndex() const
{
	return CPP14Parser::RuleRefqualifier;//688
}

void CPP14Parser::RefqualifierContext::copyFrom(RefqualifierContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::RefqualifierContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<RefqualifierContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::RefqualifierContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::RefqualifierContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::RefqualifierContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitRefqualifier(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::RefqualifierContext* CPP14Parser::refqualifier( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<RefqualifierContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 256, CPP14Parser::RuleRefqualifier);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1769);//970
		_la = _input->LA(1);
		if (!(_la == CPP14Parser::T__2 || _la == CPP14Parser::And))
		{
		_errHandler->recoverInline(this, ctx);
		}
		else
		{
			_errHandler->reportMatch(this);
			consume(ctx);
		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::RefqualifierContext> CPP14Parser::parserefqualifier()
{
	refqualifier();
	auto result = std::unique_ptr<RefqualifierContext>(dynamic_cast<RefqualifierContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- DeclaratoridContext ------------------------------------------------------------------

CPP14Parser::DeclaratoridContext::DeclaratoridContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::IdexpressionContext* CPP14Parser::DeclaratoridContext::idexpression()
{
	return getRuleContext<CPP14Parser::IdexpressionContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::DeclaratoridContext::Ellipsis()
{
	return getToken(CPP14Parser::Ellipsis, 0);
}


size_t CPP14Parser::DeclaratoridContext::getRuleIndex() const
{
	return CPP14Parser::RuleDeclaratorid;//688
}

void CPP14Parser::DeclaratoridContext::copyFrom(DeclaratoridContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::DeclaratoridContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<DeclaratoridContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::DeclaratoridContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::DeclaratoridContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::DeclaratoridContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitDeclaratorid(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::DeclaratoridContext* CPP14Parser::declaratorid( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<DeclaratoridContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 258, CPP14Parser::RuleDeclaratorid);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1772);//788
		_errHandler->sync(this, ctx);

		_la = _input->LA(1);
		if (_la == CPP14Parser::Ellipsis)
		{
			setState(1771);//958
			match(CPP14Parser::Ellipsis,ctx);
		}
		setState(1774); //951
		idexpression(ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::DeclaratoridContext> CPP14Parser::parsedeclaratorid()
{
	declaratorid();
	auto result = std::unique_ptr<DeclaratoridContext>(dynamic_cast<DeclaratoridContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- ThetypeidContext ------------------------------------------------------------------

CPP14Parser::ThetypeidContext::ThetypeidContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::TypespecifierseqContext* CPP14Parser::ThetypeidContext::typespecifierseq()
{
	return getRuleContext<CPP14Parser::TypespecifierseqContext>(0);//1165
}

CPP14Parser::AbstractdeclaratorContext* CPP14Parser::ThetypeidContext::abstractdeclarator()
{
	return getRuleContext<CPP14Parser::AbstractdeclaratorContext>(0);//1165
}


size_t CPP14Parser::ThetypeidContext::getRuleIndex() const
{
	return CPP14Parser::RuleThetypeid;//688
}

void CPP14Parser::ThetypeidContext::copyFrom(ThetypeidContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::ThetypeidContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<ThetypeidContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::ThetypeidContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::ThetypeidContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::ThetypeidContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitThetypeid(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::ThetypeidContext* CPP14Parser::thetypeid( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<ThetypeidContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 260, CPP14Parser::RuleThetypeid);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1776); //951
		typespecifierseq(ctx);
		setState(1778);//848
		_errHandler->sync(this, ctx);

		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 195, ctx))
		{
		case 1:
		{
			setState(1777); //951
			abstractdeclarator(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::ThetypeidContext> CPP14Parser::parsethetypeid()
{
	thetypeid();
	auto result = std::unique_ptr<ThetypeidContext>(dynamic_cast<ThetypeidContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- AbstractdeclaratorContext ------------------------------------------------------------------

CPP14Parser::AbstractdeclaratorContext::AbstractdeclaratorContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::PtrabstractdeclaratorContext* CPP14Parser::AbstractdeclaratorContext::ptrabstractdeclarator()
{
	return getRuleContext<CPP14Parser::PtrabstractdeclaratorContext>(0);//1165
}

CPP14Parser::ParametersandqualifiersContext* CPP14Parser::AbstractdeclaratorContext::parametersandqualifiers()
{
	return getRuleContext<CPP14Parser::ParametersandqualifiersContext>(0);//1165
}

CPP14Parser::TrailingreturntypeContext* CPP14Parser::AbstractdeclaratorContext::trailingreturntype()
{
	return getRuleContext<CPP14Parser::TrailingreturntypeContext>(0);//1165
}

CPP14Parser::NoptrabstractdeclaratorContext* CPP14Parser::AbstractdeclaratorContext::noptrabstractdeclarator()
{
	return getRuleContext<CPP14Parser::NoptrabstractdeclaratorContext>(0);//1165
}

CPP14Parser::AbstractpackdeclaratorContext* CPP14Parser::AbstractdeclaratorContext::abstractpackdeclarator()
{
	return getRuleContext<CPP14Parser::AbstractpackdeclaratorContext>(0);//1165
}


size_t CPP14Parser::AbstractdeclaratorContext::getRuleIndex() const
{
	return CPP14Parser::RuleAbstractdeclarator;//688
}

void CPP14Parser::AbstractdeclaratorContext::copyFrom(AbstractdeclaratorContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::AbstractdeclaratorContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<AbstractdeclaratorContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::AbstractdeclaratorContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::AbstractdeclaratorContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::AbstractdeclaratorContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitAbstractdeclarator(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::AbstractdeclaratorContext* CPP14Parser::abstractdeclarator( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<AbstractdeclaratorContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 262, CPP14Parser::RuleAbstractdeclarator);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1788);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 197, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(1780); //951
			ptrabstractdeclarator(ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(1782);//848
			_errHandler->sync(this, ctx);

			switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 196, ctx))
			{
			case 1:
			{
				setState(1781); //951
				noptrabstractdeclarator(0,ctx);
				break;
			}

			}
			setState(1784); //951
			parametersandqualifiers(ctx);
			setState(1785); //951
			trailingreturntype(ctx);
			break;
		}

		case 3:
		{
			enterOuterAlt(ctx, 3);
			setState(1787); //951
			abstractpackdeclarator(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::AbstractdeclaratorContext> CPP14Parser::parseabstractdeclarator()
{
	abstractdeclarator();
	auto result = std::unique_ptr<AbstractdeclaratorContext>(dynamic_cast<AbstractdeclaratorContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- PtrabstractdeclaratorContext ------------------------------------------------------------------

CPP14Parser::PtrabstractdeclaratorContext::PtrabstractdeclaratorContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::NoptrabstractdeclaratorContext* CPP14Parser::PtrabstractdeclaratorContext::noptrabstractdeclarator()
{
	return getRuleContext<CPP14Parser::NoptrabstractdeclaratorContext>(0);//1165
}

CPP14Parser::PtroperatorContext* CPP14Parser::PtrabstractdeclaratorContext::ptroperator()
{
	return getRuleContext<CPP14Parser::PtroperatorContext>(0);//1165
}

CPP14Parser::PtrabstractdeclaratorContext* CPP14Parser::PtrabstractdeclaratorContext::ptrabstractdeclarator()
{
	return getRuleContext<CPP14Parser::PtrabstractdeclaratorContext>(0);//1165
}


size_t CPP14Parser::PtrabstractdeclaratorContext::getRuleIndex() const
{
	return CPP14Parser::RulePtrabstractdeclarator;//688
}

void CPP14Parser::PtrabstractdeclaratorContext::copyFrom(PtrabstractdeclaratorContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::PtrabstractdeclaratorContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<PtrabstractdeclaratorContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::PtrabstractdeclaratorContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::PtrabstractdeclaratorContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::PtrabstractdeclaratorContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitPtrabstractdeclarator(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::PtrabstractdeclaratorContext* CPP14Parser::ptrabstractdeclarator( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<PtrabstractdeclaratorContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 264, CPP14Parser::RulePtrabstractdeclarator);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1795);//750
		_errHandler->sync(this, ctx);
		switch (_input->LA(1))
		{
			case CPP14Parser::LeftParen:
			case CPP14Parser::LeftBracket:
			{
				enterOuterAlt(ctx, 1);
				setState(1790); //951
				noptrabstractdeclarator(0,ctx);
				break;
			}

			case CPP14Parser::T__2:
			case CPP14Parser::Decltype:
			case CPP14Parser::Star:
			case CPP14Parser::And:
			case CPP14Parser::Doublecolon:
			case CPP14Parser::Identifier:
			{
				enterOuterAlt(ctx, 2);
				setState(1791); //951
				ptroperator(ctx);
				setState(1793);//848
				_errHandler->sync(this, ctx);

				switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 198, ctx))
				{
				case 1:
				{
					setState(1792); //951
					ptrabstractdeclarator(ctx);
					break;
				}

				}
				break;
			}

		default:
			throw NoViableAltException(this, ctx);
		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::PtrabstractdeclaratorContext> CPP14Parser::parseptrabstractdeclarator()
{
	ptrabstractdeclarator();
	auto result = std::unique_ptr<PtrabstractdeclaratorContext>(dynamic_cast<PtrabstractdeclaratorContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- NoptrabstractdeclaratorContext ------------------------------------------------------------------

CPP14Parser::NoptrabstractdeclaratorContext::NoptrabstractdeclaratorContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::ParametersandqualifiersContext* CPP14Parser::NoptrabstractdeclaratorContext::parametersandqualifiers()
{
	return getRuleContext<CPP14Parser::ParametersandqualifiersContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::NoptrabstractdeclaratorContext::LeftBracket()
{
	return getToken(CPP14Parser::LeftBracket, 0);
}

tree::TerminalNode* CPP14Parser::NoptrabstractdeclaratorContext::RightBracket()
{
	return getToken(CPP14Parser::RightBracket, 0);
}

CPP14Parser::ConstantexpressionContext* CPP14Parser::NoptrabstractdeclaratorContext::constantexpression()
{
	return getRuleContext<CPP14Parser::ConstantexpressionContext>(0);//1165
}

CPP14Parser::AttributespecifierseqContext* CPP14Parser::NoptrabstractdeclaratorContext::attributespecifierseq()
{
	return getRuleContext<CPP14Parser::AttributespecifierseqContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::NoptrabstractdeclaratorContext::LeftParen()
{
	return getToken(CPP14Parser::LeftParen, 0);
}

CPP14Parser::PtrabstractdeclaratorContext* CPP14Parser::NoptrabstractdeclaratorContext::ptrabstractdeclarator()
{
	return getRuleContext<CPP14Parser::PtrabstractdeclaratorContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::NoptrabstractdeclaratorContext::RightParen()
{
	return getToken(CPP14Parser::RightParen, 0);
}

CPP14Parser::NoptrabstractdeclaratorContext* CPP14Parser::NoptrabstractdeclaratorContext::noptrabstractdeclarator()
{
	return getRuleContext<CPP14Parser::NoptrabstractdeclaratorContext>(0);//1165
}


size_t CPP14Parser::NoptrabstractdeclaratorContext::getRuleIndex() const
{
	return CPP14Parser::RuleNoptrabstractdeclarator;//688
}

void CPP14Parser::NoptrabstractdeclaratorContext::copyFrom(NoptrabstractdeclaratorContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::NoptrabstractdeclaratorContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<NoptrabstractdeclaratorContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::NoptrabstractdeclaratorContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::NoptrabstractdeclaratorContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::NoptrabstractdeclaratorContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitNoptrabstractdeclarator(this);
	else
		return visitor->visitChildren(this);
}


CPP14Parser::NoptrabstractdeclaratorContext* CPP14Parser::noptrabstractdeclarator()
{
	 return noptrabstractdeclarator(0, nullptr);//600
}

CPP14Parser::NoptrabstractdeclaratorContext* CPP14Parser::noptrabstractdeclarator(int precedence, antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	antlr4::ParserRuleContext *parentContext = parent;
	size_t parentState = getState();
	auto _localctx = std::make_unique<NoptrabstractdeclaratorContext>(parentContext, parentState);//610
	auto ctx = _localctx.get();//609
	size_t startState = 266;
	enterRecursionRule(ctx, 266, CPP14Parser::RuleNoptrabstractdeclarator, precedence);

		size_t _la = 0;

	auto onExit = finally([=,&_localctx]
{
		unrollRecursionContexts(parentContext, std::move(_localctx));
	});
	try
{
		size_t alt;
		enterOuterAlt(ctx, 1);
		setState(1811);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 202, ctx))
		{
		case 1:
		{
			setState(1798); //951
			parametersandqualifiers(ctx);
			break;
		}

		case 2:
		{
			setState(1799);//958
			match(CPP14Parser::LeftBracket,ctx);
			setState(1801);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if ((((_la & ~ 0x3fULL) == 0) &&
				((1ULL << _la) & ((1ULL << CPP14Parser::T__0)
				| (1ULL << CPP14Parser::T__1)
				| (1ULL << CPP14Parser::Alignof)
				| (1ULL << CPP14Parser::Auto)
				| (1ULL << CPP14Parser::Bool)
				| (1ULL << CPP14Parser::Char)
				| (1ULL << CPP14Parser::Char16)
				| (1ULL << CPP14Parser::Char32)
				| (1ULL << CPP14Parser::Const_cast)
				| (1ULL << CPP14Parser::Decltype)
				| (1ULL << CPP14Parser::Delete)
				| (1ULL << CPP14Parser::Double)
				| (1ULL << CPP14Parser::Dynamic_cast)
				| (1ULL << CPP14Parser::False)
				| (1ULL << CPP14Parser::Float)
				| (1ULL << CPP14Parser::Int)
				| (1ULL << CPP14Parser::Long)
				| (1ULL << CPP14Parser::New)
				| (1ULL << CPP14Parser::Noexcept)
				| (1ULL << CPP14Parser::Nullptr)
				| (1ULL << CPP14Parser::Operator)
				| (1ULL << CPP14Parser::Reinterpret_cast)
				| (1ULL << CPP14Parser::Short)
				| (1ULL << CPP14Parser::Signed)
				| (1ULL << CPP14Parser::Sizeof))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
				((1ULL << (_la - 64)) & ((1ULL << (CPP14Parser::Static_cast - 64))
				| (1ULL << (CPP14Parser::This - 64))
				| (1ULL << (CPP14Parser::True - 64))
				| (1ULL << (CPP14Parser::Typeid_ - 64))
				| (1ULL << (CPP14Parser::Typename_ - 64))
				| (1ULL << (CPP14Parser::Unsigned - 64))
				| (1ULL << (CPP14Parser::Void - 64))
				| (1ULL << (CPP14Parser::Wchar - 64))
				| (1ULL << (CPP14Parser::LeftParen - 64))
				| (1ULL << (CPP14Parser::LeftBracket - 64))
				| (1ULL << (CPP14Parser::Plus - 64))
				| (1ULL << (CPP14Parser::Minus - 64))
				| (1ULL << (CPP14Parser::Star - 64))
				| (1ULL << (CPP14Parser::And - 64))
				| (1ULL << (CPP14Parser::Or - 64))
				| (1ULL << (CPP14Parser::Tilde - 64))
				| (1ULL << (CPP14Parser::PlusPlus - 64))
				| (1ULL << (CPP14Parser::MinusMinus - 64))
				| (1ULL << (CPP14Parser::Doublecolon - 64)))) != 0) || ((((_la - 130) & ~ 0x3fULL) == 0) &&
				((1ULL << (_la - 130)) & ((1ULL << (CPP14Parser::Identifier - 130))
				| (1ULL << (CPP14Parser::Integerliteral - 130))
				| (1ULL << (CPP14Parser::Characterliteral - 130))
				| (1ULL << (CPP14Parser::Floatingliteral - 130))
				| (1ULL << (CPP14Parser::Stringliteral - 130))
				| (1ULL << (CPP14Parser::Userdefinedintegerliteral - 130))
				| (1ULL << (CPP14Parser::Userdefinedfloatingliteral - 130))
				| (1ULL << (CPP14Parser::Userdefinedstringliteral - 130))
				| (1ULL << (CPP14Parser::Userdefinedcharacterliteral - 130)))) != 0))
			{
				setState(1800); //951
				constantexpression(ctx);
			}
			setState(1803);//958
			match(CPP14Parser::RightBracket,ctx);
			setState(1805);//848
			_errHandler->sync(this, ctx);

			switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 201, ctx))
			{
			case 1:
			{
				setState(1804); //951
				attributespecifierseq(0,ctx);
				break;
			}

			}
			break;
		}

		case 3:
		{
			setState(1807);//958
			match(CPP14Parser::LeftParen,ctx);
			setState(1808); //951
			ptrabstractdeclarator(ctx);
			setState(1809);//958
			match(CPP14Parser::RightParen,ctx);
			break;
		}

		}
		ctx->stop = _input->LT(-1);
		setState(1826);//865
		_errHandler->sync(this, ctx);
		alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 206, ctx);
		while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
		{
			if (alt == 1)
		{
				if (!_parseListeners.empty())
					triggerExitRuleEvent(ctx);

				setState(1824);//830
				_errHandler->sync(this, ctx);
				switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 205, ctx))
				{
				case 1:
				{
					auto tmpContext = std::make_unique<NoptrabstractdeclaratorContext>(parentContext, parentState);
					pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleNoptrabstractdeclarator);//1240
					_localctx = std::move(tmpContext);
					ctx = _localctx.get();
					setState(1813);//1002

					if (!(precpred(nullptr, 5))) throw FailedPredicateException(this, "precpred(nullptr, 5)", ctx);
					setState(1814); //951
					parametersandqualifiers(ctx);
					break;
				}

				case 2:
				{
					auto tmpContext = std::make_unique<NoptrabstractdeclaratorContext>(parentContext, parentState);
					pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleNoptrabstractdeclarator);//1240
					_localctx = std::move(tmpContext);
					ctx = _localctx.get();
					setState(1815);//1002

					if (!(precpred(nullptr, 3))) throw FailedPredicateException(this, "precpred(nullptr, 3)", ctx);
					setState(1816);//958
					match(CPP14Parser::LeftBracket,ctx);
					setState(1818);//788
					_errHandler->sync(this, ctx);

					_la = _input->LA(1);
					if ((((_la & ~ 0x3fULL) == 0) &&
						((1ULL << _la) & ((1ULL << CPP14Parser::T__0)
						| (1ULL << CPP14Parser::T__1)
						| (1ULL << CPP14Parser::Alignof)
						| (1ULL << CPP14Parser::Auto)
						| (1ULL << CPP14Parser::Bool)
						| (1ULL << CPP14Parser::Char)
						| (1ULL << CPP14Parser::Char16)
						| (1ULL << CPP14Parser::Char32)
						| (1ULL << CPP14Parser::Const_cast)
						| (1ULL << CPP14Parser::Decltype)
						| (1ULL << CPP14Parser::Delete)
						| (1ULL << CPP14Parser::Double)
						| (1ULL << CPP14Parser::Dynamic_cast)
						| (1ULL << CPP14Parser::False)
						| (1ULL << CPP14Parser::Float)
						| (1ULL << CPP14Parser::Int)
						| (1ULL << CPP14Parser::Long)
						| (1ULL << CPP14Parser::New)
						| (1ULL << CPP14Parser::Noexcept)
						| (1ULL << CPP14Parser::Nullptr)
						| (1ULL << CPP14Parser::Operator)
						| (1ULL << CPP14Parser::Reinterpret_cast)
						| (1ULL << CPP14Parser::Short)
						| (1ULL << CPP14Parser::Signed)
						| (1ULL << CPP14Parser::Sizeof))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
						((1ULL << (_la - 64)) & ((1ULL << (CPP14Parser::Static_cast - 64))
						| (1ULL << (CPP14Parser::This - 64))
						| (1ULL << (CPP14Parser::True - 64))
						| (1ULL << (CPP14Parser::Typeid_ - 64))
						| (1ULL << (CPP14Parser::Typename_ - 64))
						| (1ULL << (CPP14Parser::Unsigned - 64))
						| (1ULL << (CPP14Parser::Void - 64))
						| (1ULL << (CPP14Parser::Wchar - 64))
						| (1ULL << (CPP14Parser::LeftParen - 64))
						| (1ULL << (CPP14Parser::LeftBracket - 64))
						| (1ULL << (CPP14Parser::Plus - 64))
						| (1ULL << (CPP14Parser::Minus - 64))
						| (1ULL << (CPP14Parser::Star - 64))
						| (1ULL << (CPP14Parser::And - 64))
						| (1ULL << (CPP14Parser::Or - 64))
						| (1ULL << (CPP14Parser::Tilde - 64))
						| (1ULL << (CPP14Parser::PlusPlus - 64))
						| (1ULL << (CPP14Parser::MinusMinus - 64))
						| (1ULL << (CPP14Parser::Doublecolon - 64)))) != 0) || ((((_la - 130) & ~ 0x3fULL) == 0) &&
						((1ULL << (_la - 130)) & ((1ULL << (CPP14Parser::Identifier - 130))
						| (1ULL << (CPP14Parser::Integerliteral - 130))
						| (1ULL << (CPP14Parser::Characterliteral - 130))
						| (1ULL << (CPP14Parser::Floatingliteral - 130))
						| (1ULL << (CPP14Parser::Stringliteral - 130))
						| (1ULL << (CPP14Parser::Userdefinedintegerliteral - 130))
						| (1ULL << (CPP14Parser::Userdefinedfloatingliteral - 130))
						| (1ULL << (CPP14Parser::Userdefinedstringliteral - 130))
						| (1ULL << (CPP14Parser::Userdefinedcharacterliteral - 130)))) != 0))
					{
						setState(1817); //951
						constantexpression(ctx);
					}
					setState(1820);//958
					match(CPP14Parser::RightBracket,ctx);
					setState(1822);//848
					_errHandler->sync(this, ctx);

					switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 204, ctx))
					{
					case 1:
					{
						setState(1821); //951
						attributespecifierseq(0,ctx);
						break;
					}

					}
					break;
				}

				} 
			}
			setState(1828);//875
			_errHandler->sync(this, ctx);
			alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 206, ctx);
		}
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		_localctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}
	onExit();
	return ctx;
}

std::unique_ptr< CPP14Parser::NoptrabstractdeclaratorContext> CPP14Parser::parsenoptrabstractdeclarator()
{
	noptrabstractdeclarator();
	auto result = std::unique_ptr<NoptrabstractdeclaratorContext>(dynamic_cast<NoptrabstractdeclaratorContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}

//----------------- AbstractpackdeclaratorContext ------------------------------------------------------------------

CPP14Parser::AbstractpackdeclaratorContext::AbstractpackdeclaratorContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::NoptrabstractpackdeclaratorContext* CPP14Parser::AbstractpackdeclaratorContext::noptrabstractpackdeclarator()
{
	return getRuleContext<CPP14Parser::NoptrabstractpackdeclaratorContext>(0);//1165
}

CPP14Parser::PtroperatorContext* CPP14Parser::AbstractpackdeclaratorContext::ptroperator()
{
	return getRuleContext<CPP14Parser::PtroperatorContext>(0);//1165
}

CPP14Parser::AbstractpackdeclaratorContext* CPP14Parser::AbstractpackdeclaratorContext::abstractpackdeclarator()
{
	return getRuleContext<CPP14Parser::AbstractpackdeclaratorContext>(0);//1165
}


size_t CPP14Parser::AbstractpackdeclaratorContext::getRuleIndex() const
{
	return CPP14Parser::RuleAbstractpackdeclarator;//688
}

void CPP14Parser::AbstractpackdeclaratorContext::copyFrom(AbstractpackdeclaratorContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::AbstractpackdeclaratorContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<AbstractpackdeclaratorContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::AbstractpackdeclaratorContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::AbstractpackdeclaratorContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::AbstractpackdeclaratorContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitAbstractpackdeclarator(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::AbstractpackdeclaratorContext* CPP14Parser::abstractpackdeclarator( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<AbstractpackdeclaratorContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 268, CPP14Parser::RuleAbstractpackdeclarator);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1833);//750
		_errHandler->sync(this, ctx);
		switch (_input->LA(1))
		{
			case CPP14Parser::Ellipsis:
			{
				enterOuterAlt(ctx, 1);
				setState(1829); //951
				noptrabstractpackdeclarator(0,ctx);
				break;
			}

			case CPP14Parser::T__2:
			case CPP14Parser::Decltype:
			case CPP14Parser::Star:
			case CPP14Parser::And:
			case CPP14Parser::Doublecolon:
			case CPP14Parser::Identifier:
			{
				enterOuterAlt(ctx, 2);
				setState(1830); //951
				ptroperator(ctx);
				setState(1831); //951
				abstractpackdeclarator(ctx);
				break;
			}

		default:
			throw NoViableAltException(this, ctx);
		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::AbstractpackdeclaratorContext> CPP14Parser::parseabstractpackdeclarator()
{
	abstractpackdeclarator();
	auto result = std::unique_ptr<AbstractpackdeclaratorContext>(dynamic_cast<AbstractpackdeclaratorContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- NoptrabstractpackdeclaratorContext ------------------------------------------------------------------

CPP14Parser::NoptrabstractpackdeclaratorContext::NoptrabstractpackdeclaratorContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::NoptrabstractpackdeclaratorContext::Ellipsis()
{
	return getToken(CPP14Parser::Ellipsis, 0);
}

CPP14Parser::NoptrabstractpackdeclaratorContext* CPP14Parser::NoptrabstractpackdeclaratorContext::noptrabstractpackdeclarator()
{
	return getRuleContext<CPP14Parser::NoptrabstractpackdeclaratorContext>(0);//1165
}

CPP14Parser::ParametersandqualifiersContext* CPP14Parser::NoptrabstractpackdeclaratorContext::parametersandqualifiers()
{
	return getRuleContext<CPP14Parser::ParametersandqualifiersContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::NoptrabstractpackdeclaratorContext::LeftBracket()
{
	return getToken(CPP14Parser::LeftBracket, 0);
}

tree::TerminalNode* CPP14Parser::NoptrabstractpackdeclaratorContext::RightBracket()
{
	return getToken(CPP14Parser::RightBracket, 0);
}

CPP14Parser::ConstantexpressionContext* CPP14Parser::NoptrabstractpackdeclaratorContext::constantexpression()
{
	return getRuleContext<CPP14Parser::ConstantexpressionContext>(0);//1165
}

CPP14Parser::AttributespecifierseqContext* CPP14Parser::NoptrabstractpackdeclaratorContext::attributespecifierseq()
{
	return getRuleContext<CPP14Parser::AttributespecifierseqContext>(0);//1165
}


size_t CPP14Parser::NoptrabstractpackdeclaratorContext::getRuleIndex() const
{
	return CPP14Parser::RuleNoptrabstractpackdeclarator;//688
}

void CPP14Parser::NoptrabstractpackdeclaratorContext::copyFrom(NoptrabstractpackdeclaratorContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::NoptrabstractpackdeclaratorContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<NoptrabstractpackdeclaratorContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::NoptrabstractpackdeclaratorContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::NoptrabstractpackdeclaratorContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::NoptrabstractpackdeclaratorContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitNoptrabstractpackdeclarator(this);
	else
		return visitor->visitChildren(this);
}


CPP14Parser::NoptrabstractpackdeclaratorContext* CPP14Parser::noptrabstractpackdeclarator()
{
	 return noptrabstractpackdeclarator(0, nullptr);//600
}

CPP14Parser::NoptrabstractpackdeclaratorContext* CPP14Parser::noptrabstractpackdeclarator(int precedence, antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	antlr4::ParserRuleContext *parentContext = parent;
	size_t parentState = getState();
	auto _localctx = std::make_unique<NoptrabstractpackdeclaratorContext>(parentContext, parentState);//610
	auto ctx = _localctx.get();//609
	size_t startState = 270;
	enterRecursionRule(ctx, 270, CPP14Parser::RuleNoptrabstractpackdeclarator, precedence);

		size_t _la = 0;

	auto onExit = finally([=,&_localctx]
{
		unrollRecursionContexts(parentContext, std::move(_localctx));
	});
	try
{
		size_t alt;
		enterOuterAlt(ctx, 1);
		setState(1836);//958
		match(CPP14Parser::Ellipsis,ctx);
		ctx->stop = _input->LT(-1);
		setState(1851);//865
		_errHandler->sync(this, ctx);
		alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 211, ctx);
		while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
		{
			if (alt == 1)
		{
				if (!_parseListeners.empty())
					triggerExitRuleEvent(ctx);

				setState(1849);//830
				_errHandler->sync(this, ctx);
				switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 210, ctx))
				{
				case 1:
				{
					auto tmpContext = std::make_unique<NoptrabstractpackdeclaratorContext>(parentContext, parentState);
					pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleNoptrabstractpackdeclarator);//1240
					_localctx = std::move(tmpContext);
					ctx = _localctx.get();
					setState(1838);//1002

					if (!(precpred(nullptr, 3))) throw FailedPredicateException(this, "precpred(nullptr, 3)", ctx);
					setState(1839); //951
					parametersandqualifiers(ctx);
					break;
				}

				case 2:
				{
					auto tmpContext = std::make_unique<NoptrabstractpackdeclaratorContext>(parentContext, parentState);
					pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleNoptrabstractpackdeclarator);//1240
					_localctx = std::move(tmpContext);
					ctx = _localctx.get();
					setState(1840);//1002

					if (!(precpred(nullptr, 2))) throw FailedPredicateException(this, "precpred(nullptr, 2)", ctx);
					setState(1841);//958
					match(CPP14Parser::LeftBracket,ctx);
					setState(1843);//788
					_errHandler->sync(this, ctx);

					_la = _input->LA(1);
					if ((((_la & ~ 0x3fULL) == 0) &&
						((1ULL << _la) & ((1ULL << CPP14Parser::T__0)
						| (1ULL << CPP14Parser::T__1)
						| (1ULL << CPP14Parser::Alignof)
						| (1ULL << CPP14Parser::Auto)
						| (1ULL << CPP14Parser::Bool)
						| (1ULL << CPP14Parser::Char)
						| (1ULL << CPP14Parser::Char16)
						| (1ULL << CPP14Parser::Char32)
						| (1ULL << CPP14Parser::Const_cast)
						| (1ULL << CPP14Parser::Decltype)
						| (1ULL << CPP14Parser::Delete)
						| (1ULL << CPP14Parser::Double)
						| (1ULL << CPP14Parser::Dynamic_cast)
						| (1ULL << CPP14Parser::False)
						| (1ULL << CPP14Parser::Float)
						| (1ULL << CPP14Parser::Int)
						| (1ULL << CPP14Parser::Long)
						| (1ULL << CPP14Parser::New)
						| (1ULL << CPP14Parser::Noexcept)
						| (1ULL << CPP14Parser::Nullptr)
						| (1ULL << CPP14Parser::Operator)
						| (1ULL << CPP14Parser::Reinterpret_cast)
						| (1ULL << CPP14Parser::Short)
						| (1ULL << CPP14Parser::Signed)
						| (1ULL << CPP14Parser::Sizeof))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
						((1ULL << (_la - 64)) & ((1ULL << (CPP14Parser::Static_cast - 64))
						| (1ULL << (CPP14Parser::This - 64))
						| (1ULL << (CPP14Parser::True - 64))
						| (1ULL << (CPP14Parser::Typeid_ - 64))
						| (1ULL << (CPP14Parser::Typename_ - 64))
						| (1ULL << (CPP14Parser::Unsigned - 64))
						| (1ULL << (CPP14Parser::Void - 64))
						| (1ULL << (CPP14Parser::Wchar - 64))
						| (1ULL << (CPP14Parser::LeftParen - 64))
						| (1ULL << (CPP14Parser::LeftBracket - 64))
						| (1ULL << (CPP14Parser::Plus - 64))
						| (1ULL << (CPP14Parser::Minus - 64))
						| (1ULL << (CPP14Parser::Star - 64))
						| (1ULL << (CPP14Parser::And - 64))
						| (1ULL << (CPP14Parser::Or - 64))
						| (1ULL << (CPP14Parser::Tilde - 64))
						| (1ULL << (CPP14Parser::PlusPlus - 64))
						| (1ULL << (CPP14Parser::MinusMinus - 64))
						| (1ULL << (CPP14Parser::Doublecolon - 64)))) != 0) || ((((_la - 130) & ~ 0x3fULL) == 0) &&
						((1ULL << (_la - 130)) & ((1ULL << (CPP14Parser::Identifier - 130))
						| (1ULL << (CPP14Parser::Integerliteral - 130))
						| (1ULL << (CPP14Parser::Characterliteral - 130))
						| (1ULL << (CPP14Parser::Floatingliteral - 130))
						| (1ULL << (CPP14Parser::Stringliteral - 130))
						| (1ULL << (CPP14Parser::Userdefinedintegerliteral - 130))
						| (1ULL << (CPP14Parser::Userdefinedfloatingliteral - 130))
						| (1ULL << (CPP14Parser::Userdefinedstringliteral - 130))
						| (1ULL << (CPP14Parser::Userdefinedcharacterliteral - 130)))) != 0))
					{
						setState(1842); //951
						constantexpression(ctx);
					}
					setState(1845);//958
					match(CPP14Parser::RightBracket,ctx);
					setState(1847);//848
					_errHandler->sync(this, ctx);

					switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 209, ctx))
					{
					case 1:
					{
						setState(1846); //951
						attributespecifierseq(0,ctx);
						break;
					}

					}
					break;
				}

				} 
			}
			setState(1853);//875
			_errHandler->sync(this, ctx);
			alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 211, ctx);
		}
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		_localctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}
	onExit();
	return ctx;
}

std::unique_ptr< CPP14Parser::NoptrabstractpackdeclaratorContext> CPP14Parser::parsenoptrabstractpackdeclarator()
{
	noptrabstractpackdeclarator();
	auto result = std::unique_ptr<NoptrabstractpackdeclaratorContext>(dynamic_cast<NoptrabstractpackdeclaratorContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}

//----------------- ParameterdeclarationclauseContext ------------------------------------------------------------------

CPP14Parser::ParameterdeclarationclauseContext::ParameterdeclarationclauseContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::ParameterdeclarationlistContext* CPP14Parser::ParameterdeclarationclauseContext::parameterdeclarationlist()
{
	return getRuleContext<CPP14Parser::ParameterdeclarationlistContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::ParameterdeclarationclauseContext::Ellipsis()
{
	return getToken(CPP14Parser::Ellipsis, 0);
}

tree::TerminalNode* CPP14Parser::ParameterdeclarationclauseContext::Comma()
{
	return getToken(CPP14Parser::Comma, 0);
}


size_t CPP14Parser::ParameterdeclarationclauseContext::getRuleIndex() const
{
	return CPP14Parser::RuleParameterdeclarationclause;//688
}

void CPP14Parser::ParameterdeclarationclauseContext::copyFrom(ParameterdeclarationclauseContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::ParameterdeclarationclauseContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<ParameterdeclarationclauseContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::ParameterdeclarationclauseContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::ParameterdeclarationclauseContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::ParameterdeclarationclauseContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitParameterdeclarationclause(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::ParameterdeclarationclauseContext* CPP14Parser::parameterdeclarationclause( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<ParameterdeclarationclauseContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 272, CPP14Parser::RuleParameterdeclarationclause);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1864);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 214, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(1855);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (((((_la - 9) & ~ 0x3fULL) == 0) &&
				((1ULL << (_la - 9)) & ((1ULL << (CPP14Parser::Alignas - 9))
				| (1ULL << (CPP14Parser::Auto - 9))
				| (1ULL << (CPP14Parser::Bool - 9))
				| (1ULL << (CPP14Parser::Char - 9))
				| (1ULL << (CPP14Parser::Char16 - 9))
				| (1ULL << (CPP14Parser::Char32 - 9))
				| (1ULL << (CPP14Parser::Class - 9))
				| (1ULL << (CPP14Parser::Const - 9))
				| (1ULL << (CPP14Parser::Constexpr - 9))
				| (1ULL << (CPP14Parser::Decltype - 9))
				| (1ULL << (CPP14Parser::Double - 9))
				| (1ULL << (CPP14Parser::Enum - 9))
				| (1ULL << (CPP14Parser::Explicit - 9))
				| (1ULL << (CPP14Parser::Extern - 9))
				| (1ULL << (CPP14Parser::Float - 9))
				| (1ULL << (CPP14Parser::Friend - 9))
				| (1ULL << (CPP14Parser::Inline - 9))
				| (1ULL << (CPP14Parser::Int - 9))
				| (1ULL << (CPP14Parser::Long - 9))
				| (1ULL << (CPP14Parser::Mutable - 9))
				| (1ULL << (CPP14Parser::Register - 9))
				| (1ULL << (CPP14Parser::Short - 9))
				| (1ULL << (CPP14Parser::Signed - 9))
				| (1ULL << (CPP14Parser::Static - 9))
				| (1ULL << (CPP14Parser::Struct - 9))
				| (1ULL << (CPP14Parser::Thread_local - 9)))) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
				((1ULL << (_la - 73)) & ((1ULL << (CPP14Parser::Typedef - 73))
				| (1ULL << (CPP14Parser::Typename_ - 73))
				| (1ULL << (CPP14Parser::Union - 73))
				| (1ULL << (CPP14Parser::Unsigned - 73))
				| (1ULL << (CPP14Parser::Virtual - 73))
				| (1ULL << (CPP14Parser::Void - 73))
				| (1ULL << (CPP14Parser::Volatile - 73))
				| (1ULL << (CPP14Parser::Wchar - 73))
				| (1ULL << (CPP14Parser::LeftBracket - 73))
				| (1ULL << (CPP14Parser::Doublecolon - 73))
				| (1ULL << (CPP14Parser::Identifier - 73)))) != 0))
			{
				setState(1854); //951
				parameterdeclarationlist(0,ctx);
			}
			setState(1858);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Ellipsis)
			{
				setState(1857);//958
				match(CPP14Parser::Ellipsis,ctx);
			}
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(1860); //951
			parameterdeclarationlist(0,ctx);
			setState(1861);//958
			match(CPP14Parser::Comma,ctx);
			setState(1862);//958
			match(CPP14Parser::Ellipsis,ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::ParameterdeclarationclauseContext> CPP14Parser::parseparameterdeclarationclause()
{
	parameterdeclarationclause();
	auto result = std::unique_ptr<ParameterdeclarationclauseContext>(dynamic_cast<ParameterdeclarationclauseContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- ParameterdeclarationlistContext ------------------------------------------------------------------

CPP14Parser::ParameterdeclarationlistContext::ParameterdeclarationlistContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::ParameterdeclarationContext* CPP14Parser::ParameterdeclarationlistContext::parameterdeclaration()
{
	return getRuleContext<CPP14Parser::ParameterdeclarationContext>(0);//1165
}

CPP14Parser::ParameterdeclarationlistContext* CPP14Parser::ParameterdeclarationlistContext::parameterdeclarationlist()
{
	return getRuleContext<CPP14Parser::ParameterdeclarationlistContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::ParameterdeclarationlistContext::Comma()
{
	return getToken(CPP14Parser::Comma, 0);
}


size_t CPP14Parser::ParameterdeclarationlistContext::getRuleIndex() const
{
	return CPP14Parser::RuleParameterdeclarationlist;//688
}

void CPP14Parser::ParameterdeclarationlistContext::copyFrom(ParameterdeclarationlistContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::ParameterdeclarationlistContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<ParameterdeclarationlistContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::ParameterdeclarationlistContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::ParameterdeclarationlistContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::ParameterdeclarationlistContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitParameterdeclarationlist(this);
	else
		return visitor->visitChildren(this);
}


CPP14Parser::ParameterdeclarationlistContext* CPP14Parser::parameterdeclarationlist()
{
	 return parameterdeclarationlist(0, nullptr);//600
}

CPP14Parser::ParameterdeclarationlistContext* CPP14Parser::parameterdeclarationlist(int precedence, antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	antlr4::ParserRuleContext *parentContext = parent;
	size_t parentState = getState();
	auto _localctx = std::make_unique<ParameterdeclarationlistContext>(parentContext, parentState);//610
	auto ctx = _localctx.get();//609
	size_t startState = 274;
	enterRecursionRule(ctx, 274, CPP14Parser::RuleParameterdeclarationlist, precedence);

		

	auto onExit = finally([=,&_localctx]
{
		unrollRecursionContexts(parentContext, std::move(_localctx));
	});
	try
{
		size_t alt;
		enterOuterAlt(ctx, 1);
		setState(1867); //951
		parameterdeclaration(ctx);
		ctx->stop = _input->LT(-1);
		setState(1874);//865
		_errHandler->sync(this, ctx);
		alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 215, ctx);
		while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
		{
			if (alt == 1)
		{
				if (!_parseListeners.empty())
					triggerExitRuleEvent(ctx);

				auto tmpContext = std::make_unique<ParameterdeclarationlistContext>(parentContext, parentState);
				pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleParameterdeclarationlist);//1240
				_localctx = std::move(tmpContext);
				ctx = _localctx.get();
				setState(1869);//1002

				if (!(precpred(nullptr, 1))) throw FailedPredicateException(this, "precpred(nullptr, 1)", ctx);
				setState(1870);//958
				match(CPP14Parser::Comma,ctx);
				setState(1871); //951
				parameterdeclaration(ctx); 
			}
			setState(1876);//875
			_errHandler->sync(this, ctx);
			alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 215, ctx);
		}
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		_localctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}
	onExit();
	return ctx;
}

std::unique_ptr< CPP14Parser::ParameterdeclarationlistContext> CPP14Parser::parseparameterdeclarationlist()
{
	parameterdeclarationlist();
	auto result = std::unique_ptr<ParameterdeclarationlistContext>(dynamic_cast<ParameterdeclarationlistContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}

//----------------- ParameterdeclarationContext ------------------------------------------------------------------

CPP14Parser::ParameterdeclarationContext::ParameterdeclarationContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::DeclspecifierseqContext* CPP14Parser::ParameterdeclarationContext::declspecifierseq()
{
	return getRuleContext<CPP14Parser::DeclspecifierseqContext>(0);//1165
}

CPP14Parser::DeclaratorContext* CPP14Parser::ParameterdeclarationContext::declarator()
{
	return getRuleContext<CPP14Parser::DeclaratorContext>(0);//1165
}

CPP14Parser::AttributespecifierseqContext* CPP14Parser::ParameterdeclarationContext::attributespecifierseq()
{
	return getRuleContext<CPP14Parser::AttributespecifierseqContext>(0);//1165
}

CPP14Parser::UnqualifiedidContext* CPP14Parser::ParameterdeclarationContext::unqualifiedid()
{
	return getRuleContext<CPP14Parser::UnqualifiedidContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::ParameterdeclarationContext::Assign()
{
	return getToken(CPP14Parser::Assign, 0);
}

CPP14Parser::InitializerclauseContext* CPP14Parser::ParameterdeclarationContext::initializerclause()
{
	return getRuleContext<CPP14Parser::InitializerclauseContext>(0);//1165
}

CPP14Parser::AbstractdeclaratorContext* CPP14Parser::ParameterdeclarationContext::abstractdeclarator()
{
	return getRuleContext<CPP14Parser::AbstractdeclaratorContext>(0);//1165
}


size_t CPP14Parser::ParameterdeclarationContext::getRuleIndex() const
{
	return CPP14Parser::RuleParameterdeclaration;//688
}

void CPP14Parser::ParameterdeclarationContext::copyFrom(ParameterdeclarationContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::ParameterdeclarationContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<ParameterdeclarationContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::ParameterdeclarationContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::ParameterdeclarationContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::ParameterdeclarationContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitParameterdeclaration(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::ParameterdeclarationContext* CPP14Parser::parameterdeclaration( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<ParameterdeclarationContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 276, CPP14Parser::RuleParameterdeclaration);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1919);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 226, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(1878);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Alignas || _la == CPP14Parser::LeftBracket)
			{
				setState(1877); //951
				attributespecifierseq(0,ctx);
			}
			setState(1880); //951
			declspecifierseq(ctx);
			setState(1881); //951
			declarator(ctx);
			setState(1883);//848
			_errHandler->sync(this, ctx);

			switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 217, ctx))
			{
			case 1:
			{
				setState(1882); //951
				unqualifiedid(ctx);
				break;
			}

			}
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(1886);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Alignas || _la == CPP14Parser::LeftBracket)
			{
				setState(1885); //951
				attributespecifierseq(0,ctx);
			}
			setState(1888); //951
			declspecifierseq(ctx);
			setState(1889); //951
			declarator(ctx);
			setState(1891);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Operator || _la == CPP14Parser::Tilde

			|| _la == CPP14Parser::Identifier)
			{
				setState(1890); //951
				unqualifiedid(ctx);
			}
			setState(1893);//958
			match(CPP14Parser::Assign,ctx);
			setState(1894); //951
			initializerclause(ctx);
			break;
		}

		case 3:
		{
			enterOuterAlt(ctx, 3);
			setState(1897);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Alignas || _la == CPP14Parser::LeftBracket)
			{
				setState(1896); //951
				attributespecifierseq(0,ctx);
			}
			setState(1899); //951
			declspecifierseq(ctx);
			setState(1901);//848
			_errHandler->sync(this, ctx);

			switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 221, ctx))
			{
			case 1:
			{
				setState(1900); //951
				abstractdeclarator(ctx);
				break;
			}

			}
			setState(1904);//848
			_errHandler->sync(this, ctx);

			switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 222, ctx))
			{
			case 1:
			{
				setState(1903); //951
				unqualifiedid(ctx);
				break;
			}

			}
			break;
		}

		case 4:
		{
			enterOuterAlt(ctx, 4);
			setState(1907);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Alignas || _la == CPP14Parser::LeftBracket)
			{
				setState(1906); //951
				attributespecifierseq(0,ctx);
			}
			setState(1909); //951
			declspecifierseq(ctx);
			setState(1911);//848
			_errHandler->sync(this, ctx);

			switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 224, ctx))
			{
			case 1:
			{
				setState(1910); //951
				abstractdeclarator(ctx);
				break;
			}

			}
			setState(1914);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Operator || _la == CPP14Parser::Tilde

			|| _la == CPP14Parser::Identifier)
			{
				setState(1913); //951
				unqualifiedid(ctx);
			}
			setState(1916);//958
			match(CPP14Parser::Assign,ctx);
			setState(1917); //951
			initializerclause(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::ParameterdeclarationContext> CPP14Parser::parseparameterdeclaration()
{
	parameterdeclaration();
	auto result = std::unique_ptr<ParameterdeclarationContext>(dynamic_cast<ParameterdeclarationContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- FunctiondefinitionContext ------------------------------------------------------------------

CPP14Parser::FunctiondefinitionContext::FunctiondefinitionContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::DeclaratorContext* CPP14Parser::FunctiondefinitionContext::declarator()
{
	return getRuleContext<CPP14Parser::DeclaratorContext>(0);//1165
}

CPP14Parser::FunctionbodyContext* CPP14Parser::FunctiondefinitionContext::functionbody()
{
	return getRuleContext<CPP14Parser::FunctionbodyContext>(0);//1165
}

CPP14Parser::AttributespecifierseqContext* CPP14Parser::FunctiondefinitionContext::attributespecifierseq()
{
	return getRuleContext<CPP14Parser::AttributespecifierseqContext>(0);//1165
}

CPP14Parser::DeclspecifierseqContext* CPP14Parser::FunctiondefinitionContext::declspecifierseq()
{
	return getRuleContext<CPP14Parser::DeclspecifierseqContext>(0);//1165
}

CPP14Parser::VirtspecifierseqContext* CPP14Parser::FunctiondefinitionContext::virtspecifierseq()
{
	return getRuleContext<CPP14Parser::VirtspecifierseqContext>(0);//1165
}


size_t CPP14Parser::FunctiondefinitionContext::getRuleIndex() const
{
	return CPP14Parser::RuleFunctiondefinition;//688
}

void CPP14Parser::FunctiondefinitionContext::copyFrom(FunctiondefinitionContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::FunctiondefinitionContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<FunctiondefinitionContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::FunctiondefinitionContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::FunctiondefinitionContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::FunctiondefinitionContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitFunctiondefinition(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::FunctiondefinitionContext* CPP14Parser::functiondefinition( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<FunctiondefinitionContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 278, CPP14Parser::RuleFunctiondefinition);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1922);//788
		_errHandler->sync(this, ctx);

		_la = _input->LA(1);
		if (_la == CPP14Parser::Alignas || _la == CPP14Parser::LeftBracket)
		{
			setState(1921); //951
			attributespecifierseq(0,ctx);
		}
		setState(1925);//848
		_errHandler->sync(this, ctx);

		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 228, ctx))
		{
		case 1:
		{
			setState(1924); //951
			declspecifierseq(ctx);
			break;
		}

		}
		setState(1927); //951
		declarator(ctx);
		setState(1929);//788
		_errHandler->sync(this, ctx);

		_la = _input->LA(1);
		if (_la == CPP14Parser::Final

		|| _la == CPP14Parser::Override)
		{
			setState(1928); //951
			virtspecifierseq(0,ctx);
		}
		setState(1931); //951
		functionbody(ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::FunctiondefinitionContext> CPP14Parser::parsefunctiondefinition()
{
	functiondefinition();
	auto result = std::unique_ptr<FunctiondefinitionContext>(dynamic_cast<FunctiondefinitionContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- FunctionbodyContext ------------------------------------------------------------------

CPP14Parser::FunctionbodyContext::FunctionbodyContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::CompoundstatementContext* CPP14Parser::FunctionbodyContext::compoundstatement()
{
	return getRuleContext<CPP14Parser::CompoundstatementContext>(0);//1165
}

CPP14Parser::CtorinitializerContext* CPP14Parser::FunctionbodyContext::ctorinitializer()
{
	return getRuleContext<CPP14Parser::CtorinitializerContext>(0);//1165
}

CPP14Parser::FunctiontryblockContext* CPP14Parser::FunctionbodyContext::functiontryblock()
{
	return getRuleContext<CPP14Parser::FunctiontryblockContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::FunctionbodyContext::Assign()
{
	return getToken(CPP14Parser::Assign, 0);
}

tree::TerminalNode* CPP14Parser::FunctionbodyContext::Default()
{
	return getToken(CPP14Parser::Default, 0);
}

tree::TerminalNode* CPP14Parser::FunctionbodyContext::Semi()
{
	return getToken(CPP14Parser::Semi, 0);
}

tree::TerminalNode* CPP14Parser::FunctionbodyContext::Delete()
{
	return getToken(CPP14Parser::Delete, 0);
}


size_t CPP14Parser::FunctionbodyContext::getRuleIndex() const
{
	return CPP14Parser::RuleFunctionbody;//688
}

void CPP14Parser::FunctionbodyContext::copyFrom(FunctionbodyContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::FunctionbodyContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<FunctionbodyContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::FunctionbodyContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::FunctionbodyContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::FunctionbodyContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitFunctionbody(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::FunctionbodyContext* CPP14Parser::functionbody( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<FunctionbodyContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 280, CPP14Parser::RuleFunctionbody);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1944);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 231, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(1934);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Colon)
			{
				setState(1933); //951
				ctorinitializer(ctx);
			}
			setState(1936); //951
			compoundstatement(ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(1937); //951
			functiontryblock(ctx);
			break;
		}

		case 3:
		{
			enterOuterAlt(ctx, 3);
			setState(1938);//958
			match(CPP14Parser::Assign,ctx);
			setState(1939);//958
			match(CPP14Parser::Default,ctx);
			setState(1940);//958
			match(CPP14Parser::Semi,ctx);
			break;
		}

		case 4:
		{
			enterOuterAlt(ctx, 4);
			setState(1941);//958
			match(CPP14Parser::Assign,ctx);
			setState(1942);//958
			match(CPP14Parser::Delete,ctx);
			setState(1943);//958
			match(CPP14Parser::Semi,ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::FunctionbodyContext> CPP14Parser::parsefunctionbody()
{
	functionbody();
	auto result = std::unique_ptr<FunctionbodyContext>(dynamic_cast<FunctionbodyContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- InitializerContext ------------------------------------------------------------------

CPP14Parser::InitializerContext::InitializerContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::BraceorequalinitializerContext* CPP14Parser::InitializerContext::braceorequalinitializer()
{
	return getRuleContext<CPP14Parser::BraceorequalinitializerContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::InitializerContext::LeftParen()
{
	return getToken(CPP14Parser::LeftParen, 0);
}

CPP14Parser::ExpressionlistContext* CPP14Parser::InitializerContext::expressionlist()
{
	return getRuleContext<CPP14Parser::ExpressionlistContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::InitializerContext::RightParen()
{
	return getToken(CPP14Parser::RightParen, 0);
}


size_t CPP14Parser::InitializerContext::getRuleIndex() const
{
	return CPP14Parser::RuleInitializer;//688
}

void CPP14Parser::InitializerContext::copyFrom(InitializerContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::InitializerContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<InitializerContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::InitializerContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::InitializerContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::InitializerContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitInitializer(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::InitializerContext* CPP14Parser::initializer( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<InitializerContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 282, CPP14Parser::RuleInitializer);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1951);//750
		_errHandler->sync(this, ctx);
		switch (_input->LA(1))
		{
			case CPP14Parser::LeftBrace:
			case CPP14Parser::Assign:
			{
				enterOuterAlt(ctx, 1);
				setState(1946); //951
				braceorequalinitializer(ctx);
				break;
			}

			case CPP14Parser::LeftParen:
			{
				enterOuterAlt(ctx, 2);
				setState(1947);//958
				match(CPP14Parser::LeftParen,ctx);
				setState(1948); //951
				expressionlist(ctx);
				setState(1949);//958
				match(CPP14Parser::RightParen,ctx);
				break;
			}

		default:
			throw NoViableAltException(this, ctx);
		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::InitializerContext> CPP14Parser::parseinitializer()
{
	initializer();
	auto result = std::unique_ptr<InitializerContext>(dynamic_cast<InitializerContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- BraceorequalinitializerContext ------------------------------------------------------------------

CPP14Parser::BraceorequalinitializerContext::BraceorequalinitializerContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::BraceorequalinitializerContext::Assign()
{
	return getToken(CPP14Parser::Assign, 0);
}

CPP14Parser::InitializerclauseContext* CPP14Parser::BraceorequalinitializerContext::initializerclause()
{
	return getRuleContext<CPP14Parser::InitializerclauseContext>(0);//1165
}

CPP14Parser::BracedinitlistContext* CPP14Parser::BraceorequalinitializerContext::bracedinitlist()
{
	return getRuleContext<CPP14Parser::BracedinitlistContext>(0);//1165
}


size_t CPP14Parser::BraceorequalinitializerContext::getRuleIndex() const
{
	return CPP14Parser::RuleBraceorequalinitializer;//688
}

void CPP14Parser::BraceorequalinitializerContext::copyFrom(BraceorequalinitializerContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::BraceorequalinitializerContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<BraceorequalinitializerContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::BraceorequalinitializerContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::BraceorequalinitializerContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::BraceorequalinitializerContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitBraceorequalinitializer(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::BraceorequalinitializerContext* CPP14Parser::braceorequalinitializer( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<BraceorequalinitializerContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 284, CPP14Parser::RuleBraceorequalinitializer);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1956);//750
		_errHandler->sync(this, ctx);
		switch (_input->LA(1))
		{
			case CPP14Parser::Assign:
			{
				enterOuterAlt(ctx, 1);
				setState(1953);//958
				match(CPP14Parser::Assign,ctx);
				setState(1954); //951
				initializerclause(ctx);
				break;
			}

			case CPP14Parser::LeftBrace:
			{
				enterOuterAlt(ctx, 2);
				setState(1955); //951
				bracedinitlist(ctx);
				break;
			}

		default:
			throw NoViableAltException(this, ctx);
		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::BraceorequalinitializerContext> CPP14Parser::parsebraceorequalinitializer()
{
	braceorequalinitializer();
	auto result = std::unique_ptr<BraceorequalinitializerContext>(dynamic_cast<BraceorequalinitializerContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- InitializerclauseContext ------------------------------------------------------------------

CPP14Parser::InitializerclauseContext::InitializerclauseContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::AssignmentexpressionContext* CPP14Parser::InitializerclauseContext::assignmentexpression()
{
	return getRuleContext<CPP14Parser::AssignmentexpressionContext>(0);//1165
}

CPP14Parser::BracedinitlistContext* CPP14Parser::InitializerclauseContext::bracedinitlist()
{
	return getRuleContext<CPP14Parser::BracedinitlistContext>(0);//1165
}


size_t CPP14Parser::InitializerclauseContext::getRuleIndex() const
{
	return CPP14Parser::RuleInitializerclause;//688
}

void CPP14Parser::InitializerclauseContext::copyFrom(InitializerclauseContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::InitializerclauseContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<InitializerclauseContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::InitializerclauseContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::InitializerclauseContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::InitializerclauseContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitInitializerclause(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::InitializerclauseContext* CPP14Parser::initializerclause( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<InitializerclauseContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 286, CPP14Parser::RuleInitializerclause);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1960);//750
		_errHandler->sync(this, ctx);
		switch (_input->LA(1))
		{
			case CPP14Parser::T__0:
			case CPP14Parser::T__1:
			case CPP14Parser::Alignof:
			case CPP14Parser::Auto:
			case CPP14Parser::Bool:
			case CPP14Parser::Char:
			case CPP14Parser::Char16:
			case CPP14Parser::Char32:
			case CPP14Parser::Const_cast:
			case CPP14Parser::Decltype:
			case CPP14Parser::Delete:
			case CPP14Parser::Double:
			case CPP14Parser::Dynamic_cast:
			case CPP14Parser::False:
			case CPP14Parser::Float:
			case CPP14Parser::Int:
			case CPP14Parser::Long:
			case CPP14Parser::New:
			case CPP14Parser::Noexcept:
			case CPP14Parser::Nullptr:
			case CPP14Parser::Operator:
			case CPP14Parser::Reinterpret_cast:
			case CPP14Parser::Short:
			case CPP14Parser::Signed:
			case CPP14Parser::Sizeof:
			case CPP14Parser::Static_cast:
			case CPP14Parser::This:
			case CPP14Parser::Throw:
			case CPP14Parser::True:
			case CPP14Parser::Typeid_:
			case CPP14Parser::Typename_:
			case CPP14Parser::Unsigned:
			case CPP14Parser::Void:
			case CPP14Parser::Wchar:
			case CPP14Parser::LeftParen:
			case CPP14Parser::LeftBracket:
			case CPP14Parser::Plus:
			case CPP14Parser::Minus:
			case CPP14Parser::Star:
			case CPP14Parser::And:
			case CPP14Parser::Or:
			case CPP14Parser::Tilde:
			case CPP14Parser::PlusPlus:
			case CPP14Parser::MinusMinus:
			case CPP14Parser::Doublecolon:
			case CPP14Parser::Identifier:
			case CPP14Parser::Integerliteral:
			case CPP14Parser::Characterliteral:
			case CPP14Parser::Floatingliteral:
			case CPP14Parser::Stringliteral:
			case CPP14Parser::Userdefinedintegerliteral:
			case CPP14Parser::Userdefinedfloatingliteral:
			case CPP14Parser::Userdefinedstringliteral:
			case CPP14Parser::Userdefinedcharacterliteral:
			{
				enterOuterAlt(ctx, 1);
				setState(1958); //951
				assignmentexpression(ctx);
				break;
			}

			case CPP14Parser::LeftBrace:
			{
				enterOuterAlt(ctx, 2);
				setState(1959); //951
				bracedinitlist(ctx);
				break;
			}

		default:
			throw NoViableAltException(this, ctx);
		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::InitializerclauseContext> CPP14Parser::parseinitializerclause()
{
	initializerclause();
	auto result = std::unique_ptr<InitializerclauseContext>(dynamic_cast<InitializerclauseContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- InitializerlistContext ------------------------------------------------------------------

CPP14Parser::InitializerlistContext::InitializerlistContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::InitializerclauseContext* CPP14Parser::InitializerlistContext::initializerclause()
{
	return getRuleContext<CPP14Parser::InitializerclauseContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::InitializerlistContext::Ellipsis()
{
	return getToken(CPP14Parser::Ellipsis, 0);
}

CPP14Parser::InitializerlistContext* CPP14Parser::InitializerlistContext::initializerlist()
{
	return getRuleContext<CPP14Parser::InitializerlistContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::InitializerlistContext::Comma()
{
	return getToken(CPP14Parser::Comma, 0);
}


size_t CPP14Parser::InitializerlistContext::getRuleIndex() const
{
	return CPP14Parser::RuleInitializerlist;//688
}

void CPP14Parser::InitializerlistContext::copyFrom(InitializerlistContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::InitializerlistContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<InitializerlistContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::InitializerlistContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::InitializerlistContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::InitializerlistContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitInitializerlist(this);
	else
		return visitor->visitChildren(this);
}


CPP14Parser::InitializerlistContext* CPP14Parser::initializerlist()
{
	 return initializerlist(0, nullptr);//600
}

CPP14Parser::InitializerlistContext* CPP14Parser::initializerlist(int precedence, antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	antlr4::ParserRuleContext *parentContext = parent;
	size_t parentState = getState();
	auto _localctx = std::make_unique<InitializerlistContext>(parentContext, parentState);//610
	auto ctx = _localctx.get();//609
	size_t startState = 288;
	enterRecursionRule(ctx, 288, CPP14Parser::RuleInitializerlist, precedence);

		

	auto onExit = finally([=,&_localctx]
{
		unrollRecursionContexts(parentContext, std::move(_localctx));
	});
	try
{
		size_t alt;
		enterOuterAlt(ctx, 1);
		setState(1963); //951
		initializerclause(ctx);
		setState(1965);//848
		_errHandler->sync(this, ctx);

		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 235, ctx))
		{
		case 1:
		{
			setState(1964);//958
			match(CPP14Parser::Ellipsis,ctx);
			break;
		}

		}
		ctx->stop = _input->LT(-1);
		setState(1975);//865
		_errHandler->sync(this, ctx);
		alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 237, ctx);
		while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
		{
			if (alt == 1)
		{
				if (!_parseListeners.empty())
					triggerExitRuleEvent(ctx);

				auto tmpContext = std::make_unique<InitializerlistContext>(parentContext, parentState);
				pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleInitializerlist);//1240
				_localctx = std::move(tmpContext);
				ctx = _localctx.get();
				setState(1967);//1002

				if (!(precpred(nullptr, 1))) throw FailedPredicateException(this, "precpred(nullptr, 1)", ctx);
				setState(1968);//958
				match(CPP14Parser::Comma,ctx);
				setState(1969); //951
				initializerclause(ctx);
				setState(1971);//848
				_errHandler->sync(this, ctx);

				switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 236, ctx))
				{
				case 1:
				{
					setState(1970);//958
					match(CPP14Parser::Ellipsis,ctx);
					break;
				}

				} 
			}
			setState(1977);//875
			_errHandler->sync(this, ctx);
			alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 237, ctx);
		}
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		_localctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}
	onExit();
	return ctx;
}

std::unique_ptr< CPP14Parser::InitializerlistContext> CPP14Parser::parseinitializerlist()
{
	initializerlist();
	auto result = std::unique_ptr<InitializerlistContext>(dynamic_cast<InitializerlistContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}

//----------------- BracedinitlistContext ------------------------------------------------------------------

CPP14Parser::BracedinitlistContext::BracedinitlistContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::BracedinitlistContext::LeftBrace()
{
	return getToken(CPP14Parser::LeftBrace, 0);
}

CPP14Parser::InitializerlistContext* CPP14Parser::BracedinitlistContext::initializerlist()
{
	return getRuleContext<CPP14Parser::InitializerlistContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::BracedinitlistContext::RightBrace()
{
	return getToken(CPP14Parser::RightBrace, 0);
}

tree::TerminalNode* CPP14Parser::BracedinitlistContext::Comma()
{
	return getToken(CPP14Parser::Comma, 0);
}


size_t CPP14Parser::BracedinitlistContext::getRuleIndex() const
{
	return CPP14Parser::RuleBracedinitlist;//688
}

void CPP14Parser::BracedinitlistContext::copyFrom(BracedinitlistContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::BracedinitlistContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<BracedinitlistContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::BracedinitlistContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::BracedinitlistContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::BracedinitlistContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitBracedinitlist(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::BracedinitlistContext* CPP14Parser::bracedinitlist( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<BracedinitlistContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 290, CPP14Parser::RuleBracedinitlist);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1987);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 239, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(1978);//958
			match(CPP14Parser::LeftBrace,ctx);
			setState(1979); //951
			initializerlist(0,ctx);
			setState(1981);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Comma)
			{
				setState(1980);//958
				match(CPP14Parser::Comma,ctx);
			}
			setState(1983);//958
			match(CPP14Parser::RightBrace,ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(1985);//958
			match(CPP14Parser::LeftBrace,ctx);
			setState(1986);//958
			match(CPP14Parser::RightBrace,ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::BracedinitlistContext> CPP14Parser::parsebracedinitlist()
{
	bracedinitlist();
	auto result = std::unique_ptr<BracedinitlistContext>(dynamic_cast<BracedinitlistContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- ClassnameContext ------------------------------------------------------------------

CPP14Parser::ClassnameContext::ClassnameContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::ClassnameContext::Identifier()
{
	return getToken(CPP14Parser::Identifier, 0);
}

CPP14Parser::SimpletemplateidContext* CPP14Parser::ClassnameContext::simpletemplateid()
{
	return getRuleContext<CPP14Parser::SimpletemplateidContext>(0);//1165
}


size_t CPP14Parser::ClassnameContext::getRuleIndex() const
{
	return CPP14Parser::RuleClassname;//688
}

void CPP14Parser::ClassnameContext::copyFrom(ClassnameContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::ClassnameContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<ClassnameContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::ClassnameContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::ClassnameContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::ClassnameContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitClassname(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::ClassnameContext* CPP14Parser::classname( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<ClassnameContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 292, CPP14Parser::RuleClassname);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(1991);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 240, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(1989);//958
			match(CPP14Parser::Identifier,ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(1990); //951
			simpletemplateid(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::ClassnameContext> CPP14Parser::parseclassname()
{
	classname();
	auto result = std::unique_ptr<ClassnameContext>(dynamic_cast<ClassnameContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- ClassspecifierContext ------------------------------------------------------------------

CPP14Parser::ClassspecifierContext::ClassspecifierContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::ClassheadContext* CPP14Parser::ClassspecifierContext::classhead()
{
	return getRuleContext<CPP14Parser::ClassheadContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::ClassspecifierContext::LeftBrace()
{
	return getToken(CPP14Parser::LeftBrace, 0);
}

tree::TerminalNode* CPP14Parser::ClassspecifierContext::RightBrace()
{
	return getToken(CPP14Parser::RightBrace, 0);
}

CPP14Parser::MemberspecificationContext* CPP14Parser::ClassspecifierContext::memberspecification()
{
	return getRuleContext<CPP14Parser::MemberspecificationContext>(0);//1165
}


size_t CPP14Parser::ClassspecifierContext::getRuleIndex() const
{
	return CPP14Parser::RuleClassspecifier;//688
}

void CPP14Parser::ClassspecifierContext::copyFrom(ClassspecifierContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::ClassspecifierContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<ClassspecifierContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::ClassspecifierContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::ClassspecifierContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::ClassspecifierContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitClassspecifier(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::ClassspecifierContext* CPP14Parser::classspecifier( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<ClassspecifierContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 294, CPP14Parser::RuleClassspecifier);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(1993); //951
		classhead(ctx);
		setState(1994);//958
		match(CPP14Parser::LeftBrace,ctx);
		setState(1996);//788
		_errHandler->sync(this, ctx);

		_la = _input->LA(1);
		if (((((_la - 3) & ~ 0x3fULL) == 0) &&
			((1ULL << (_la - 3)) & ((1ULL << (CPP14Parser::T__2 - 3))
			| (1ULL << (CPP14Parser::Alignas - 3))
			| (1ULL << (CPP14Parser::Auto - 3))
			| (1ULL << (CPP14Parser::Bool - 3))
			| (1ULL << (CPP14Parser::Char - 3))
			| (1ULL << (CPP14Parser::Char16 - 3))
			| (1ULL << (CPP14Parser::Char32 - 3))
			| (1ULL << (CPP14Parser::Class - 3))
			| (1ULL << (CPP14Parser::Const - 3))
			| (1ULL << (CPP14Parser::Constexpr - 3))
			| (1ULL << (CPP14Parser::Decltype - 3))
			| (1ULL << (CPP14Parser::Double - 3))
			| (1ULL << (CPP14Parser::Enum - 3))
			| (1ULL << (CPP14Parser::Explicit - 3))
			| (1ULL << (CPP14Parser::Extern - 3))
			| (1ULL << (CPP14Parser::Float - 3))
			| (1ULL << (CPP14Parser::Friend - 3))
			| (1ULL << (CPP14Parser::Inline - 3))
			| (1ULL << (CPP14Parser::Int - 3))
			| (1ULL << (CPP14Parser::Long - 3))
			| (1ULL << (CPP14Parser::Mutable - 3))
			| (1ULL << (CPP14Parser::Operator - 3))
			| (1ULL << (CPP14Parser::Private - 3))
			| (1ULL << (CPP14Parser::Protected - 3))
			| (1ULL << (CPP14Parser::Public - 3))
			| (1ULL << (CPP14Parser::Register - 3))
			| (1ULL << (CPP14Parser::Short - 3))
			| (1ULL << (CPP14Parser::Signed - 3))
			| (1ULL << (CPP14Parser::Static - 3))
			| (1ULL << (CPP14Parser::Static_assert - 3))
			| (1ULL << (CPP14Parser::Struct - 3)))) != 0) || ((((_la - 67) & ~ 0x3fULL) == 0) &&
			((1ULL << (_la - 67)) & ((1ULL << (CPP14Parser::Template - 67))
			| (1ULL << (CPP14Parser::Thread_local - 67))
			| (1ULL << (CPP14Parser::Typedef - 67))
			| (1ULL << (CPP14Parser::Typename_ - 67))
			| (1ULL << (CPP14Parser::Union - 67))
			| (1ULL << (CPP14Parser::Unsigned - 67))
			| (1ULL << (CPP14Parser::Using - 67))
			| (1ULL << (CPP14Parser::Virtual - 67))
			| (1ULL << (CPP14Parser::Void - 67))
			| (1ULL << (CPP14Parser::Volatile - 67))
			| (1ULL << (CPP14Parser::Wchar - 67))
			| (1ULL << (CPP14Parser::LeftParen - 67))
			| (1ULL << (CPP14Parser::LeftBracket - 67))
			| (1ULL << (CPP14Parser::Star - 67))
			| (1ULL << (CPP14Parser::And - 67))
			| (1ULL << (CPP14Parser::Tilde - 67))
			| (1ULL << (CPP14Parser::Colon - 67))
			| (1ULL << (CPP14Parser::Doublecolon - 67))
			| (1ULL << (CPP14Parser::Semi - 67))
			| (1ULL << (CPP14Parser::Ellipsis - 67))
			| (1ULL << (CPP14Parser::Identifier - 67)))) != 0))
		{
			setState(1995); //951
			memberspecification(ctx);
		}
		setState(1998);//958
		match(CPP14Parser::RightBrace,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::ClassspecifierContext> CPP14Parser::parseclassspecifier()
{
	classspecifier();
	auto result = std::unique_ptr<ClassspecifierContext>(dynamic_cast<ClassspecifierContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- ClassheadContext ------------------------------------------------------------------

CPP14Parser::ClassheadContext::ClassheadContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::ClasskeyContext* CPP14Parser::ClassheadContext::classkey()
{
	return getRuleContext<CPP14Parser::ClasskeyContext>(0);//1165
}

CPP14Parser::ClassheadnameContext* CPP14Parser::ClassheadContext::classheadname()
{
	return getRuleContext<CPP14Parser::ClassheadnameContext>(0);//1165
}

CPP14Parser::AttributespecifierseqContext* CPP14Parser::ClassheadContext::attributespecifierseq()
{
	return getRuleContext<CPP14Parser::AttributespecifierseqContext>(0);//1165
}

CPP14Parser::ClassvirtspecifierContext* CPP14Parser::ClassheadContext::classvirtspecifier()
{
	return getRuleContext<CPP14Parser::ClassvirtspecifierContext>(0);//1165
}

CPP14Parser::BaseclauseContext* CPP14Parser::ClassheadContext::baseclause()
{
	return getRuleContext<CPP14Parser::BaseclauseContext>(0);//1165
}


size_t CPP14Parser::ClassheadContext::getRuleIndex() const
{
	return CPP14Parser::RuleClasshead;//688
}

void CPP14Parser::ClassheadContext::copyFrom(ClassheadContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::ClassheadContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<ClassheadContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::ClassheadContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::ClassheadContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::ClassheadContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitClasshead(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::ClassheadContext* CPP14Parser::classhead( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<ClassheadContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 296, CPP14Parser::RuleClasshead);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(2018);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 247, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(2000); //951
			classkey(ctx);
			setState(2002);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Alignas || _la == CPP14Parser::LeftBracket)
			{
				setState(2001); //951
				attributespecifierseq(0,ctx);
			}
			setState(2004); //951
			classheadname(ctx);
			setState(2006);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Final)
			{
				setState(2005); //951
				classvirtspecifier(ctx);
			}
			setState(2009);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Colon)
			{
				setState(2008); //951
				baseclause(ctx);
			}
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(2011); //951
			classkey(ctx);
			setState(2013);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Alignas || _la == CPP14Parser::LeftBracket)
			{
				setState(2012); //951
				attributespecifierseq(0,ctx);
			}
			setState(2016);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Colon)
			{
				setState(2015); //951
				baseclause(ctx);
			}
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::ClassheadContext> CPP14Parser::parseclasshead()
{
	classhead();
	auto result = std::unique_ptr<ClassheadContext>(dynamic_cast<ClassheadContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- ClassheadnameContext ------------------------------------------------------------------

CPP14Parser::ClassheadnameContext::ClassheadnameContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::ClassnameContext* CPP14Parser::ClassheadnameContext::classname()
{
	return getRuleContext<CPP14Parser::ClassnameContext>(0);//1165
}

CPP14Parser::NestednamespecifierContext* CPP14Parser::ClassheadnameContext::nestednamespecifier()
{
	return getRuleContext<CPP14Parser::NestednamespecifierContext>(0);//1165
}


size_t CPP14Parser::ClassheadnameContext::getRuleIndex() const
{
	return CPP14Parser::RuleClassheadname;//688
}

void CPP14Parser::ClassheadnameContext::copyFrom(ClassheadnameContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::ClassheadnameContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<ClassheadnameContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::ClassheadnameContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::ClassheadnameContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::ClassheadnameContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitClassheadname(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::ClassheadnameContext* CPP14Parser::classheadname( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<ClassheadnameContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 298, CPP14Parser::RuleClassheadname);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(2021);//848
		_errHandler->sync(this, ctx);

		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 248, ctx))
		{
		case 1:
		{
			setState(2020); //951
			nestednamespecifier(0,ctx);
			break;
		}

		}
		setState(2023); //951
		classname(ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::ClassheadnameContext> CPP14Parser::parseclassheadname()
{
	classheadname();
	auto result = std::unique_ptr<ClassheadnameContext>(dynamic_cast<ClassheadnameContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- ClassvirtspecifierContext ------------------------------------------------------------------

CPP14Parser::ClassvirtspecifierContext::ClassvirtspecifierContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::ClassvirtspecifierContext::Final()
{
	return getToken(CPP14Parser::Final, 0);
}


size_t CPP14Parser::ClassvirtspecifierContext::getRuleIndex() const
{
	return CPP14Parser::RuleClassvirtspecifier;//688
}

void CPP14Parser::ClassvirtspecifierContext::copyFrom(ClassvirtspecifierContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::ClassvirtspecifierContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<ClassvirtspecifierContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::ClassvirtspecifierContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::ClassvirtspecifierContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::ClassvirtspecifierContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitClassvirtspecifier(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::ClassvirtspecifierContext* CPP14Parser::classvirtspecifier( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<ClassvirtspecifierContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 300, CPP14Parser::RuleClassvirtspecifier);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(2025);//958
		match(CPP14Parser::Final,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::ClassvirtspecifierContext> CPP14Parser::parseclassvirtspecifier()
{
	classvirtspecifier();
	auto result = std::unique_ptr<ClassvirtspecifierContext>(dynamic_cast<ClassvirtspecifierContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- ClasskeyContext ------------------------------------------------------------------

CPP14Parser::ClasskeyContext::ClasskeyContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::ClasskeyContext::Class()
{
	return getToken(CPP14Parser::Class, 0);
}

tree::TerminalNode* CPP14Parser::ClasskeyContext::Struct()
{
	return getToken(CPP14Parser::Struct, 0);
}

tree::TerminalNode* CPP14Parser::ClasskeyContext::Union()
{
	return getToken(CPP14Parser::Union, 0);
}


size_t CPP14Parser::ClasskeyContext::getRuleIndex() const
{
	return CPP14Parser::RuleClasskey;//688
}

void CPP14Parser::ClasskeyContext::copyFrom(ClasskeyContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::ClasskeyContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<ClasskeyContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::ClasskeyContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::ClasskeyContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::ClasskeyContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitClasskey(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::ClasskeyContext* CPP14Parser::classkey( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<ClasskeyContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 302, CPP14Parser::RuleClasskey);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(2027);//970
		_la = _input->LA(1);
		if (!(((((_la - 20) & ~ 0x3fULL) == 0) &&
			((1ULL << (_la - 20)) & ((1ULL << (CPP14Parser::Class - 20))
			| (1ULL << (CPP14Parser::Struct - 20))
			| (1ULL << (CPP14Parser::Union - 20)))) != 0)))
		{
		_errHandler->recoverInline(this, ctx);
		}
		else
		{
			_errHandler->reportMatch(this);
			consume(ctx);
		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::ClasskeyContext> CPP14Parser::parseclasskey()
{
	classkey();
	auto result = std::unique_ptr<ClasskeyContext>(dynamic_cast<ClasskeyContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- MemberspecificationContext ------------------------------------------------------------------

CPP14Parser::MemberspecificationContext::MemberspecificationContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::MemberdeclarationContext* CPP14Parser::MemberspecificationContext::memberdeclaration()
{
	return getRuleContext<CPP14Parser::MemberdeclarationContext>(0);//1165
}

CPP14Parser::MemberspecificationContext* CPP14Parser::MemberspecificationContext::memberspecification()
{
	return getRuleContext<CPP14Parser::MemberspecificationContext>(0);//1165
}

CPP14Parser::AccessspecifierContext* CPP14Parser::MemberspecificationContext::accessspecifier()
{
	return getRuleContext<CPP14Parser::AccessspecifierContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::MemberspecificationContext::Colon()
{
	return getToken(CPP14Parser::Colon, 0);
}


size_t CPP14Parser::MemberspecificationContext::getRuleIndex() const
{
	return CPP14Parser::RuleMemberspecification;//688
}

void CPP14Parser::MemberspecificationContext::copyFrom(MemberspecificationContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::MemberspecificationContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<MemberspecificationContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::MemberspecificationContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::MemberspecificationContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::MemberspecificationContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitMemberspecification(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::MemberspecificationContext* CPP14Parser::memberspecification( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<MemberspecificationContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 304, CPP14Parser::RuleMemberspecification);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(2038);//750
		_errHandler->sync(this, ctx);
		switch (_input->LA(1))
		{
			case CPP14Parser::T__2:
			case CPP14Parser::Alignas:
			case CPP14Parser::Auto:
			case CPP14Parser::Bool:
			case CPP14Parser::Char:
			case CPP14Parser::Char16:
			case CPP14Parser::Char32:
			case CPP14Parser::Class:
			case CPP14Parser::Const:
			case CPP14Parser::Constexpr:
			case CPP14Parser::Decltype:
			case CPP14Parser::Double:
			case CPP14Parser::Enum:
			case CPP14Parser::Explicit:
			case CPP14Parser::Extern:
			case CPP14Parser::Float:
			case CPP14Parser::Friend:
			case CPP14Parser::Inline:
			case CPP14Parser::Int:
			case CPP14Parser::Long:
			case CPP14Parser::Mutable:
			case CPP14Parser::Operator:
			case CPP14Parser::Register:
			case CPP14Parser::Short:
			case CPP14Parser::Signed:
			case CPP14Parser::Static:
			case CPP14Parser::Static_assert:
			case CPP14Parser::Struct:
			case CPP14Parser::Template:
			case CPP14Parser::Thread_local:
			case CPP14Parser::Typedef:
			case CPP14Parser::Typename_:
			case CPP14Parser::Union:
			case CPP14Parser::Unsigned:
			case CPP14Parser::Using:
			case CPP14Parser::Virtual:
			case CPP14Parser::Void:
			case CPP14Parser::Volatile:
			case CPP14Parser::Wchar:
			case CPP14Parser::LeftParen:
			case CPP14Parser::LeftBracket:
			case CPP14Parser::Star:
			case CPP14Parser::And:
			case CPP14Parser::Tilde:
			case CPP14Parser::Colon:
			case CPP14Parser::Doublecolon:
			case CPP14Parser::Semi:
			case CPP14Parser::Ellipsis:
			case CPP14Parser::Identifier:
			{
				enterOuterAlt(ctx, 1);
				setState(2029); //951
				memberdeclaration(ctx);
				setState(2031);//788
				_errHandler->sync(this, ctx);

				_la = _input->LA(1);
				if (((((_la - 3) & ~ 0x3fULL) == 0) &&
					((1ULL << (_la - 3)) & ((1ULL << (CPP14Parser::T__2 - 3))
					| (1ULL << (CPP14Parser::Alignas - 3))
					| (1ULL << (CPP14Parser::Auto - 3))
					| (1ULL << (CPP14Parser::Bool - 3))
					| (1ULL << (CPP14Parser::Char - 3))
					| (1ULL << (CPP14Parser::Char16 - 3))
					| (1ULL << (CPP14Parser::Char32 - 3))
					| (1ULL << (CPP14Parser::Class - 3))
					| (1ULL << (CPP14Parser::Const - 3))
					| (1ULL << (CPP14Parser::Constexpr - 3))
					| (1ULL << (CPP14Parser::Decltype - 3))
					| (1ULL << (CPP14Parser::Double - 3))
					| (1ULL << (CPP14Parser::Enum - 3))
					| (1ULL << (CPP14Parser::Explicit - 3))
					| (1ULL << (CPP14Parser::Extern - 3))
					| (1ULL << (CPP14Parser::Float - 3))
					| (1ULL << (CPP14Parser::Friend - 3))
					| (1ULL << (CPP14Parser::Inline - 3))
					| (1ULL << (CPP14Parser::Int - 3))
					| (1ULL << (CPP14Parser::Long - 3))
					| (1ULL << (CPP14Parser::Mutable - 3))
					| (1ULL << (CPP14Parser::Operator - 3))
					| (1ULL << (CPP14Parser::Private - 3))
					| (1ULL << (CPP14Parser::Protected - 3))
					| (1ULL << (CPP14Parser::Public - 3))
					| (1ULL << (CPP14Parser::Register - 3))
					| (1ULL << (CPP14Parser::Short - 3))
					| (1ULL << (CPP14Parser::Signed - 3))
					| (1ULL << (CPP14Parser::Static - 3))
					| (1ULL << (CPP14Parser::Static_assert - 3))
					| (1ULL << (CPP14Parser::Struct - 3)))) != 0) || ((((_la - 67) & ~ 0x3fULL) == 0) &&
					((1ULL << (_la - 67)) & ((1ULL << (CPP14Parser::Template - 67))
					| (1ULL << (CPP14Parser::Thread_local - 67))
					| (1ULL << (CPP14Parser::Typedef - 67))
					| (1ULL << (CPP14Parser::Typename_ - 67))
					| (1ULL << (CPP14Parser::Union - 67))
					| (1ULL << (CPP14Parser::Unsigned - 67))
					| (1ULL << (CPP14Parser::Using - 67))
					| (1ULL << (CPP14Parser::Virtual - 67))
					| (1ULL << (CPP14Parser::Void - 67))
					| (1ULL << (CPP14Parser::Volatile - 67))
					| (1ULL << (CPP14Parser::Wchar - 67))
					| (1ULL << (CPP14Parser::LeftParen - 67))
					| (1ULL << (CPP14Parser::LeftBracket - 67))
					| (1ULL << (CPP14Parser::Star - 67))
					| (1ULL << (CPP14Parser::And - 67))
					| (1ULL << (CPP14Parser::Tilde - 67))
					| (1ULL << (CPP14Parser::Colon - 67))
					| (1ULL << (CPP14Parser::Doublecolon - 67))
					| (1ULL << (CPP14Parser::Semi - 67))
					| (1ULL << (CPP14Parser::Ellipsis - 67))
					| (1ULL << (CPP14Parser::Identifier - 67)))) != 0))
				{
					setState(2030); //951
					memberspecification(ctx);
				}
				break;
			}

			case CPP14Parser::Private:
			case CPP14Parser::Protected:
			case CPP14Parser::Public:
			{
				enterOuterAlt(ctx, 2);
				setState(2033); //951
				accessspecifier(ctx);
				setState(2034);//958
				match(CPP14Parser::Colon,ctx);
				setState(2036);//788
				_errHandler->sync(this, ctx);

				_la = _input->LA(1);
				if (((((_la - 3) & ~ 0x3fULL) == 0) &&
					((1ULL << (_la - 3)) & ((1ULL << (CPP14Parser::T__2 - 3))
					| (1ULL << (CPP14Parser::Alignas - 3))
					| (1ULL << (CPP14Parser::Auto - 3))
					| (1ULL << (CPP14Parser::Bool - 3))
					| (1ULL << (CPP14Parser::Char - 3))
					| (1ULL << (CPP14Parser::Char16 - 3))
					| (1ULL << (CPP14Parser::Char32 - 3))
					| (1ULL << (CPP14Parser::Class - 3))
					| (1ULL << (CPP14Parser::Const - 3))
					| (1ULL << (CPP14Parser::Constexpr - 3))
					| (1ULL << (CPP14Parser::Decltype - 3))
					| (1ULL << (CPP14Parser::Double - 3))
					| (1ULL << (CPP14Parser::Enum - 3))
					| (1ULL << (CPP14Parser::Explicit - 3))
					| (1ULL << (CPP14Parser::Extern - 3))
					| (1ULL << (CPP14Parser::Float - 3))
					| (1ULL << (CPP14Parser::Friend - 3))
					| (1ULL << (CPP14Parser::Inline - 3))
					| (1ULL << (CPP14Parser::Int - 3))
					| (1ULL << (CPP14Parser::Long - 3))
					| (1ULL << (CPP14Parser::Mutable - 3))
					| (1ULL << (CPP14Parser::Operator - 3))
					| (1ULL << (CPP14Parser::Private - 3))
					| (1ULL << (CPP14Parser::Protected - 3))
					| (1ULL << (CPP14Parser::Public - 3))
					| (1ULL << (CPP14Parser::Register - 3))
					| (1ULL << (CPP14Parser::Short - 3))
					| (1ULL << (CPP14Parser::Signed - 3))
					| (1ULL << (CPP14Parser::Static - 3))
					| (1ULL << (CPP14Parser::Static_assert - 3))
					| (1ULL << (CPP14Parser::Struct - 3)))) != 0) || ((((_la - 67) & ~ 0x3fULL) == 0) &&
					((1ULL << (_la - 67)) & ((1ULL << (CPP14Parser::Template - 67))
					| (1ULL << (CPP14Parser::Thread_local - 67))
					| (1ULL << (CPP14Parser::Typedef - 67))
					| (1ULL << (CPP14Parser::Typename_ - 67))
					| (1ULL << (CPP14Parser::Union - 67))
					| (1ULL << (CPP14Parser::Unsigned - 67))
					| (1ULL << (CPP14Parser::Using - 67))
					| (1ULL << (CPP14Parser::Virtual - 67))
					| (1ULL << (CPP14Parser::Void - 67))
					| (1ULL << (CPP14Parser::Volatile - 67))
					| (1ULL << (CPP14Parser::Wchar - 67))
					| (1ULL << (CPP14Parser::LeftParen - 67))
					| (1ULL << (CPP14Parser::LeftBracket - 67))
					| (1ULL << (CPP14Parser::Star - 67))
					| (1ULL << (CPP14Parser::And - 67))
					| (1ULL << (CPP14Parser::Tilde - 67))
					| (1ULL << (CPP14Parser::Colon - 67))
					| (1ULL << (CPP14Parser::Doublecolon - 67))
					| (1ULL << (CPP14Parser::Semi - 67))
					| (1ULL << (CPP14Parser::Ellipsis - 67))
					| (1ULL << (CPP14Parser::Identifier - 67)))) != 0))
				{
					setState(2035); //951
					memberspecification(ctx);
				}
				break;
			}

		default:
			throw NoViableAltException(this, ctx);
		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::MemberspecificationContext> CPP14Parser::parsememberspecification()
{
	memberspecification();
	auto result = std::unique_ptr<MemberspecificationContext>(dynamic_cast<MemberspecificationContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- MemberdeclarationContext ------------------------------------------------------------------

CPP14Parser::MemberdeclarationContext::MemberdeclarationContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::MemberdeclarationContext::Semi()
{
	return getToken(CPP14Parser::Semi, 0);
}

CPP14Parser::AttributespecifierseqContext* CPP14Parser::MemberdeclarationContext::attributespecifierseq()
{
	return getRuleContext<CPP14Parser::AttributespecifierseqContext>(0);//1165
}

CPP14Parser::DeclspecifierseqContext* CPP14Parser::MemberdeclarationContext::declspecifierseq()
{
	return getRuleContext<CPP14Parser::DeclspecifierseqContext>(0);//1165
}

CPP14Parser::MemberdeclaratorlistContext* CPP14Parser::MemberdeclarationContext::memberdeclaratorlist()
{
	return getRuleContext<CPP14Parser::MemberdeclaratorlistContext>(0);//1165
}

CPP14Parser::FunctiondefinitionContext* CPP14Parser::MemberdeclarationContext::functiondefinition()
{
	return getRuleContext<CPP14Parser::FunctiondefinitionContext>(0);//1165
}

CPP14Parser::UsingdeclarationContext* CPP14Parser::MemberdeclarationContext::usingdeclaration()
{
	return getRuleContext<CPP14Parser::UsingdeclarationContext>(0);//1165
}

CPP14Parser::Static_assertdeclarationContext* CPP14Parser::MemberdeclarationContext::static_assertdeclaration()
{
	return getRuleContext<CPP14Parser::Static_assertdeclarationContext>(0);//1165
}

CPP14Parser::TemplatedeclarationContext* CPP14Parser::MemberdeclarationContext::templatedeclaration()
{
	return getRuleContext<CPP14Parser::TemplatedeclarationContext>(0);//1165
}

CPP14Parser::AliasdeclarationContext* CPP14Parser::MemberdeclarationContext::aliasdeclaration()
{
	return getRuleContext<CPP14Parser::AliasdeclarationContext>(0);//1165
}

CPP14Parser::EmptydeclarationContext* CPP14Parser::MemberdeclarationContext::emptydeclaration()
{
	return getRuleContext<CPP14Parser::EmptydeclarationContext>(0);//1165
}


size_t CPP14Parser::MemberdeclarationContext::getRuleIndex() const
{
	return CPP14Parser::RuleMemberdeclaration;//688
}

void CPP14Parser::MemberdeclarationContext::copyFrom(MemberdeclarationContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::MemberdeclarationContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<MemberdeclarationContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::MemberdeclarationContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::MemberdeclarationContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::MemberdeclarationContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitMemberdeclaration(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::MemberdeclarationContext* CPP14Parser::memberdeclaration( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<MemberdeclarationContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 306, CPP14Parser::RuleMemberdeclaration);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(2056);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 255, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(2041);//848
			_errHandler->sync(this, ctx);

			switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 252, ctx))
			{
			case 1:
			{
				setState(2040); //951
				attributespecifierseq(0,ctx);
				break;
			}

			}
			setState(2044);//848
			_errHandler->sync(this, ctx);

			switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 253, ctx))
			{
			case 1:
			{
				setState(2043); //951
				declspecifierseq(ctx);
				break;
			}

			}
			setState(2047);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if ((((_la & ~ 0x3fULL) == 0) &&
				((1ULL << _la) & ((1ULL << CPP14Parser::T__2)
				| (1ULL << CPP14Parser::Alignas)
				| (1ULL << CPP14Parser::Decltype)
				| (1ULL << CPP14Parser::Operator))) != 0) || ((((_la - 84) & ~ 0x3fULL) == 0) &&
				((1ULL << (_la - 84)) & ((1ULL << (CPP14Parser::LeftParen - 84))
				| (1ULL << (CPP14Parser::LeftBracket - 84))
				| (1ULL << (CPP14Parser::Star - 84))
				| (1ULL << (CPP14Parser::And - 84))
				| (1ULL << (CPP14Parser::Tilde - 84))
				| (1ULL << (CPP14Parser::Colon - 84))
				| (1ULL << (CPP14Parser::Doublecolon - 84))
				| (1ULL << (CPP14Parser::Ellipsis - 84))
				| (1ULL << (CPP14Parser::Identifier - 84)))) != 0))
			{
				setState(2046); //951
				memberdeclaratorlist(0,ctx);
			}
			setState(2049);//958
			match(CPP14Parser::Semi,ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(2050); //951
			functiondefinition(ctx);
			break;
		}

		case 3:
		{
			enterOuterAlt(ctx, 3);
			setState(2051); //951
			usingdeclaration(ctx);
			break;
		}

		case 4:
		{
			enterOuterAlt(ctx, 4);
			setState(2052); //951
			static_assertdeclaration(ctx);
			break;
		}

		case 5:
		{
			enterOuterAlt(ctx, 5);
			setState(2053); //951
			templatedeclaration(ctx);
			break;
		}

		case 6:
		{
			enterOuterAlt(ctx, 6);
			setState(2054); //951
			aliasdeclaration(ctx);
			break;
		}

		case 7:
		{
			enterOuterAlt(ctx, 7);
			setState(2055); //951
			emptydeclaration(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::MemberdeclarationContext> CPP14Parser::parsememberdeclaration()
{
	memberdeclaration();
	auto result = std::unique_ptr<MemberdeclarationContext>(dynamic_cast<MemberdeclarationContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- MemberdeclaratorlistContext ------------------------------------------------------------------

CPP14Parser::MemberdeclaratorlistContext::MemberdeclaratorlistContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::MemberdeclaratorContext* CPP14Parser::MemberdeclaratorlistContext::memberdeclarator()
{
	return getRuleContext<CPP14Parser::MemberdeclaratorContext>(0);//1165
}

CPP14Parser::MemberdeclaratorlistContext* CPP14Parser::MemberdeclaratorlistContext::memberdeclaratorlist()
{
	return getRuleContext<CPP14Parser::MemberdeclaratorlistContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::MemberdeclaratorlistContext::Comma()
{
	return getToken(CPP14Parser::Comma, 0);
}


size_t CPP14Parser::MemberdeclaratorlistContext::getRuleIndex() const
{
	return CPP14Parser::RuleMemberdeclaratorlist;//688
}

void CPP14Parser::MemberdeclaratorlistContext::copyFrom(MemberdeclaratorlistContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::MemberdeclaratorlistContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<MemberdeclaratorlistContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::MemberdeclaratorlistContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::MemberdeclaratorlistContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::MemberdeclaratorlistContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitMemberdeclaratorlist(this);
	else
		return visitor->visitChildren(this);
}


CPP14Parser::MemberdeclaratorlistContext* CPP14Parser::memberdeclaratorlist()
{
	 return memberdeclaratorlist(0, nullptr);//600
}

CPP14Parser::MemberdeclaratorlistContext* CPP14Parser::memberdeclaratorlist(int precedence, antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	antlr4::ParserRuleContext *parentContext = parent;
	size_t parentState = getState();
	auto _localctx = std::make_unique<MemberdeclaratorlistContext>(parentContext, parentState);//610
	auto ctx = _localctx.get();//609
	size_t startState = 308;
	enterRecursionRule(ctx, 308, CPP14Parser::RuleMemberdeclaratorlist, precedence);

		

	auto onExit = finally([=,&_localctx]
{
		unrollRecursionContexts(parentContext, std::move(_localctx));
	});
	try
{
		size_t alt;
		enterOuterAlt(ctx, 1);
		setState(2059); //951
		memberdeclarator(ctx);
		ctx->stop = _input->LT(-1);
		setState(2066);//865
		_errHandler->sync(this, ctx);
		alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 256, ctx);
		while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
		{
			if (alt == 1)
		{
				if (!_parseListeners.empty())
					triggerExitRuleEvent(ctx);

				auto tmpContext = std::make_unique<MemberdeclaratorlistContext>(parentContext, parentState);
				pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleMemberdeclaratorlist);//1240
				_localctx = std::move(tmpContext);
				ctx = _localctx.get();
				setState(2061);//1002

				if (!(precpred(nullptr, 1))) throw FailedPredicateException(this, "precpred(nullptr, 1)", ctx);
				setState(2062);//958
				match(CPP14Parser::Comma,ctx);
				setState(2063); //951
				memberdeclarator(ctx); 
			}
			setState(2068);//875
			_errHandler->sync(this, ctx);
			alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 256, ctx);
		}
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		_localctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}
	onExit();
	return ctx;
}

std::unique_ptr< CPP14Parser::MemberdeclaratorlistContext> CPP14Parser::parsememberdeclaratorlist()
{
	memberdeclaratorlist();
	auto result = std::unique_ptr<MemberdeclaratorlistContext>(dynamic_cast<MemberdeclaratorlistContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}

//----------------- MemberdeclaratorContext ------------------------------------------------------------------

CPP14Parser::MemberdeclaratorContext::MemberdeclaratorContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::DeclaratorContext* CPP14Parser::MemberdeclaratorContext::declarator()
{
	return getRuleContext<CPP14Parser::DeclaratorContext>(0);//1165
}

CPP14Parser::VirtspecifierseqContext* CPP14Parser::MemberdeclaratorContext::virtspecifierseq()
{
	return getRuleContext<CPP14Parser::VirtspecifierseqContext>(0);//1165
}

CPP14Parser::PurespecifierContext* CPP14Parser::MemberdeclaratorContext::purespecifier()
{
	return getRuleContext<CPP14Parser::PurespecifierContext>(0);//1165
}

CPP14Parser::BraceorequalinitializerContext* CPP14Parser::MemberdeclaratorContext::braceorequalinitializer()
{
	return getRuleContext<CPP14Parser::BraceorequalinitializerContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::MemberdeclaratorContext::Colon()
{
	return getToken(CPP14Parser::Colon, 0);
}

CPP14Parser::ConstantexpressionContext* CPP14Parser::MemberdeclaratorContext::constantexpression()
{
	return getRuleContext<CPP14Parser::ConstantexpressionContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::MemberdeclaratorContext::Identifier()
{
	return getToken(CPP14Parser::Identifier, 0);
}

CPP14Parser::AttributespecifierseqContext* CPP14Parser::MemberdeclaratorContext::attributespecifierseq()
{
	return getRuleContext<CPP14Parser::AttributespecifierseqContext>(0);//1165
}


size_t CPP14Parser::MemberdeclaratorContext::getRuleIndex() const
{
	return CPP14Parser::RuleMemberdeclarator;//688
}

void CPP14Parser::MemberdeclaratorContext::copyFrom(MemberdeclaratorContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::MemberdeclaratorContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<MemberdeclaratorContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::MemberdeclaratorContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::MemberdeclaratorContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::MemberdeclaratorContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitMemberdeclarator(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::MemberdeclaratorContext* CPP14Parser::memberdeclarator( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<MemberdeclaratorContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 310, CPP14Parser::RuleMemberdeclarator);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(2088);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 262, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(2069); //951
			declarator(ctx);
			setState(2071);//848
			_errHandler->sync(this, ctx);

			switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 257, ctx))
			{
			case 1:
			{
				setState(2070); //951
				virtspecifierseq(0,ctx);
				break;
			}

			}
			setState(2074);//848
			_errHandler->sync(this, ctx);

			switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 258, ctx))
			{
			case 1:
			{
				setState(2073); //951
				purespecifier(ctx);
				break;
			}

			}
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(2076); //951
			declarator(ctx);
			setState(2078);//848
			_errHandler->sync(this, ctx);

			switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 259, ctx))
			{
			case 1:
			{
				setState(2077); //951
				braceorequalinitializer(ctx);
				break;
			}

			}
			break;
		}

		case 3:
		{
			enterOuterAlt(ctx, 3);
			setState(2081);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Identifier)
			{
				setState(2080);//958
				match(CPP14Parser::Identifier,ctx);
			}
			setState(2084);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Alignas || _la == CPP14Parser::LeftBracket)
			{
				setState(2083); //951
				attributespecifierseq(0,ctx);
			}
			setState(2086);//958
			match(CPP14Parser::Colon,ctx);
			setState(2087); //951
			constantexpression(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::MemberdeclaratorContext> CPP14Parser::parsememberdeclarator()
{
	memberdeclarator();
	auto result = std::unique_ptr<MemberdeclaratorContext>(dynamic_cast<MemberdeclaratorContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- VirtspecifierseqContext ------------------------------------------------------------------

CPP14Parser::VirtspecifierseqContext::VirtspecifierseqContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::VirtspecifierContext* CPP14Parser::VirtspecifierseqContext::virtspecifier()
{
	return getRuleContext<CPP14Parser::VirtspecifierContext>(0);//1165
}

CPP14Parser::VirtspecifierseqContext* CPP14Parser::VirtspecifierseqContext::virtspecifierseq()
{
	return getRuleContext<CPP14Parser::VirtspecifierseqContext>(0);//1165
}


size_t CPP14Parser::VirtspecifierseqContext::getRuleIndex() const
{
	return CPP14Parser::RuleVirtspecifierseq;//688
}

void CPP14Parser::VirtspecifierseqContext::copyFrom(VirtspecifierseqContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::VirtspecifierseqContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<VirtspecifierseqContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::VirtspecifierseqContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::VirtspecifierseqContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::VirtspecifierseqContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitVirtspecifierseq(this);
	else
		return visitor->visitChildren(this);
}


CPP14Parser::VirtspecifierseqContext* CPP14Parser::virtspecifierseq()
{
	 return virtspecifierseq(0, nullptr);//600
}

CPP14Parser::VirtspecifierseqContext* CPP14Parser::virtspecifierseq(int precedence, antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	antlr4::ParserRuleContext *parentContext = parent;
	size_t parentState = getState();
	auto _localctx = std::make_unique<VirtspecifierseqContext>(parentContext, parentState);//610
	auto ctx = _localctx.get();//609
	size_t startState = 312;
	enterRecursionRule(ctx, 312, CPP14Parser::RuleVirtspecifierseq, precedence);

		

	auto onExit = finally([=,&_localctx]
{
		unrollRecursionContexts(parentContext, std::move(_localctx));
	});
	try
{
		size_t alt;
		enterOuterAlt(ctx, 1);
		setState(2091); //951
		virtspecifier(ctx);
		ctx->stop = _input->LT(-1);
		setState(2097);//865
		_errHandler->sync(this, ctx);
		alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 263, ctx);
		while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
		{
			if (alt == 1)
		{
				if (!_parseListeners.empty())
					triggerExitRuleEvent(ctx);

				auto tmpContext = std::make_unique<VirtspecifierseqContext>(parentContext, parentState);
				pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleVirtspecifierseq);//1240
				_localctx = std::move(tmpContext);
				ctx = _localctx.get();
				setState(2093);//1002

				if (!(precpred(nullptr, 1))) throw FailedPredicateException(this, "precpred(nullptr, 1)", ctx);
				setState(2094); //951
				virtspecifier(ctx); 
			}
			setState(2099);//875
			_errHandler->sync(this, ctx);
			alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 263, ctx);
		}
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		_localctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}
	onExit();
	return ctx;
}

std::unique_ptr< CPP14Parser::VirtspecifierseqContext> CPP14Parser::parsevirtspecifierseq()
{
	virtspecifierseq();
	auto result = std::unique_ptr<VirtspecifierseqContext>(dynamic_cast<VirtspecifierseqContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}

//----------------- VirtspecifierContext ------------------------------------------------------------------

CPP14Parser::VirtspecifierContext::VirtspecifierContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::VirtspecifierContext::Override()
{
	return getToken(CPP14Parser::Override, 0);
}

tree::TerminalNode* CPP14Parser::VirtspecifierContext::Final()
{
	return getToken(CPP14Parser::Final, 0);
}


size_t CPP14Parser::VirtspecifierContext::getRuleIndex() const
{
	return CPP14Parser::RuleVirtspecifier;//688
}

void CPP14Parser::VirtspecifierContext::copyFrom(VirtspecifierContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::VirtspecifierContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<VirtspecifierContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::VirtspecifierContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::VirtspecifierContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::VirtspecifierContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitVirtspecifier(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::VirtspecifierContext* CPP14Parser::virtspecifier( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<VirtspecifierContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 314, CPP14Parser::RuleVirtspecifier);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(2100);//970
		_la = _input->LA(1);
		if (!(_la == CPP14Parser::Final

		|| _la == CPP14Parser::Override))
		{
		_errHandler->recoverInline(this, ctx);
		}
		else
		{
			_errHandler->reportMatch(this);
			consume(ctx);
		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::VirtspecifierContext> CPP14Parser::parsevirtspecifier()
{
	virtspecifier();
	auto result = std::unique_ptr<VirtspecifierContext>(dynamic_cast<VirtspecifierContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- PurespecifierContext ------------------------------------------------------------------

CPP14Parser::PurespecifierContext::PurespecifierContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::PurespecifierContext::Assign()
{
	return getToken(CPP14Parser::Assign, 0);
}

tree::TerminalNode* CPP14Parser::PurespecifierContext::Octalliteral()
{
	return getToken(CPP14Parser::Octalliteral, 0);
}


size_t CPP14Parser::PurespecifierContext::getRuleIndex() const
{
	return CPP14Parser::RulePurespecifier;//688
}

void CPP14Parser::PurespecifierContext::copyFrom(PurespecifierContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
	this->val = ctx->val;
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::PurespecifierContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<PurespecifierContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::PurespecifierContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::PurespecifierContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::PurespecifierContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitPurespecifier(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::PurespecifierContext* CPP14Parser::purespecifier( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<PurespecifierContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 316, CPP14Parser::RulePurespecifier);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(2102);//958
		match(CPP14Parser::Assign,ctx);
		setState(2103);//958
		dynamic_cast<PurespecifierContext *>(_localctx.get())->val = match(CPP14Parser::Octalliteral,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::PurespecifierContext> CPP14Parser::parsepurespecifier()
{
	purespecifier();
	auto result = std::unique_ptr<PurespecifierContext>(dynamic_cast<PurespecifierContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- BaseclauseContext ------------------------------------------------------------------

CPP14Parser::BaseclauseContext::BaseclauseContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::BaseclauseContext::Colon()
{
	return getToken(CPP14Parser::Colon, 0);
}

CPP14Parser::BasespecifierlistContext* CPP14Parser::BaseclauseContext::basespecifierlist()
{
	return getRuleContext<CPP14Parser::BasespecifierlistContext>(0);//1165
}


size_t CPP14Parser::BaseclauseContext::getRuleIndex() const
{
	return CPP14Parser::RuleBaseclause;//688
}

void CPP14Parser::BaseclauseContext::copyFrom(BaseclauseContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::BaseclauseContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<BaseclauseContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::BaseclauseContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::BaseclauseContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::BaseclauseContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitBaseclause(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::BaseclauseContext* CPP14Parser::baseclause( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<BaseclauseContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 318, CPP14Parser::RuleBaseclause);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(2105);//958
		match(CPP14Parser::Colon,ctx);
		setState(2106); //951
		basespecifierlist(0,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::BaseclauseContext> CPP14Parser::parsebaseclause()
{
	baseclause();
	auto result = std::unique_ptr<BaseclauseContext>(dynamic_cast<BaseclauseContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- BasespecifierlistContext ------------------------------------------------------------------

CPP14Parser::BasespecifierlistContext::BasespecifierlistContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::BasespecifierContext* CPP14Parser::BasespecifierlistContext::basespecifier()
{
	return getRuleContext<CPP14Parser::BasespecifierContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::BasespecifierlistContext::Ellipsis()
{
	return getToken(CPP14Parser::Ellipsis, 0);
}

CPP14Parser::BasespecifierlistContext* CPP14Parser::BasespecifierlistContext::basespecifierlist()
{
	return getRuleContext<CPP14Parser::BasespecifierlistContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::BasespecifierlistContext::Comma()
{
	return getToken(CPP14Parser::Comma, 0);
}


size_t CPP14Parser::BasespecifierlistContext::getRuleIndex() const
{
	return CPP14Parser::RuleBasespecifierlist;//688
}

void CPP14Parser::BasespecifierlistContext::copyFrom(BasespecifierlistContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::BasespecifierlistContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<BasespecifierlistContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::BasespecifierlistContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::BasespecifierlistContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::BasespecifierlistContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitBasespecifierlist(this);
	else
		return visitor->visitChildren(this);
}


CPP14Parser::BasespecifierlistContext* CPP14Parser::basespecifierlist()
{
	 return basespecifierlist(0, nullptr);//600
}

CPP14Parser::BasespecifierlistContext* CPP14Parser::basespecifierlist(int precedence, antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	antlr4::ParserRuleContext *parentContext = parent;
	size_t parentState = getState();
	auto _localctx = std::make_unique<BasespecifierlistContext>(parentContext, parentState);//610
	auto ctx = _localctx.get();//609
	size_t startState = 320;
	enterRecursionRule(ctx, 320, CPP14Parser::RuleBasespecifierlist, precedence);

		

	auto onExit = finally([=,&_localctx]
{
		unrollRecursionContexts(parentContext, std::move(_localctx));
	});
	try
{
		size_t alt;
		enterOuterAlt(ctx, 1);
		setState(2109); //951
		basespecifier(ctx);
		setState(2111);//848
		_errHandler->sync(this, ctx);

		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 264, ctx))
		{
		case 1:
		{
			setState(2110);//958
			match(CPP14Parser::Ellipsis,ctx);
			break;
		}

		}
		ctx->stop = _input->LT(-1);
		setState(2121);//865
		_errHandler->sync(this, ctx);
		alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 266, ctx);
		while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
		{
			if (alt == 1)
		{
				if (!_parseListeners.empty())
					triggerExitRuleEvent(ctx);

				auto tmpContext = std::make_unique<BasespecifierlistContext>(parentContext, parentState);
				pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleBasespecifierlist);//1240
				_localctx = std::move(tmpContext);
				ctx = _localctx.get();
				setState(2113);//1002

				if (!(precpred(nullptr, 1))) throw FailedPredicateException(this, "precpred(nullptr, 1)", ctx);
				setState(2114);//958
				match(CPP14Parser::Comma,ctx);
				setState(2115); //951
				basespecifier(ctx);
				setState(2117);//848
				_errHandler->sync(this, ctx);

				switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 265, ctx))
				{
				case 1:
				{
					setState(2116);//958
					match(CPP14Parser::Ellipsis,ctx);
					break;
				}

				} 
			}
			setState(2123);//875
			_errHandler->sync(this, ctx);
			alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 266, ctx);
		}
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		_localctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}
	onExit();
	return ctx;
}

std::unique_ptr< CPP14Parser::BasespecifierlistContext> CPP14Parser::parsebasespecifierlist()
{
	basespecifierlist();
	auto result = std::unique_ptr<BasespecifierlistContext>(dynamic_cast<BasespecifierlistContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}

//----------------- BasespecifierContext ------------------------------------------------------------------

CPP14Parser::BasespecifierContext::BasespecifierContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::BasetypespecifierContext* CPP14Parser::BasespecifierContext::basetypespecifier()
{
	return getRuleContext<CPP14Parser::BasetypespecifierContext>(0);//1165
}

CPP14Parser::AttributespecifierseqContext* CPP14Parser::BasespecifierContext::attributespecifierseq()
{
	return getRuleContext<CPP14Parser::AttributespecifierseqContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::BasespecifierContext::Virtual()
{
	return getToken(CPP14Parser::Virtual, 0);
}

CPP14Parser::AccessspecifierContext* CPP14Parser::BasespecifierContext::accessspecifier()
{
	return getRuleContext<CPP14Parser::AccessspecifierContext>(0);//1165
}


size_t CPP14Parser::BasespecifierContext::getRuleIndex() const
{
	return CPP14Parser::RuleBasespecifier;//688
}

void CPP14Parser::BasespecifierContext::copyFrom(BasespecifierContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::BasespecifierContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<BasespecifierContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::BasespecifierContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::BasespecifierContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::BasespecifierContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitBasespecifier(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::BasespecifierContext* CPP14Parser::basespecifier( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<BasespecifierContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 322, CPP14Parser::RuleBasespecifier);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(2145);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 272, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(2125);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Alignas || _la == CPP14Parser::LeftBracket)
			{
				setState(2124); //951
				attributespecifierseq(0,ctx);
			}
			setState(2127); //951
			basetypespecifier(ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(2129);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Alignas || _la == CPP14Parser::LeftBracket)
			{
				setState(2128); //951
				attributespecifierseq(0,ctx);
			}
			setState(2131);//958
			match(CPP14Parser::Virtual,ctx);
			setState(2133);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if ((((_la & ~ 0x3fULL) == 0) &&
				((1ULL << _la) & ((1ULL << CPP14Parser::Private)
				| (1ULL << CPP14Parser::Protected)
				| (1ULL << CPP14Parser::Public))) != 0))
			{
				setState(2132); //951
				accessspecifier(ctx);
			}
			setState(2135); //951
			basetypespecifier(ctx);
			break;
		}

		case 3:
		{
			enterOuterAlt(ctx, 3);
			setState(2137);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Alignas || _la == CPP14Parser::LeftBracket)
			{
				setState(2136); //951
				attributespecifierseq(0,ctx);
			}
			setState(2139); //951
			accessspecifier(ctx);
			setState(2141);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Virtual)
			{
				setState(2140);//958
				match(CPP14Parser::Virtual,ctx);
			}
			setState(2143); //951
			basetypespecifier(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::BasespecifierContext> CPP14Parser::parsebasespecifier()
{
	basespecifier();
	auto result = std::unique_ptr<BasespecifierContext>(dynamic_cast<BasespecifierContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- ClassordecltypeContext ------------------------------------------------------------------

CPP14Parser::ClassordecltypeContext::ClassordecltypeContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::ClassnameContext* CPP14Parser::ClassordecltypeContext::classname()
{
	return getRuleContext<CPP14Parser::ClassnameContext>(0);//1165
}

CPP14Parser::NestednamespecifierContext* CPP14Parser::ClassordecltypeContext::nestednamespecifier()
{
	return getRuleContext<CPP14Parser::NestednamespecifierContext>(0);//1165
}

CPP14Parser::DecltypespecifierContext* CPP14Parser::ClassordecltypeContext::decltypespecifier()
{
	return getRuleContext<CPP14Parser::DecltypespecifierContext>(0);//1165
}


size_t CPP14Parser::ClassordecltypeContext::getRuleIndex() const
{
	return CPP14Parser::RuleClassordecltype;//688
}

void CPP14Parser::ClassordecltypeContext::copyFrom(ClassordecltypeContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::ClassordecltypeContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<ClassordecltypeContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::ClassordecltypeContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::ClassordecltypeContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::ClassordecltypeContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitClassordecltype(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::ClassordecltypeContext* CPP14Parser::classordecltype( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<ClassordecltypeContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 324, CPP14Parser::RuleClassordecltype);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(2152);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 274, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(2148);//848
			_errHandler->sync(this, ctx);

			switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 273, ctx))
			{
			case 1:
			{
				setState(2147); //951
				nestednamespecifier(0,ctx);
				break;
			}

			}
			setState(2150); //951
			classname(ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(2151); //951
			decltypespecifier(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::ClassordecltypeContext> CPP14Parser::parseclassordecltype()
{
	classordecltype();
	auto result = std::unique_ptr<ClassordecltypeContext>(dynamic_cast<ClassordecltypeContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- BasetypespecifierContext ------------------------------------------------------------------

CPP14Parser::BasetypespecifierContext::BasetypespecifierContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::ClassordecltypeContext* CPP14Parser::BasetypespecifierContext::classordecltype()
{
	return getRuleContext<CPP14Parser::ClassordecltypeContext>(0);//1165
}


size_t CPP14Parser::BasetypespecifierContext::getRuleIndex() const
{
	return CPP14Parser::RuleBasetypespecifier;//688
}

void CPP14Parser::BasetypespecifierContext::copyFrom(BasetypespecifierContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::BasetypespecifierContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<BasetypespecifierContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::BasetypespecifierContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::BasetypespecifierContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::BasetypespecifierContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitBasetypespecifier(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::BasetypespecifierContext* CPP14Parser::basetypespecifier( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<BasetypespecifierContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 326, CPP14Parser::RuleBasetypespecifier);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(2154); //951
		classordecltype(ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::BasetypespecifierContext> CPP14Parser::parsebasetypespecifier()
{
	basetypespecifier();
	auto result = std::unique_ptr<BasetypespecifierContext>(dynamic_cast<BasetypespecifierContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- AccessspecifierContext ------------------------------------------------------------------

CPP14Parser::AccessspecifierContext::AccessspecifierContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::AccessspecifierContext::Private()
{
	return getToken(CPP14Parser::Private, 0);
}

tree::TerminalNode* CPP14Parser::AccessspecifierContext::Protected()
{
	return getToken(CPP14Parser::Protected, 0);
}

tree::TerminalNode* CPP14Parser::AccessspecifierContext::Public()
{
	return getToken(CPP14Parser::Public, 0);
}


size_t CPP14Parser::AccessspecifierContext::getRuleIndex() const
{
	return CPP14Parser::RuleAccessspecifier;//688
}

void CPP14Parser::AccessspecifierContext::copyFrom(AccessspecifierContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::AccessspecifierContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<AccessspecifierContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::AccessspecifierContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::AccessspecifierContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::AccessspecifierContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitAccessspecifier(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::AccessspecifierContext* CPP14Parser::accessspecifier( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<AccessspecifierContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 328, CPP14Parser::RuleAccessspecifier);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(2156);//970
		_la = _input->LA(1);
		if (!((((_la & ~ 0x3fULL) == 0) &&
			((1ULL << _la) & ((1ULL << CPP14Parser::Private)
			| (1ULL << CPP14Parser::Protected)
			| (1ULL << CPP14Parser::Public))) != 0)))
		{
		_errHandler->recoverInline(this, ctx);
		}
		else
		{
			_errHandler->reportMatch(this);
			consume(ctx);
		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::AccessspecifierContext> CPP14Parser::parseaccessspecifier()
{
	accessspecifier();
	auto result = std::unique_ptr<AccessspecifierContext>(dynamic_cast<AccessspecifierContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- ConversionfunctionidContext ------------------------------------------------------------------

CPP14Parser::ConversionfunctionidContext::ConversionfunctionidContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::ConversionfunctionidContext::Operator()
{
	return getToken(CPP14Parser::Operator, 0);
}

CPP14Parser::ConversiontypeidContext* CPP14Parser::ConversionfunctionidContext::conversiontypeid()
{
	return getRuleContext<CPP14Parser::ConversiontypeidContext>(0);//1165
}


size_t CPP14Parser::ConversionfunctionidContext::getRuleIndex() const
{
	return CPP14Parser::RuleConversionfunctionid;//688
}

void CPP14Parser::ConversionfunctionidContext::copyFrom(ConversionfunctionidContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::ConversionfunctionidContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<ConversionfunctionidContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::ConversionfunctionidContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::ConversionfunctionidContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::ConversionfunctionidContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitConversionfunctionid(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::ConversionfunctionidContext* CPP14Parser::conversionfunctionid( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<ConversionfunctionidContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 330, CPP14Parser::RuleConversionfunctionid);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(2158);//958
		match(CPP14Parser::Operator,ctx);
		setState(2159); //951
		conversiontypeid(ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::ConversionfunctionidContext> CPP14Parser::parseconversionfunctionid()
{
	conversionfunctionid();
	auto result = std::unique_ptr<ConversionfunctionidContext>(dynamic_cast<ConversionfunctionidContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- ConversiontypeidContext ------------------------------------------------------------------

CPP14Parser::ConversiontypeidContext::ConversiontypeidContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::TypespecifierseqContext* CPP14Parser::ConversiontypeidContext::typespecifierseq()
{
	return getRuleContext<CPP14Parser::TypespecifierseqContext>(0);//1165
}

CPP14Parser::ConversiondeclaratorContext* CPP14Parser::ConversiontypeidContext::conversiondeclarator()
{
	return getRuleContext<CPP14Parser::ConversiondeclaratorContext>(0);//1165
}


size_t CPP14Parser::ConversiontypeidContext::getRuleIndex() const
{
	return CPP14Parser::RuleConversiontypeid;//688
}

void CPP14Parser::ConversiontypeidContext::copyFrom(ConversiontypeidContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::ConversiontypeidContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<ConversiontypeidContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::ConversiontypeidContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::ConversiontypeidContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::ConversiontypeidContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitConversiontypeid(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::ConversiontypeidContext* CPP14Parser::conversiontypeid( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<ConversiontypeidContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 332, CPP14Parser::RuleConversiontypeid);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(2161); //951
		typespecifierseq(ctx);
		setState(2163);//848
		_errHandler->sync(this, ctx);

		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 275, ctx))
		{
		case 1:
		{
			setState(2162); //951
			conversiondeclarator(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::ConversiontypeidContext> CPP14Parser::parseconversiontypeid()
{
	conversiontypeid();
	auto result = std::unique_ptr<ConversiontypeidContext>(dynamic_cast<ConversiontypeidContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- ConversiondeclaratorContext ------------------------------------------------------------------

CPP14Parser::ConversiondeclaratorContext::ConversiondeclaratorContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::PtroperatorContext* CPP14Parser::ConversiondeclaratorContext::ptroperator()
{
	return getRuleContext<CPP14Parser::PtroperatorContext>(0);//1165
}

CPP14Parser::ConversiondeclaratorContext* CPP14Parser::ConversiondeclaratorContext::conversiondeclarator()
{
	return getRuleContext<CPP14Parser::ConversiondeclaratorContext>(0);//1165
}


size_t CPP14Parser::ConversiondeclaratorContext::getRuleIndex() const
{
	return CPP14Parser::RuleConversiondeclarator;//688
}

void CPP14Parser::ConversiondeclaratorContext::copyFrom(ConversiondeclaratorContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::ConversiondeclaratorContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<ConversiondeclaratorContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::ConversiondeclaratorContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::ConversiondeclaratorContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::ConversiondeclaratorContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitConversiondeclarator(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::ConversiondeclaratorContext* CPP14Parser::conversiondeclarator( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<ConversiondeclaratorContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 334, CPP14Parser::RuleConversiondeclarator);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(2165); //951
		ptroperator(ctx);
		setState(2167);//848
		_errHandler->sync(this, ctx);

		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 276, ctx))
		{
		case 1:
		{
			setState(2166); //951
			conversiondeclarator(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::ConversiondeclaratorContext> CPP14Parser::parseconversiondeclarator()
{
	conversiondeclarator();
	auto result = std::unique_ptr<ConversiondeclaratorContext>(dynamic_cast<ConversiondeclaratorContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- CtorinitializerContext ------------------------------------------------------------------

CPP14Parser::CtorinitializerContext::CtorinitializerContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::CtorinitializerContext::Colon()
{
	return getToken(CPP14Parser::Colon, 0);
}

CPP14Parser::MeminitializerlistContext* CPP14Parser::CtorinitializerContext::meminitializerlist()
{
	return getRuleContext<CPP14Parser::MeminitializerlistContext>(0);//1165
}


size_t CPP14Parser::CtorinitializerContext::getRuleIndex() const
{
	return CPP14Parser::RuleCtorinitializer;//688
}

void CPP14Parser::CtorinitializerContext::copyFrom(CtorinitializerContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::CtorinitializerContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<CtorinitializerContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::CtorinitializerContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::CtorinitializerContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::CtorinitializerContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitCtorinitializer(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::CtorinitializerContext* CPP14Parser::ctorinitializer( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<CtorinitializerContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 336, CPP14Parser::RuleCtorinitializer);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(2169);//958
		match(CPP14Parser::Colon,ctx);
		setState(2170); //951
		meminitializerlist(ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::CtorinitializerContext> CPP14Parser::parsectorinitializer()
{
	ctorinitializer();
	auto result = std::unique_ptr<CtorinitializerContext>(dynamic_cast<CtorinitializerContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- MeminitializerlistContext ------------------------------------------------------------------

CPP14Parser::MeminitializerlistContext::MeminitializerlistContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::MeminitializerContext* CPP14Parser::MeminitializerlistContext::meminitializer()
{
	return getRuleContext<CPP14Parser::MeminitializerContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::MeminitializerlistContext::Ellipsis()
{
	return getToken(CPP14Parser::Ellipsis, 0);
}

tree::TerminalNode* CPP14Parser::MeminitializerlistContext::Comma()
{
	return getToken(CPP14Parser::Comma, 0);
}

CPP14Parser::MeminitializerlistContext* CPP14Parser::MeminitializerlistContext::meminitializerlist()
{
	return getRuleContext<CPP14Parser::MeminitializerlistContext>(0);//1165
}


size_t CPP14Parser::MeminitializerlistContext::getRuleIndex() const
{
	return CPP14Parser::RuleMeminitializerlist;//688
}

void CPP14Parser::MeminitializerlistContext::copyFrom(MeminitializerlistContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::MeminitializerlistContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<MeminitializerlistContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::MeminitializerlistContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::MeminitializerlistContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::MeminitializerlistContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitMeminitializerlist(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::MeminitializerlistContext* CPP14Parser::meminitializerlist( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<MeminitializerlistContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 338, CPP14Parser::RuleMeminitializerlist);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(2183);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 279, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(2172); //951
			meminitializer(ctx);
			setState(2174);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Ellipsis)
			{
				setState(2173);//958
				match(CPP14Parser::Ellipsis,ctx);
			}
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(2176); //951
			meminitializer(ctx);
			setState(2178);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Ellipsis)
			{
				setState(2177);//958
				match(CPP14Parser::Ellipsis,ctx);
			}
			setState(2180);//958
			match(CPP14Parser::Comma,ctx);
			setState(2181); //951
			meminitializerlist(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::MeminitializerlistContext> CPP14Parser::parsememinitializerlist()
{
	meminitializerlist();
	auto result = std::unique_ptr<MeminitializerlistContext>(dynamic_cast<MeminitializerlistContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- MeminitializerContext ------------------------------------------------------------------

CPP14Parser::MeminitializerContext::MeminitializerContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::MeminitializeridContext* CPP14Parser::MeminitializerContext::meminitializerid()
{
	return getRuleContext<CPP14Parser::MeminitializeridContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::MeminitializerContext::LeftParen()
{
	return getToken(CPP14Parser::LeftParen, 0);
}

tree::TerminalNode* CPP14Parser::MeminitializerContext::RightParen()
{
	return getToken(CPP14Parser::RightParen, 0);
}

CPP14Parser::ExpressionlistContext* CPP14Parser::MeminitializerContext::expressionlist()
{
	return getRuleContext<CPP14Parser::ExpressionlistContext>(0);//1165
}

CPP14Parser::BracedinitlistContext* CPP14Parser::MeminitializerContext::bracedinitlist()
{
	return getRuleContext<CPP14Parser::BracedinitlistContext>(0);//1165
}


size_t CPP14Parser::MeminitializerContext::getRuleIndex() const
{
	return CPP14Parser::RuleMeminitializer;//688
}

void CPP14Parser::MeminitializerContext::copyFrom(MeminitializerContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::MeminitializerContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<MeminitializerContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::MeminitializerContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::MeminitializerContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::MeminitializerContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitMeminitializer(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::MeminitializerContext* CPP14Parser::meminitializer( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<MeminitializerContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 340, CPP14Parser::RuleMeminitializer);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(2195);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 281, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(2185); //951
			meminitializerid(ctx);
			setState(2186);//958
			match(CPP14Parser::LeftParen,ctx);
			setState(2188);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if ((((_la & ~ 0x3fULL) == 0) &&
				((1ULL << _la) & ((1ULL << CPP14Parser::T__0)
				| (1ULL << CPP14Parser::T__1)
				| (1ULL << CPP14Parser::Alignof)
				| (1ULL << CPP14Parser::Auto)
				| (1ULL << CPP14Parser::Bool)
				| (1ULL << CPP14Parser::Char)
				| (1ULL << CPP14Parser::Char16)
				| (1ULL << CPP14Parser::Char32)
				| (1ULL << CPP14Parser::Const_cast)
				| (1ULL << CPP14Parser::Decltype)
				| (1ULL << CPP14Parser::Delete)
				| (1ULL << CPP14Parser::Double)
				| (1ULL << CPP14Parser::Dynamic_cast)
				| (1ULL << CPP14Parser::False)
				| (1ULL << CPP14Parser::Float)
				| (1ULL << CPP14Parser::Int)
				| (1ULL << CPP14Parser::Long)
				| (1ULL << CPP14Parser::New)
				| (1ULL << CPP14Parser::Noexcept)
				| (1ULL << CPP14Parser::Nullptr)
				| (1ULL << CPP14Parser::Operator)
				| (1ULL << CPP14Parser::Reinterpret_cast)
				| (1ULL << CPP14Parser::Short)
				| (1ULL << CPP14Parser::Signed)
				| (1ULL << CPP14Parser::Sizeof))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
				((1ULL << (_la - 64)) & ((1ULL << (CPP14Parser::Static_cast - 64))
				| (1ULL << (CPP14Parser::This - 64))
				| (1ULL << (CPP14Parser::Throw - 64))
				| (1ULL << (CPP14Parser::True - 64))
				| (1ULL << (CPP14Parser::Typeid_ - 64))
				| (1ULL << (CPP14Parser::Typename_ - 64))
				| (1ULL << (CPP14Parser::Unsigned - 64))
				| (1ULL << (CPP14Parser::Void - 64))
				| (1ULL << (CPP14Parser::Wchar - 64))
				| (1ULL << (CPP14Parser::LeftParen - 64))
				| (1ULL << (CPP14Parser::LeftBracket - 64))
				| (1ULL << (CPP14Parser::LeftBrace - 64))
				| (1ULL << (CPP14Parser::Plus - 64))
				| (1ULL << (CPP14Parser::Minus - 64))
				| (1ULL << (CPP14Parser::Star - 64))
				| (1ULL << (CPP14Parser::And - 64))
				| (1ULL << (CPP14Parser::Or - 64))
				| (1ULL << (CPP14Parser::Tilde - 64))
				| (1ULL << (CPP14Parser::PlusPlus - 64))
				| (1ULL << (CPP14Parser::MinusMinus - 64))
				| (1ULL << (CPP14Parser::Doublecolon - 64)))) != 0) || ((((_la - 130) & ~ 0x3fULL) == 0) &&
				((1ULL << (_la - 130)) & ((1ULL << (CPP14Parser::Identifier - 130))
				| (1ULL << (CPP14Parser::Integerliteral - 130))
				| (1ULL << (CPP14Parser::Characterliteral - 130))
				| (1ULL << (CPP14Parser::Floatingliteral - 130))
				| (1ULL << (CPP14Parser::Stringliteral - 130))
				| (1ULL << (CPP14Parser::Userdefinedintegerliteral - 130))
				| (1ULL << (CPP14Parser::Userdefinedfloatingliteral - 130))
				| (1ULL << (CPP14Parser::Userdefinedstringliteral - 130))
				| (1ULL << (CPP14Parser::Userdefinedcharacterliteral - 130)))) != 0))
			{
				setState(2187); //951
				expressionlist(ctx);
			}
			setState(2190);//958
			match(CPP14Parser::RightParen,ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(2192); //951
			meminitializerid(ctx);
			setState(2193); //951
			bracedinitlist(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::MeminitializerContext> CPP14Parser::parsememinitializer()
{
	meminitializer();
	auto result = std::unique_ptr<MeminitializerContext>(dynamic_cast<MeminitializerContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- MeminitializeridContext ------------------------------------------------------------------

CPP14Parser::MeminitializeridContext::MeminitializeridContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::ClassordecltypeContext* CPP14Parser::MeminitializeridContext::classordecltype()
{
	return getRuleContext<CPP14Parser::ClassordecltypeContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::MeminitializeridContext::Identifier()
{
	return getToken(CPP14Parser::Identifier, 0);
}


size_t CPP14Parser::MeminitializeridContext::getRuleIndex() const
{
	return CPP14Parser::RuleMeminitializerid;//688
}

void CPP14Parser::MeminitializeridContext::copyFrom(MeminitializeridContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::MeminitializeridContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<MeminitializeridContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::MeminitializeridContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::MeminitializeridContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::MeminitializeridContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitMeminitializerid(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::MeminitializeridContext* CPP14Parser::meminitializerid( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<MeminitializeridContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 342, CPP14Parser::RuleMeminitializerid);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(2199);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 282, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(2197); //951
			classordecltype(ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(2198);//958
			match(CPP14Parser::Identifier,ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::MeminitializeridContext> CPP14Parser::parsememinitializerid()
{
	meminitializerid();
	auto result = std::unique_ptr<MeminitializeridContext>(dynamic_cast<MeminitializeridContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- OperatorfunctionidContext ------------------------------------------------------------------

CPP14Parser::OperatorfunctionidContext::OperatorfunctionidContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::OperatorfunctionidContext::Operator()
{
	return getToken(CPP14Parser::Operator, 0);
}

CPP14Parser::TheoperatorContext* CPP14Parser::OperatorfunctionidContext::theoperator()
{
	return getRuleContext<CPP14Parser::TheoperatorContext>(0);//1165
}


size_t CPP14Parser::OperatorfunctionidContext::getRuleIndex() const
{
	return CPP14Parser::RuleOperatorfunctionid;//688
}

void CPP14Parser::OperatorfunctionidContext::copyFrom(OperatorfunctionidContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::OperatorfunctionidContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<OperatorfunctionidContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::OperatorfunctionidContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::OperatorfunctionidContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::OperatorfunctionidContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitOperatorfunctionid(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::OperatorfunctionidContext* CPP14Parser::operatorfunctionid( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<OperatorfunctionidContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 344, CPP14Parser::RuleOperatorfunctionid);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(2201);//958
		match(CPP14Parser::Operator,ctx);
		setState(2202); //951
		theoperator(ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::OperatorfunctionidContext> CPP14Parser::parseoperatorfunctionid()
{
	operatorfunctionid();
	auto result = std::unique_ptr<OperatorfunctionidContext>(dynamic_cast<OperatorfunctionidContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- LiteraloperatoridContext ------------------------------------------------------------------

CPP14Parser::LiteraloperatoridContext::LiteraloperatoridContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::LiteraloperatoridContext::Operator()
{
	return getToken(CPP14Parser::Operator, 0);
}

tree::TerminalNode* CPP14Parser::LiteraloperatoridContext::Stringliteral()
{
	return getToken(CPP14Parser::Stringliteral, 0);
}

tree::TerminalNode* CPP14Parser::LiteraloperatoridContext::Identifier()
{
	return getToken(CPP14Parser::Identifier, 0);
}

tree::TerminalNode* CPP14Parser::LiteraloperatoridContext::Userdefinedstringliteral()
{
	return getToken(CPP14Parser::Userdefinedstringliteral, 0);
}


size_t CPP14Parser::LiteraloperatoridContext::getRuleIndex() const
{
	return CPP14Parser::RuleLiteraloperatorid;//688
}

void CPP14Parser::LiteraloperatoridContext::copyFrom(LiteraloperatoridContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::LiteraloperatoridContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<LiteraloperatoridContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::LiteraloperatoridContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::LiteraloperatoridContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::LiteraloperatoridContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitLiteraloperatorid(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::LiteraloperatoridContext* CPP14Parser::literaloperatorid( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<LiteraloperatoridContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 346, CPP14Parser::RuleLiteraloperatorid);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(2209);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 283, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(2204);//958
			match(CPP14Parser::Operator,ctx);
			setState(2205);//958
			match(CPP14Parser::Stringliteral,ctx);
			setState(2206);//958
			match(CPP14Parser::Identifier,ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(2207);//958
			match(CPP14Parser::Operator,ctx);
			setState(2208);//958
			match(CPP14Parser::Userdefinedstringliteral,ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::LiteraloperatoridContext> CPP14Parser::parseliteraloperatorid()
{
	literaloperatorid();
	auto result = std::unique_ptr<LiteraloperatoridContext>(dynamic_cast<LiteraloperatoridContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- TemplatedeclarationContext ------------------------------------------------------------------

CPP14Parser::TemplatedeclarationContext::TemplatedeclarationContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::TemplatedeclarationContext::Template()
{
	return getToken(CPP14Parser::Template, 0);
}

tree::TerminalNode* CPP14Parser::TemplatedeclarationContext::Less()
{
	return getToken(CPP14Parser::Less, 0);
}

CPP14Parser::TemplateparameterlistContext* CPP14Parser::TemplatedeclarationContext::templateparameterlist()
{
	return getRuleContext<CPP14Parser::TemplateparameterlistContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::TemplatedeclarationContext::GreaterThan()
{
	return getToken(CPP14Parser::GreaterThan, 0);
}

CPP14Parser::DeclarationContext* CPP14Parser::TemplatedeclarationContext::declaration()
{
	return getRuleContext<CPP14Parser::DeclarationContext>(0);//1165
}


size_t CPP14Parser::TemplatedeclarationContext::getRuleIndex() const
{
	return CPP14Parser::RuleTemplatedeclaration;//688
}

void CPP14Parser::TemplatedeclarationContext::copyFrom(TemplatedeclarationContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::TemplatedeclarationContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<TemplatedeclarationContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::TemplatedeclarationContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::TemplatedeclarationContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::TemplatedeclarationContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitTemplatedeclaration(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::TemplatedeclarationContext* CPP14Parser::templatedeclaration( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<TemplatedeclarationContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 348, CPP14Parser::RuleTemplatedeclaration);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(2211);//958
		match(CPP14Parser::Template,ctx);
		setState(2212);//958
		match(CPP14Parser::Less,ctx);
		setState(2213); //951
		templateparameterlist(0,ctx);
		setState(2214);//958
		match(CPP14Parser::GreaterThan,ctx);
		setState(2215); //951
		declaration(ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::TemplatedeclarationContext> CPP14Parser::parsetemplatedeclaration()
{
	templatedeclaration();
	auto result = std::unique_ptr<TemplatedeclarationContext>(dynamic_cast<TemplatedeclarationContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- TemplateparameterlistContext ------------------------------------------------------------------

CPP14Parser::TemplateparameterlistContext::TemplateparameterlistContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::TemplateparameterContext* CPP14Parser::TemplateparameterlistContext::templateparameter()
{
	return getRuleContext<CPP14Parser::TemplateparameterContext>(0);//1165
}

CPP14Parser::TemplateparameterlistContext* CPP14Parser::TemplateparameterlistContext::templateparameterlist()
{
	return getRuleContext<CPP14Parser::TemplateparameterlistContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::TemplateparameterlistContext::Comma()
{
	return getToken(CPP14Parser::Comma, 0);
}


size_t CPP14Parser::TemplateparameterlistContext::getRuleIndex() const
{
	return CPP14Parser::RuleTemplateparameterlist;//688
}

void CPP14Parser::TemplateparameterlistContext::copyFrom(TemplateparameterlistContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::TemplateparameterlistContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<TemplateparameterlistContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::TemplateparameterlistContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::TemplateparameterlistContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::TemplateparameterlistContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitTemplateparameterlist(this);
	else
		return visitor->visitChildren(this);
}


CPP14Parser::TemplateparameterlistContext* CPP14Parser::templateparameterlist()
{
	 return templateparameterlist(0, nullptr);//600
}

CPP14Parser::TemplateparameterlistContext* CPP14Parser::templateparameterlist(int precedence, antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	antlr4::ParserRuleContext *parentContext = parent;
	size_t parentState = getState();
	auto _localctx = std::make_unique<TemplateparameterlistContext>(parentContext, parentState);//610
	auto ctx = _localctx.get();//609
	size_t startState = 350;
	enterRecursionRule(ctx, 350, CPP14Parser::RuleTemplateparameterlist, precedence);

		

	auto onExit = finally([=,&_localctx]
{
		unrollRecursionContexts(parentContext, std::move(_localctx));
	});
	try
{
		size_t alt;
		enterOuterAlt(ctx, 1);
		setState(2218); //951
		templateparameter(ctx);
		ctx->stop = _input->LT(-1);
		setState(2225);//865
		_errHandler->sync(this, ctx);
		alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 284, ctx);
		while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
		{
			if (alt == 1)
		{
				if (!_parseListeners.empty())
					triggerExitRuleEvent(ctx);

				auto tmpContext = std::make_unique<TemplateparameterlistContext>(parentContext, parentState);
				pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleTemplateparameterlist);//1240
				_localctx = std::move(tmpContext);
				ctx = _localctx.get();
				setState(2220);//1002

				if (!(precpred(nullptr, 1))) throw FailedPredicateException(this, "precpred(nullptr, 1)", ctx);
				setState(2221);//958
				match(CPP14Parser::Comma,ctx);
				setState(2222); //951
				templateparameter(ctx); 
			}
			setState(2227);//875
			_errHandler->sync(this, ctx);
			alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 284, ctx);
		}
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		_localctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}
	onExit();
	return ctx;
}

std::unique_ptr< CPP14Parser::TemplateparameterlistContext> CPP14Parser::parsetemplateparameterlist()
{
	templateparameterlist();
	auto result = std::unique_ptr<TemplateparameterlistContext>(dynamic_cast<TemplateparameterlistContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}

//----------------- TemplateparameterContext ------------------------------------------------------------------

CPP14Parser::TemplateparameterContext::TemplateparameterContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::TypeparameterContext* CPP14Parser::TemplateparameterContext::typeparameter()
{
	return getRuleContext<CPP14Parser::TypeparameterContext>(0);//1165
}

CPP14Parser::ParameterdeclarationContext* CPP14Parser::TemplateparameterContext::parameterdeclaration()
{
	return getRuleContext<CPP14Parser::ParameterdeclarationContext>(0);//1165
}


size_t CPP14Parser::TemplateparameterContext::getRuleIndex() const
{
	return CPP14Parser::RuleTemplateparameter;//688
}

void CPP14Parser::TemplateparameterContext::copyFrom(TemplateparameterContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::TemplateparameterContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<TemplateparameterContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::TemplateparameterContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::TemplateparameterContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::TemplateparameterContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitTemplateparameter(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::TemplateparameterContext* CPP14Parser::templateparameter( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<TemplateparameterContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 352, CPP14Parser::RuleTemplateparameter);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(2230);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 285, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(2228); //951
			typeparameter(ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(2229); //951
			parameterdeclaration(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::TemplateparameterContext> CPP14Parser::parsetemplateparameter()
{
	templateparameter();
	auto result = std::unique_ptr<TemplateparameterContext>(dynamic_cast<TemplateparameterContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- TypeparameterContext ------------------------------------------------------------------

CPP14Parser::TypeparameterContext::TypeparameterContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::TypeparameterContext::Class()
{
	return getToken(CPP14Parser::Class, 0);
}

tree::TerminalNode* CPP14Parser::TypeparameterContext::Ellipsis()
{
	return getToken(CPP14Parser::Ellipsis, 0);
}

tree::TerminalNode* CPP14Parser::TypeparameterContext::Identifier()
{
	return getToken(CPP14Parser::Identifier, 0);
}

tree::TerminalNode* CPP14Parser::TypeparameterContext::Assign()
{
	return getToken(CPP14Parser::Assign, 0);
}

CPP14Parser::ThetypeidContext* CPP14Parser::TypeparameterContext::thetypeid()
{
	return getRuleContext<CPP14Parser::ThetypeidContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::TypeparameterContext::Typename_()
{
	return getToken(CPP14Parser::Typename_, 0);
}

tree::TerminalNode* CPP14Parser::TypeparameterContext::Template()
{
	return getToken(CPP14Parser::Template, 0);
}

tree::TerminalNode* CPP14Parser::TypeparameterContext::Less()
{
	return getToken(CPP14Parser::Less, 0);
}

CPP14Parser::TemplateparameterlistContext* CPP14Parser::TypeparameterContext::templateparameterlist()
{
	return getRuleContext<CPP14Parser::TemplateparameterlistContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::TypeparameterContext::GreaterThan()
{
	return getToken(CPP14Parser::GreaterThan, 0);
}

CPP14Parser::IdexpressionContext* CPP14Parser::TypeparameterContext::idexpression()
{
	return getRuleContext<CPP14Parser::IdexpressionContext>(0);//1165
}


size_t CPP14Parser::TypeparameterContext::getRuleIndex() const
{
	return CPP14Parser::RuleTypeparameter;//688
}

void CPP14Parser::TypeparameterContext::copyFrom(TypeparameterContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::TypeparameterContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<TypeparameterContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::TypeparameterContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::TypeparameterContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::TypeparameterContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitTypeparameter(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::TypeparameterContext* CPP14Parser::typeparameter( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<TypeparameterContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 354, CPP14Parser::RuleTypeparameter);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(2280);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 295, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(2232);//958
			match(CPP14Parser::Class,ctx);
			setState(2234);//848
			_errHandler->sync(this, ctx);

			switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 286, ctx))
			{
			case 1:
			{
				setState(2233);//958
				match(CPP14Parser::Ellipsis,ctx);
				break;
			}

			}
			setState(2237);//848
			_errHandler->sync(this, ctx);

			switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 287, ctx))
			{
			case 1:
			{
				setState(2236);//958
				match(CPP14Parser::Identifier,ctx);
				break;
			}

			}
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(2239);//958
			match(CPP14Parser::Class,ctx);
			setState(2241);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Identifier)
			{
				setState(2240);//958
				match(CPP14Parser::Identifier,ctx);
			}
			setState(2243);//958
			match(CPP14Parser::Assign,ctx);
			setState(2244); //951
			thetypeid(ctx);
			break;
		}

		case 3:
		{
			enterOuterAlt(ctx, 3);
			setState(2245);//958
			match(CPP14Parser::Typename_,ctx);
			setState(2247);//848
			_errHandler->sync(this, ctx);

			switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 289, ctx))
			{
			case 1:
			{
				setState(2246);//958
				match(CPP14Parser::Ellipsis,ctx);
				break;
			}

			}
			setState(2250);//848
			_errHandler->sync(this, ctx);

			switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 290, ctx))
			{
			case 1:
			{
				setState(2249);//958
				match(CPP14Parser::Identifier,ctx);
				break;
			}

			}
			break;
		}

		case 4:
		{
			enterOuterAlt(ctx, 4);
			setState(2252);//958
			match(CPP14Parser::Typename_,ctx);
			setState(2254);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Identifier)
			{
				setState(2253);//958
				match(CPP14Parser::Identifier,ctx);
			}
			setState(2256);//958
			match(CPP14Parser::Assign,ctx);
			setState(2257); //951
			thetypeid(ctx);
			break;
		}

		case 5:
		{
			enterOuterAlt(ctx, 5);
			setState(2258);//958
			match(CPP14Parser::Template,ctx);
			setState(2259);//958
			match(CPP14Parser::Less,ctx);
			setState(2260); //951
			templateparameterlist(0,ctx);
			setState(2261);//958
			match(CPP14Parser::GreaterThan,ctx);
			setState(2262);//958
			match(CPP14Parser::Class,ctx);
			setState(2264);//848
			_errHandler->sync(this, ctx);

			switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 292, ctx))
			{
			case 1:
			{
				setState(2263);//958
				match(CPP14Parser::Ellipsis,ctx);
				break;
			}

			}
			setState(2267);//848
			_errHandler->sync(this, ctx);

			switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 293, ctx))
			{
			case 1:
			{
				setState(2266);//958
				match(CPP14Parser::Identifier,ctx);
				break;
			}

			}
			break;
		}

		case 6:
		{
			enterOuterAlt(ctx, 6);
			setState(2269);//958
			match(CPP14Parser::Template,ctx);
			setState(2270);//958
			match(CPP14Parser::Less,ctx);
			setState(2271); //951
			templateparameterlist(0,ctx);
			setState(2272);//958
			match(CPP14Parser::GreaterThan,ctx);
			setState(2273);//958
			match(CPP14Parser::Class,ctx);
			setState(2275);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Identifier)
			{
				setState(2274);//958
				match(CPP14Parser::Identifier,ctx);
			}
			setState(2277);//958
			match(CPP14Parser::Assign,ctx);
			setState(2278); //951
			idexpression(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::TypeparameterContext> CPP14Parser::parsetypeparameter()
{
	typeparameter();
	auto result = std::unique_ptr<TypeparameterContext>(dynamic_cast<TypeparameterContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- SimpletemplateidContext ------------------------------------------------------------------

CPP14Parser::SimpletemplateidContext::SimpletemplateidContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::TemplatenameContext* CPP14Parser::SimpletemplateidContext::templatename()
{
	return getRuleContext<CPP14Parser::TemplatenameContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::SimpletemplateidContext::Less()
{
	return getToken(CPP14Parser::Less, 0);
}

tree::TerminalNode* CPP14Parser::SimpletemplateidContext::GreaterThan()
{
	return getToken(CPP14Parser::GreaterThan, 0);
}

CPP14Parser::TemplateargumentlistContext* CPP14Parser::SimpletemplateidContext::templateargumentlist()
{
	return getRuleContext<CPP14Parser::TemplateargumentlistContext>(0);//1165
}


size_t CPP14Parser::SimpletemplateidContext::getRuleIndex() const
{
	return CPP14Parser::RuleSimpletemplateid;//688
}

void CPP14Parser::SimpletemplateidContext::copyFrom(SimpletemplateidContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::SimpletemplateidContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<SimpletemplateidContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::SimpletemplateidContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::SimpletemplateidContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::SimpletemplateidContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitSimpletemplateid(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::SimpletemplateidContext* CPP14Parser::simpletemplateid( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<SimpletemplateidContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 356, CPP14Parser::RuleSimpletemplateid);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(2282); //951
		templatename(ctx);
		setState(2283);//958
		match(CPP14Parser::Less,ctx);
		setState(2285);//788
		_errHandler->sync(this, ctx);

		_la = _input->LA(1);
		if ((((_la & ~ 0x3fULL) == 0) &&
			((1ULL << _la) & ((1ULL << CPP14Parser::T__0)
			| (1ULL << CPP14Parser::T__1)
			| (1ULL << CPP14Parser::Alignof)
			| (1ULL << CPP14Parser::Auto)
			| (1ULL << CPP14Parser::Bool)
			| (1ULL << CPP14Parser::Char)
			| (1ULL << CPP14Parser::Char16)
			| (1ULL << CPP14Parser::Char32)
			| (1ULL << CPP14Parser::Class)
			| (1ULL << CPP14Parser::Const)
			| (1ULL << CPP14Parser::Const_cast)
			| (1ULL << CPP14Parser::Decltype)
			| (1ULL << CPP14Parser::Delete)
			| (1ULL << CPP14Parser::Double)
			| (1ULL << CPP14Parser::Dynamic_cast)
			| (1ULL << CPP14Parser::Enum)
			| (1ULL << CPP14Parser::False)
			| (1ULL << CPP14Parser::Float)
			| (1ULL << CPP14Parser::Int)
			| (1ULL << CPP14Parser::Long)
			| (1ULL << CPP14Parser::New)
			| (1ULL << CPP14Parser::Noexcept)
			| (1ULL << CPP14Parser::Nullptr)
			| (1ULL << CPP14Parser::Operator)
			| (1ULL << CPP14Parser::Reinterpret_cast)
			| (1ULL << CPP14Parser::Short)
			| (1ULL << CPP14Parser::Signed)
			| (1ULL << CPP14Parser::Sizeof))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
			((1ULL << (_la - 64)) & ((1ULL << (CPP14Parser::Static_cast - 64))
			| (1ULL << (CPP14Parser::Struct - 64))
			| (1ULL << (CPP14Parser::This - 64))
			| (1ULL << (CPP14Parser::True - 64))
			| (1ULL << (CPP14Parser::Typeid_ - 64))
			| (1ULL << (CPP14Parser::Typename_ - 64))
			| (1ULL << (CPP14Parser::Union - 64))
			| (1ULL << (CPP14Parser::Unsigned - 64))
			| (1ULL << (CPP14Parser::Void - 64))
			| (1ULL << (CPP14Parser::Volatile - 64))
			| (1ULL << (CPP14Parser::Wchar - 64))
			| (1ULL << (CPP14Parser::LeftParen - 64))
			| (1ULL << (CPP14Parser::LeftBracket - 64))
			| (1ULL << (CPP14Parser::Plus - 64))
			| (1ULL << (CPP14Parser::Minus - 64))
			| (1ULL << (CPP14Parser::Star - 64))
			| (1ULL << (CPP14Parser::And - 64))
			| (1ULL << (CPP14Parser::Or - 64))
			| (1ULL << (CPP14Parser::Tilde - 64))
			| (1ULL << (CPP14Parser::PlusPlus - 64))
			| (1ULL << (CPP14Parser::MinusMinus - 64))
			| (1ULL << (CPP14Parser::Doublecolon - 64)))) != 0) || ((((_la - 130) & ~ 0x3fULL) == 0) &&
			((1ULL << (_la - 130)) & ((1ULL << (CPP14Parser::Identifier - 130))
			| (1ULL << (CPP14Parser::Integerliteral - 130))
			| (1ULL << (CPP14Parser::Characterliteral - 130))
			| (1ULL << (CPP14Parser::Floatingliteral - 130))
			| (1ULL << (CPP14Parser::Stringliteral - 130))
			| (1ULL << (CPP14Parser::Userdefinedintegerliteral - 130))
			| (1ULL << (CPP14Parser::Userdefinedfloatingliteral - 130))
			| (1ULL << (CPP14Parser::Userdefinedstringliteral - 130))
			| (1ULL << (CPP14Parser::Userdefinedcharacterliteral - 130)))) != 0))
		{
			setState(2284); //951
			templateargumentlist(0,ctx);
		}
		setState(2287);//958
		match(CPP14Parser::GreaterThan,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::SimpletemplateidContext> CPP14Parser::parsesimpletemplateid()
{
	simpletemplateid();
	auto result = std::unique_ptr<SimpletemplateidContext>(dynamic_cast<SimpletemplateidContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- TemplateidContext ------------------------------------------------------------------

CPP14Parser::TemplateidContext::TemplateidContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::SimpletemplateidContext* CPP14Parser::TemplateidContext::simpletemplateid()
{
	return getRuleContext<CPP14Parser::SimpletemplateidContext>(0);//1165
}

CPP14Parser::OperatorfunctionidContext* CPP14Parser::TemplateidContext::operatorfunctionid()
{
	return getRuleContext<CPP14Parser::OperatorfunctionidContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::TemplateidContext::Less()
{
	return getToken(CPP14Parser::Less, 0);
}

tree::TerminalNode* CPP14Parser::TemplateidContext::GreaterThan()
{
	return getToken(CPP14Parser::GreaterThan, 0);
}

CPP14Parser::TemplateargumentlistContext* CPP14Parser::TemplateidContext::templateargumentlist()
{
	return getRuleContext<CPP14Parser::TemplateargumentlistContext>(0);//1165
}

CPP14Parser::LiteraloperatoridContext* CPP14Parser::TemplateidContext::literaloperatorid()
{
	return getRuleContext<CPP14Parser::LiteraloperatoridContext>(0);//1165
}


size_t CPP14Parser::TemplateidContext::getRuleIndex() const
{
	return CPP14Parser::RuleTemplateid;//688
}

void CPP14Parser::TemplateidContext::copyFrom(TemplateidContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::TemplateidContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<TemplateidContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::TemplateidContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::TemplateidContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::TemplateidContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitTemplateid(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::TemplateidContext* CPP14Parser::templateid( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<TemplateidContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 358, CPP14Parser::RuleTemplateid);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(2304);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 299, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(2289); //951
			simpletemplateid(ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(2290); //951
			operatorfunctionid(ctx);
			setState(2291);//958
			match(CPP14Parser::Less,ctx);
			setState(2293);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if ((((_la & ~ 0x3fULL) == 0) &&
				((1ULL << _la) & ((1ULL << CPP14Parser::T__0)
				| (1ULL << CPP14Parser::T__1)
				| (1ULL << CPP14Parser::Alignof)
				| (1ULL << CPP14Parser::Auto)
				| (1ULL << CPP14Parser::Bool)
				| (1ULL << CPP14Parser::Char)
				| (1ULL << CPP14Parser::Char16)
				| (1ULL << CPP14Parser::Char32)
				| (1ULL << CPP14Parser::Class)
				| (1ULL << CPP14Parser::Const)
				| (1ULL << CPP14Parser::Const_cast)
				| (1ULL << CPP14Parser::Decltype)
				| (1ULL << CPP14Parser::Delete)
				| (1ULL << CPP14Parser::Double)
				| (1ULL << CPP14Parser::Dynamic_cast)
				| (1ULL << CPP14Parser::Enum)
				| (1ULL << CPP14Parser::False)
				| (1ULL << CPP14Parser::Float)
				| (1ULL << CPP14Parser::Int)
				| (1ULL << CPP14Parser::Long)
				| (1ULL << CPP14Parser::New)
				| (1ULL << CPP14Parser::Noexcept)
				| (1ULL << CPP14Parser::Nullptr)
				| (1ULL << CPP14Parser::Operator)
				| (1ULL << CPP14Parser::Reinterpret_cast)
				| (1ULL << CPP14Parser::Short)
				| (1ULL << CPP14Parser::Signed)
				| (1ULL << CPP14Parser::Sizeof))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
				((1ULL << (_la - 64)) & ((1ULL << (CPP14Parser::Static_cast - 64))
				| (1ULL << (CPP14Parser::Struct - 64))
				| (1ULL << (CPP14Parser::This - 64))
				| (1ULL << (CPP14Parser::True - 64))
				| (1ULL << (CPP14Parser::Typeid_ - 64))
				| (1ULL << (CPP14Parser::Typename_ - 64))
				| (1ULL << (CPP14Parser::Union - 64))
				| (1ULL << (CPP14Parser::Unsigned - 64))
				| (1ULL << (CPP14Parser::Void - 64))
				| (1ULL << (CPP14Parser::Volatile - 64))
				| (1ULL << (CPP14Parser::Wchar - 64))
				| (1ULL << (CPP14Parser::LeftParen - 64))
				| (1ULL << (CPP14Parser::LeftBracket - 64))
				| (1ULL << (CPP14Parser::Plus - 64))
				| (1ULL << (CPP14Parser::Minus - 64))
				| (1ULL << (CPP14Parser::Star - 64))
				| (1ULL << (CPP14Parser::And - 64))
				| (1ULL << (CPP14Parser::Or - 64))
				| (1ULL << (CPP14Parser::Tilde - 64))
				| (1ULL << (CPP14Parser::PlusPlus - 64))
				| (1ULL << (CPP14Parser::MinusMinus - 64))
				| (1ULL << (CPP14Parser::Doublecolon - 64)))) != 0) || ((((_la - 130) & ~ 0x3fULL) == 0) &&
				((1ULL << (_la - 130)) & ((1ULL << (CPP14Parser::Identifier - 130))
				| (1ULL << (CPP14Parser::Integerliteral - 130))
				| (1ULL << (CPP14Parser::Characterliteral - 130))
				| (1ULL << (CPP14Parser::Floatingliteral - 130))
				| (1ULL << (CPP14Parser::Stringliteral - 130))
				| (1ULL << (CPP14Parser::Userdefinedintegerliteral - 130))
				| (1ULL << (CPP14Parser::Userdefinedfloatingliteral - 130))
				| (1ULL << (CPP14Parser::Userdefinedstringliteral - 130))
				| (1ULL << (CPP14Parser::Userdefinedcharacterliteral - 130)))) != 0))
			{
				setState(2292); //951
				templateargumentlist(0,ctx);
			}
			setState(2295);//958
			match(CPP14Parser::GreaterThan,ctx);
			break;
		}

		case 3:
		{
			enterOuterAlt(ctx, 3);
			setState(2297); //951
			literaloperatorid(ctx);
			setState(2298);//958
			match(CPP14Parser::Less,ctx);
			setState(2300);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if ((((_la & ~ 0x3fULL) == 0) &&
				((1ULL << _la) & ((1ULL << CPP14Parser::T__0)
				| (1ULL << CPP14Parser::T__1)
				| (1ULL << CPP14Parser::Alignof)
				| (1ULL << CPP14Parser::Auto)
				| (1ULL << CPP14Parser::Bool)
				| (1ULL << CPP14Parser::Char)
				| (1ULL << CPP14Parser::Char16)
				| (1ULL << CPP14Parser::Char32)
				| (1ULL << CPP14Parser::Class)
				| (1ULL << CPP14Parser::Const)
				| (1ULL << CPP14Parser::Const_cast)
				| (1ULL << CPP14Parser::Decltype)
				| (1ULL << CPP14Parser::Delete)
				| (1ULL << CPP14Parser::Double)
				| (1ULL << CPP14Parser::Dynamic_cast)
				| (1ULL << CPP14Parser::Enum)
				| (1ULL << CPP14Parser::False)
				| (1ULL << CPP14Parser::Float)
				| (1ULL << CPP14Parser::Int)
				| (1ULL << CPP14Parser::Long)
				| (1ULL << CPP14Parser::New)
				| (1ULL << CPP14Parser::Noexcept)
				| (1ULL << CPP14Parser::Nullptr)
				| (1ULL << CPP14Parser::Operator)
				| (1ULL << CPP14Parser::Reinterpret_cast)
				| (1ULL << CPP14Parser::Short)
				| (1ULL << CPP14Parser::Signed)
				| (1ULL << CPP14Parser::Sizeof))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
				((1ULL << (_la - 64)) & ((1ULL << (CPP14Parser::Static_cast - 64))
				| (1ULL << (CPP14Parser::Struct - 64))
				| (1ULL << (CPP14Parser::This - 64))
				| (1ULL << (CPP14Parser::True - 64))
				| (1ULL << (CPP14Parser::Typeid_ - 64))
				| (1ULL << (CPP14Parser::Typename_ - 64))
				| (1ULL << (CPP14Parser::Union - 64))
				| (1ULL << (CPP14Parser::Unsigned - 64))
				| (1ULL << (CPP14Parser::Void - 64))
				| (1ULL << (CPP14Parser::Volatile - 64))
				| (1ULL << (CPP14Parser::Wchar - 64))
				| (1ULL << (CPP14Parser::LeftParen - 64))
				| (1ULL << (CPP14Parser::LeftBracket - 64))
				| (1ULL << (CPP14Parser::Plus - 64))
				| (1ULL << (CPP14Parser::Minus - 64))
				| (1ULL << (CPP14Parser::Star - 64))
				| (1ULL << (CPP14Parser::And - 64))
				| (1ULL << (CPP14Parser::Or - 64))
				| (1ULL << (CPP14Parser::Tilde - 64))
				| (1ULL << (CPP14Parser::PlusPlus - 64))
				| (1ULL << (CPP14Parser::MinusMinus - 64))
				| (1ULL << (CPP14Parser::Doublecolon - 64)))) != 0) || ((((_la - 130) & ~ 0x3fULL) == 0) &&
				((1ULL << (_la - 130)) & ((1ULL << (CPP14Parser::Identifier - 130))
				| (1ULL << (CPP14Parser::Integerliteral - 130))
				| (1ULL << (CPP14Parser::Characterliteral - 130))
				| (1ULL << (CPP14Parser::Floatingliteral - 130))
				| (1ULL << (CPP14Parser::Stringliteral - 130))
				| (1ULL << (CPP14Parser::Userdefinedintegerliteral - 130))
				| (1ULL << (CPP14Parser::Userdefinedfloatingliteral - 130))
				| (1ULL << (CPP14Parser::Userdefinedstringliteral - 130))
				| (1ULL << (CPP14Parser::Userdefinedcharacterliteral - 130)))) != 0))
			{
				setState(2299); //951
				templateargumentlist(0,ctx);
			}
			setState(2302);//958
			match(CPP14Parser::GreaterThan,ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::TemplateidContext> CPP14Parser::parsetemplateid()
{
	templateid();
	auto result = std::unique_ptr<TemplateidContext>(dynamic_cast<TemplateidContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- TemplatenameContext ------------------------------------------------------------------

CPP14Parser::TemplatenameContext::TemplatenameContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::TemplatenameContext::Identifier()
{
	return getToken(CPP14Parser::Identifier, 0);
}


size_t CPP14Parser::TemplatenameContext::getRuleIndex() const
{
	return CPP14Parser::RuleTemplatename;//688
}

void CPP14Parser::TemplatenameContext::copyFrom(TemplatenameContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::TemplatenameContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<TemplatenameContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::TemplatenameContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::TemplatenameContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::TemplatenameContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitTemplatename(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::TemplatenameContext* CPP14Parser::templatename( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<TemplatenameContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 360, CPP14Parser::RuleTemplatename);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(2306);//958
		match(CPP14Parser::Identifier,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::TemplatenameContext> CPP14Parser::parsetemplatename()
{
	templatename();
	auto result = std::unique_ptr<TemplatenameContext>(dynamic_cast<TemplatenameContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- TemplateargumentlistContext ------------------------------------------------------------------

CPP14Parser::TemplateargumentlistContext::TemplateargumentlistContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::TemplateargumentContext* CPP14Parser::TemplateargumentlistContext::templateargument()
{
	return getRuleContext<CPP14Parser::TemplateargumentContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::TemplateargumentlistContext::Ellipsis()
{
	return getToken(CPP14Parser::Ellipsis, 0);
}

CPP14Parser::TemplateargumentlistContext* CPP14Parser::TemplateargumentlistContext::templateargumentlist()
{
	return getRuleContext<CPP14Parser::TemplateargumentlistContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::TemplateargumentlistContext::Comma()
{
	return getToken(CPP14Parser::Comma, 0);
}


size_t CPP14Parser::TemplateargumentlistContext::getRuleIndex() const
{
	return CPP14Parser::RuleTemplateargumentlist;//688
}

void CPP14Parser::TemplateargumentlistContext::copyFrom(TemplateargumentlistContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::TemplateargumentlistContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<TemplateargumentlistContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::TemplateargumentlistContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::TemplateargumentlistContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::TemplateargumentlistContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitTemplateargumentlist(this);
	else
		return visitor->visitChildren(this);
}


CPP14Parser::TemplateargumentlistContext* CPP14Parser::templateargumentlist()
{
	 return templateargumentlist(0, nullptr);//600
}

CPP14Parser::TemplateargumentlistContext* CPP14Parser::templateargumentlist(int precedence, antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	antlr4::ParserRuleContext *parentContext = parent;
	size_t parentState = getState();
	auto _localctx = std::make_unique<TemplateargumentlistContext>(parentContext, parentState);//610
	auto ctx = _localctx.get();//609
	size_t startState = 362;
	enterRecursionRule(ctx, 362, CPP14Parser::RuleTemplateargumentlist, precedence);

		

	auto onExit = finally([=,&_localctx]
{
		unrollRecursionContexts(parentContext, std::move(_localctx));
	});
	try
{
		size_t alt;
		enterOuterAlt(ctx, 1);
		setState(2309); //951
		templateargument(ctx);
		setState(2311);//848
		_errHandler->sync(this, ctx);

		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 300, ctx))
		{
		case 1:
		{
			setState(2310);//958
			match(CPP14Parser::Ellipsis,ctx);
			break;
		}

		}
		ctx->stop = _input->LT(-1);
		setState(2321);//865
		_errHandler->sync(this, ctx);
		alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 302, ctx);
		while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
		{
			if (alt == 1)
		{
				if (!_parseListeners.empty())
					triggerExitRuleEvent(ctx);

				auto tmpContext = std::make_unique<TemplateargumentlistContext>(parentContext, parentState);
				pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleTemplateargumentlist);//1240
				_localctx = std::move(tmpContext);
				ctx = _localctx.get();
				setState(2313);//1002

				if (!(precpred(nullptr, 1))) throw FailedPredicateException(this, "precpred(nullptr, 1)", ctx);
				setState(2314);//958
				match(CPP14Parser::Comma,ctx);
				setState(2315); //951
				templateargument(ctx);
				setState(2317);//848
				_errHandler->sync(this, ctx);

				switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 301, ctx))
				{
				case 1:
				{
					setState(2316);//958
					match(CPP14Parser::Ellipsis,ctx);
					break;
				}

				} 
			}
			setState(2323);//875
			_errHandler->sync(this, ctx);
			alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 302, ctx);
		}
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		_localctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}
	onExit();
	return ctx;
}

std::unique_ptr< CPP14Parser::TemplateargumentlistContext> CPP14Parser::parsetemplateargumentlist()
{
	templateargumentlist();
	auto result = std::unique_ptr<TemplateargumentlistContext>(dynamic_cast<TemplateargumentlistContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}

//----------------- TemplateargumentContext ------------------------------------------------------------------

CPP14Parser::TemplateargumentContext::TemplateargumentContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::SimpletemplateidContext* CPP14Parser::TemplateargumentContext::simpletemplateid()
{
	return getRuleContext<CPP14Parser::SimpletemplateidContext>(0);//1165
}

CPP14Parser::ThetypeidContext* CPP14Parser::TemplateargumentContext::thetypeid()
{
	return getRuleContext<CPP14Parser::ThetypeidContext>(0);//1165
}

CPP14Parser::ConstantexpressionContext* CPP14Parser::TemplateargumentContext::constantexpression()
{
	return getRuleContext<CPP14Parser::ConstantexpressionContext>(0);//1165
}

CPP14Parser::IdexpressionContext* CPP14Parser::TemplateargumentContext::idexpression()
{
	return getRuleContext<CPP14Parser::IdexpressionContext>(0);//1165
}


size_t CPP14Parser::TemplateargumentContext::getRuleIndex() const
{
	return CPP14Parser::RuleTemplateargument;//688
}

void CPP14Parser::TemplateargumentContext::copyFrom(TemplateargumentContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::TemplateargumentContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<TemplateargumentContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::TemplateargumentContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::TemplateargumentContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::TemplateargumentContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitTemplateargument(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::TemplateargumentContext* CPP14Parser::templateargument( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<TemplateargumentContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 364, CPP14Parser::RuleTemplateargument);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(2328);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 303, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(2324); //951
			simpletemplateid(ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(2325); //951
			thetypeid(ctx);
			break;
		}

		case 3:
		{
			enterOuterAlt(ctx, 3);
			setState(2326); //951
			constantexpression(ctx);
			break;
		}

		case 4:
		{
			enterOuterAlt(ctx, 4);
			setState(2327); //951
			idexpression(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::TemplateargumentContext> CPP14Parser::parsetemplateargument()
{
	templateargument();
	auto result = std::unique_ptr<TemplateargumentContext>(dynamic_cast<TemplateargumentContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- TypenamespecifierContext ------------------------------------------------------------------

CPP14Parser::TypenamespecifierContext::TypenamespecifierContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::TypenamespecifierContext::Typename_()
{
	return getToken(CPP14Parser::Typename_, 0);
}

CPP14Parser::NestednamespecifierContext* CPP14Parser::TypenamespecifierContext::nestednamespecifier()
{
	return getRuleContext<CPP14Parser::NestednamespecifierContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::TypenamespecifierContext::Identifier()
{
	return getToken(CPP14Parser::Identifier, 0);
}

CPP14Parser::SimpletemplateidContext* CPP14Parser::TypenamespecifierContext::simpletemplateid()
{
	return getRuleContext<CPP14Parser::SimpletemplateidContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::TypenamespecifierContext::Template()
{
	return getToken(CPP14Parser::Template, 0);
}


size_t CPP14Parser::TypenamespecifierContext::getRuleIndex() const
{
	return CPP14Parser::RuleTypenamespecifier;//688
}

void CPP14Parser::TypenamespecifierContext::copyFrom(TypenamespecifierContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::TypenamespecifierContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<TypenamespecifierContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::TypenamespecifierContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::TypenamespecifierContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::TypenamespecifierContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitTypenamespecifier(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::TypenamespecifierContext* CPP14Parser::typenamespecifier( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<TypenamespecifierContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 366, CPP14Parser::RuleTypenamespecifier);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(2341);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 305, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(2330);//958
			match(CPP14Parser::Typename_,ctx);
			setState(2331); //951
			nestednamespecifier(0,ctx);
			setState(2332);//958
			match(CPP14Parser::Identifier,ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(2334);//958
			match(CPP14Parser::Typename_,ctx);
			setState(2335); //951
			nestednamespecifier(0,ctx);
			setState(2337);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Template)
			{
				setState(2336);//958
				match(CPP14Parser::Template,ctx);
			}
			setState(2339); //951
			simpletemplateid(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::TypenamespecifierContext> CPP14Parser::parsetypenamespecifier()
{
	typenamespecifier();
	auto result = std::unique_ptr<TypenamespecifierContext>(dynamic_cast<TypenamespecifierContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- ExplicitinstantiationContext ------------------------------------------------------------------

CPP14Parser::ExplicitinstantiationContext::ExplicitinstantiationContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::ExplicitinstantiationContext::Template()
{
	return getToken(CPP14Parser::Template, 0);
}

CPP14Parser::DeclarationContext* CPP14Parser::ExplicitinstantiationContext::declaration()
{
	return getRuleContext<CPP14Parser::DeclarationContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::ExplicitinstantiationContext::Extern()
{
	return getToken(CPP14Parser::Extern, 0);
}


size_t CPP14Parser::ExplicitinstantiationContext::getRuleIndex() const
{
	return CPP14Parser::RuleExplicitinstantiation;//688
}

void CPP14Parser::ExplicitinstantiationContext::copyFrom(ExplicitinstantiationContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::ExplicitinstantiationContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<ExplicitinstantiationContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::ExplicitinstantiationContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::ExplicitinstantiationContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::ExplicitinstantiationContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitExplicitinstantiation(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::ExplicitinstantiationContext* CPP14Parser::explicitinstantiation( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<ExplicitinstantiationContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 368, CPP14Parser::RuleExplicitinstantiation);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(2344);//788
		_errHandler->sync(this, ctx);

		_la = _input->LA(1);
		if (_la == CPP14Parser::Extern)
		{
			setState(2343);//958
			match(CPP14Parser::Extern,ctx);
		}
		setState(2346);//958
		match(CPP14Parser::Template,ctx);
		setState(2347); //951
		declaration(ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::ExplicitinstantiationContext> CPP14Parser::parseexplicitinstantiation()
{
	explicitinstantiation();
	auto result = std::unique_ptr<ExplicitinstantiationContext>(dynamic_cast<ExplicitinstantiationContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- ExplicitspecializationContext ------------------------------------------------------------------

CPP14Parser::ExplicitspecializationContext::ExplicitspecializationContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::ExplicitspecializationContext::Template()
{
	return getToken(CPP14Parser::Template, 0);
}

tree::TerminalNode* CPP14Parser::ExplicitspecializationContext::Less()
{
	return getToken(CPP14Parser::Less, 0);
}

tree::TerminalNode* CPP14Parser::ExplicitspecializationContext::GreaterThan()
{
	return getToken(CPP14Parser::GreaterThan, 0);
}

CPP14Parser::DeclarationContext* CPP14Parser::ExplicitspecializationContext::declaration()
{
	return getRuleContext<CPP14Parser::DeclarationContext>(0);//1165
}


size_t CPP14Parser::ExplicitspecializationContext::getRuleIndex() const
{
	return CPP14Parser::RuleExplicitspecialization;//688
}

void CPP14Parser::ExplicitspecializationContext::copyFrom(ExplicitspecializationContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::ExplicitspecializationContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<ExplicitspecializationContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::ExplicitspecializationContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::ExplicitspecializationContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::ExplicitspecializationContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitExplicitspecialization(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::ExplicitspecializationContext* CPP14Parser::explicitspecialization( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<ExplicitspecializationContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 370, CPP14Parser::RuleExplicitspecialization);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(2349);//958
		match(CPP14Parser::Template,ctx);
		setState(2350);//958
		match(CPP14Parser::Less,ctx);
		setState(2351);//958
		match(CPP14Parser::GreaterThan,ctx);
		setState(2352); //951
		declaration(ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::ExplicitspecializationContext> CPP14Parser::parseexplicitspecialization()
{
	explicitspecialization();
	auto result = std::unique_ptr<ExplicitspecializationContext>(dynamic_cast<ExplicitspecializationContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- TryblockContext ------------------------------------------------------------------

CPP14Parser::TryblockContext::TryblockContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::TryblockContext::Try()
{
	return getToken(CPP14Parser::Try, 0);
}

CPP14Parser::CompoundstatementContext* CPP14Parser::TryblockContext::compoundstatement()
{
	return getRuleContext<CPP14Parser::CompoundstatementContext>(0);//1165
}

CPP14Parser::HandlerseqContext* CPP14Parser::TryblockContext::handlerseq()
{
	return getRuleContext<CPP14Parser::HandlerseqContext>(0);//1165
}


size_t CPP14Parser::TryblockContext::getRuleIndex() const
{
	return CPP14Parser::RuleTryblock;//688
}

void CPP14Parser::TryblockContext::copyFrom(TryblockContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::TryblockContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<TryblockContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::TryblockContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::TryblockContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::TryblockContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitTryblock(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::TryblockContext* CPP14Parser::tryblock( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<TryblockContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 372, CPP14Parser::RuleTryblock);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(2354);//958
		match(CPP14Parser::Try,ctx);
		setState(2355); //951
		compoundstatement(ctx);
		setState(2356); //951
		handlerseq(ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::TryblockContext> CPP14Parser::parsetryblock()
{
	tryblock();
	auto result = std::unique_ptr<TryblockContext>(dynamic_cast<TryblockContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- FunctiontryblockContext ------------------------------------------------------------------

CPP14Parser::FunctiontryblockContext::FunctiontryblockContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::FunctiontryblockContext::Try()
{
	return getToken(CPP14Parser::Try, 0);
}

CPP14Parser::CompoundstatementContext* CPP14Parser::FunctiontryblockContext::compoundstatement()
{
	return getRuleContext<CPP14Parser::CompoundstatementContext>(0);//1165
}

CPP14Parser::HandlerseqContext* CPP14Parser::FunctiontryblockContext::handlerseq()
{
	return getRuleContext<CPP14Parser::HandlerseqContext>(0);//1165
}

CPP14Parser::CtorinitializerContext* CPP14Parser::FunctiontryblockContext::ctorinitializer()
{
	return getRuleContext<CPP14Parser::CtorinitializerContext>(0);//1165
}


size_t CPP14Parser::FunctiontryblockContext::getRuleIndex() const
{
	return CPP14Parser::RuleFunctiontryblock;//688
}

void CPP14Parser::FunctiontryblockContext::copyFrom(FunctiontryblockContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::FunctiontryblockContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<FunctiontryblockContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::FunctiontryblockContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::FunctiontryblockContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::FunctiontryblockContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitFunctiontryblock(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::FunctiontryblockContext* CPP14Parser::functiontryblock( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<FunctiontryblockContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 374, CPP14Parser::RuleFunctiontryblock);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(2358);//958
		match(CPP14Parser::Try,ctx);
		setState(2360);//788
		_errHandler->sync(this, ctx);

		_la = _input->LA(1);
		if (_la == CPP14Parser::Colon)
		{
			setState(2359); //951
			ctorinitializer(ctx);
		}
		setState(2362); //951
		compoundstatement(ctx);
		setState(2363); //951
		handlerseq(ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::FunctiontryblockContext> CPP14Parser::parsefunctiontryblock()
{
	functiontryblock();
	auto result = std::unique_ptr<FunctiontryblockContext>(dynamic_cast<FunctiontryblockContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- HandlerseqContext ------------------------------------------------------------------

CPP14Parser::HandlerseqContext::HandlerseqContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::HandlerContext* CPP14Parser::HandlerseqContext::handler()
{
	return getRuleContext<CPP14Parser::HandlerContext>(0);//1165
}

CPP14Parser::HandlerseqContext* CPP14Parser::HandlerseqContext::handlerseq()
{
	return getRuleContext<CPP14Parser::HandlerseqContext>(0);//1165
}


size_t CPP14Parser::HandlerseqContext::getRuleIndex() const
{
	return CPP14Parser::RuleHandlerseq;//688
}

void CPP14Parser::HandlerseqContext::copyFrom(HandlerseqContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::HandlerseqContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<HandlerseqContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::HandlerseqContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::HandlerseqContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::HandlerseqContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitHandlerseq(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::HandlerseqContext* CPP14Parser::handlerseq( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<HandlerseqContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 376, CPP14Parser::RuleHandlerseq);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(2365); //951
		handler(ctx);
		setState(2367);//848
		_errHandler->sync(this, ctx);

		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 308, ctx))
		{
		case 1:
		{
			setState(2366); //951
			handlerseq(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::HandlerseqContext> CPP14Parser::parsehandlerseq()
{
	handlerseq();
	auto result = std::unique_ptr<HandlerseqContext>(dynamic_cast<HandlerseqContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- HandlerContext ------------------------------------------------------------------

CPP14Parser::HandlerContext::HandlerContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::HandlerContext::Catch()
{
	return getToken(CPP14Parser::Catch, 0);
}

tree::TerminalNode* CPP14Parser::HandlerContext::LeftParen()
{
	return getToken(CPP14Parser::LeftParen, 0);
}

CPP14Parser::ExceptiondeclarationContext* CPP14Parser::HandlerContext::exceptiondeclaration()
{
	return getRuleContext<CPP14Parser::ExceptiondeclarationContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::HandlerContext::RightParen()
{
	return getToken(CPP14Parser::RightParen, 0);
}

CPP14Parser::CompoundstatementContext* CPP14Parser::HandlerContext::compoundstatement()
{
	return getRuleContext<CPP14Parser::CompoundstatementContext>(0);//1165
}


size_t CPP14Parser::HandlerContext::getRuleIndex() const
{
	return CPP14Parser::RuleHandler;//688
}

void CPP14Parser::HandlerContext::copyFrom(HandlerContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::HandlerContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<HandlerContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::HandlerContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::HandlerContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::HandlerContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitHandler(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::HandlerContext* CPP14Parser::handler( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<HandlerContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 378, CPP14Parser::RuleHandler);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(2369);//958
		match(CPP14Parser::Catch,ctx);
		setState(2370);//958
		match(CPP14Parser::LeftParen,ctx);
		setState(2371); //951
		exceptiondeclaration(ctx);
		setState(2372);//958
		match(CPP14Parser::RightParen,ctx);
		setState(2373); //951
		compoundstatement(ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::HandlerContext> CPP14Parser::parsehandler()
{
	handler();
	auto result = std::unique_ptr<HandlerContext>(dynamic_cast<HandlerContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- ExceptiondeclarationContext ------------------------------------------------------------------

CPP14Parser::ExceptiondeclarationContext::ExceptiondeclarationContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::TypespecifierseqContext* CPP14Parser::ExceptiondeclarationContext::typespecifierseq()
{
	return getRuleContext<CPP14Parser::TypespecifierseqContext>(0);//1165
}

CPP14Parser::DeclaratorContext* CPP14Parser::ExceptiondeclarationContext::declarator()
{
	return getRuleContext<CPP14Parser::DeclaratorContext>(0);//1165
}

CPP14Parser::AttributespecifierseqContext* CPP14Parser::ExceptiondeclarationContext::attributespecifierseq()
{
	return getRuleContext<CPP14Parser::AttributespecifierseqContext>(0);//1165
}

CPP14Parser::AbstractdeclaratorContext* CPP14Parser::ExceptiondeclarationContext::abstractdeclarator()
{
	return getRuleContext<CPP14Parser::AbstractdeclaratorContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::ExceptiondeclarationContext::Ellipsis()
{
	return getToken(CPP14Parser::Ellipsis, 0);
}


size_t CPP14Parser::ExceptiondeclarationContext::getRuleIndex() const
{
	return CPP14Parser::RuleExceptiondeclaration;//688
}

void CPP14Parser::ExceptiondeclarationContext::copyFrom(ExceptiondeclarationContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::ExceptiondeclarationContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<ExceptiondeclarationContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::ExceptiondeclarationContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::ExceptiondeclarationContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::ExceptiondeclarationContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitExceptiondeclaration(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::ExceptiondeclarationContext* CPP14Parser::exceptiondeclaration( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<ExceptiondeclarationContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 380, CPP14Parser::RuleExceptiondeclaration);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(2389);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 312, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(2376);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Alignas || _la == CPP14Parser::LeftBracket)
			{
				setState(2375); //951
				attributespecifierseq(0,ctx);
			}
			setState(2378); //951
			typespecifierseq(ctx);
			setState(2379); //951
			declarator(ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(2382);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::Alignas || _la == CPP14Parser::LeftBracket)
			{
				setState(2381); //951
				attributespecifierseq(0,ctx);
			}
			setState(2384); //951
			typespecifierseq(ctx);
			setState(2386);//788
			_errHandler->sync(this, ctx);

			_la = _input->LA(1);
			if (_la == CPP14Parser::T__2

			|| _la == CPP14Parser::Decltype || ((((_la - 84) & ~ 0x3fULL) == 0) &&
				((1ULL << (_la - 84)) & ((1ULL << (CPP14Parser::LeftParen - 84))
				| (1ULL << (CPP14Parser::LeftBracket - 84))
				| (1ULL << (CPP14Parser::Star - 84))
				| (1ULL << (CPP14Parser::And - 84))
				| (1ULL << (CPP14Parser::Doublecolon - 84))
				| (1ULL << (CPP14Parser::Ellipsis - 84))
				| (1ULL << (CPP14Parser::Identifier - 84)))) != 0))
			{
				setState(2385); //951
				abstractdeclarator(ctx);
			}
			break;
		}

		case 3:
		{
			enterOuterAlt(ctx, 3);
			setState(2388);//958
			match(CPP14Parser::Ellipsis,ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::ExceptiondeclarationContext> CPP14Parser::parseexceptiondeclaration()
{
	exceptiondeclaration();
	auto result = std::unique_ptr<ExceptiondeclarationContext>(dynamic_cast<ExceptiondeclarationContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- ThrowexpressionContext ------------------------------------------------------------------

CPP14Parser::ThrowexpressionContext::ThrowexpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::ThrowexpressionContext::Throw()
{
	return getToken(CPP14Parser::Throw, 0);
}

CPP14Parser::AssignmentexpressionContext* CPP14Parser::ThrowexpressionContext::assignmentexpression()
{
	return getRuleContext<CPP14Parser::AssignmentexpressionContext>(0);//1165
}


size_t CPP14Parser::ThrowexpressionContext::getRuleIndex() const
{
	return CPP14Parser::RuleThrowexpression;//688
}

void CPP14Parser::ThrowexpressionContext::copyFrom(ThrowexpressionContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::ThrowexpressionContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<ThrowexpressionContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::ThrowexpressionContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::ThrowexpressionContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::ThrowexpressionContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitThrowexpression(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::ThrowexpressionContext* CPP14Parser::throwexpression( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<ThrowexpressionContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 382, CPP14Parser::RuleThrowexpression);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(2391);//958
		match(CPP14Parser::Throw,ctx);
		setState(2393);//848
		_errHandler->sync(this, ctx);

		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 313, ctx))
		{
		case 1:
		{
			setState(2392); //951
			assignmentexpression(ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::ThrowexpressionContext> CPP14Parser::parsethrowexpression()
{
	throwexpression();
	auto result = std::unique_ptr<ThrowexpressionContext>(dynamic_cast<ThrowexpressionContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- ExceptionspecificationContext ------------------------------------------------------------------

CPP14Parser::ExceptionspecificationContext::ExceptionspecificationContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::DynamicexceptionspecificationContext* CPP14Parser::ExceptionspecificationContext::dynamicexceptionspecification()
{
	return getRuleContext<CPP14Parser::DynamicexceptionspecificationContext>(0);//1165
}

CPP14Parser::NoexceptspecificationContext* CPP14Parser::ExceptionspecificationContext::noexceptspecification()
{
	return getRuleContext<CPP14Parser::NoexceptspecificationContext>(0);//1165
}


size_t CPP14Parser::ExceptionspecificationContext::getRuleIndex() const
{
	return CPP14Parser::RuleExceptionspecification;//688
}

void CPP14Parser::ExceptionspecificationContext::copyFrom(ExceptionspecificationContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::ExceptionspecificationContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<ExceptionspecificationContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::ExceptionspecificationContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::ExceptionspecificationContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::ExceptionspecificationContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitExceptionspecification(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::ExceptionspecificationContext* CPP14Parser::exceptionspecification( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<ExceptionspecificationContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 384, CPP14Parser::RuleExceptionspecification);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(2397);//750
		_errHandler->sync(this, ctx);
		switch (_input->LA(1))
		{
			case CPP14Parser::Throw:
			{
				enterOuterAlt(ctx, 1);
				setState(2395); //951
				dynamicexceptionspecification(ctx);
				break;
			}

			case CPP14Parser::Noexcept:
			{
				enterOuterAlt(ctx, 2);
				setState(2396); //951
				noexceptspecification(ctx);
				break;
			}

		default:
			throw NoViableAltException(this, ctx);
		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::ExceptionspecificationContext> CPP14Parser::parseexceptionspecification()
{
	exceptionspecification();
	auto result = std::unique_ptr<ExceptionspecificationContext>(dynamic_cast<ExceptionspecificationContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- DynamicexceptionspecificationContext ------------------------------------------------------------------

CPP14Parser::DynamicexceptionspecificationContext::DynamicexceptionspecificationContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::DynamicexceptionspecificationContext::Throw()
{
	return getToken(CPP14Parser::Throw, 0);
}

tree::TerminalNode* CPP14Parser::DynamicexceptionspecificationContext::LeftParen()
{
	return getToken(CPP14Parser::LeftParen, 0);
}

tree::TerminalNode* CPP14Parser::DynamicexceptionspecificationContext::RightParen()
{
	return getToken(CPP14Parser::RightParen, 0);
}

CPP14Parser::TypeidlistContext* CPP14Parser::DynamicexceptionspecificationContext::typeidlist()
{
	return getRuleContext<CPP14Parser::TypeidlistContext>(0);//1165
}


size_t CPP14Parser::DynamicexceptionspecificationContext::getRuleIndex() const
{
	return CPP14Parser::RuleDynamicexceptionspecification;//688
}

void CPP14Parser::DynamicexceptionspecificationContext::copyFrom(DynamicexceptionspecificationContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::DynamicexceptionspecificationContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<DynamicexceptionspecificationContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::DynamicexceptionspecificationContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::DynamicexceptionspecificationContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::DynamicexceptionspecificationContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitDynamicexceptionspecification(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::DynamicexceptionspecificationContext* CPP14Parser::dynamicexceptionspecification( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<DynamicexceptionspecificationContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 386, CPP14Parser::RuleDynamicexceptionspecification);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(2399);//958
		match(CPP14Parser::Throw,ctx);
		setState(2400);//958
		match(CPP14Parser::LeftParen,ctx);
		setState(2402);//788
		_errHandler->sync(this, ctx);

		_la = _input->LA(1);
		if (((((_la - 12) & ~ 0x3fULL) == 0) &&
			((1ULL << (_la - 12)) & ((1ULL << (CPP14Parser::Auto - 12))
			| (1ULL << (CPP14Parser::Bool - 12))
			| (1ULL << (CPP14Parser::Char - 12))
			| (1ULL << (CPP14Parser::Char16 - 12))
			| (1ULL << (CPP14Parser::Char32 - 12))
			| (1ULL << (CPP14Parser::Class - 12))
			| (1ULL << (CPP14Parser::Const - 12))
			| (1ULL << (CPP14Parser::Decltype - 12))
			| (1ULL << (CPP14Parser::Double - 12))
			| (1ULL << (CPP14Parser::Enum - 12))
			| (1ULL << (CPP14Parser::Float - 12))
			| (1ULL << (CPP14Parser::Int - 12))
			| (1ULL << (CPP14Parser::Long - 12))
			| (1ULL << (CPP14Parser::Short - 12))
			| (1ULL << (CPP14Parser::Signed - 12))
			| (1ULL << (CPP14Parser::Struct - 12))
			| (1ULL << (CPP14Parser::Typename_ - 12)))) != 0) || ((((_la - 76) & ~ 0x3fULL) == 0) &&
			((1ULL << (_la - 76)) & ((1ULL << (CPP14Parser::Union - 76))
			| (1ULL << (CPP14Parser::Unsigned - 76))
			| (1ULL << (CPP14Parser::Void - 76))
			| (1ULL << (CPP14Parser::Volatile - 76))
			| (1ULL << (CPP14Parser::Wchar - 76))
			| (1ULL << (CPP14Parser::Doublecolon - 76))
			| (1ULL << (CPP14Parser::Identifier - 76)))) != 0))
		{
			setState(2401); //951
			typeidlist(0,ctx);
		}
		setState(2404);//958
		match(CPP14Parser::RightParen,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::DynamicexceptionspecificationContext> CPP14Parser::parsedynamicexceptionspecification()
{
	dynamicexceptionspecification();
	auto result = std::unique_ptr<DynamicexceptionspecificationContext>(dynamic_cast<DynamicexceptionspecificationContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- TypeidlistContext ------------------------------------------------------------------

CPP14Parser::TypeidlistContext::TypeidlistContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

CPP14Parser::ThetypeidContext* CPP14Parser::TypeidlistContext::thetypeid()
{
	return getRuleContext<CPP14Parser::ThetypeidContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::TypeidlistContext::Ellipsis()
{
	return getToken(CPP14Parser::Ellipsis, 0);
}

CPP14Parser::TypeidlistContext* CPP14Parser::TypeidlistContext::typeidlist()
{
	return getRuleContext<CPP14Parser::TypeidlistContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::TypeidlistContext::Comma()
{
	return getToken(CPP14Parser::Comma, 0);
}


size_t CPP14Parser::TypeidlistContext::getRuleIndex() const
{
	return CPP14Parser::RuleTypeidlist;//688
}

void CPP14Parser::TypeidlistContext::copyFrom(TypeidlistContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::TypeidlistContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<TypeidlistContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::TypeidlistContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::TypeidlistContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::TypeidlistContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitTypeidlist(this);
	else
		return visitor->visitChildren(this);
}


CPP14Parser::TypeidlistContext* CPP14Parser::typeidlist()
{
	 return typeidlist(0, nullptr);//600
}

CPP14Parser::TypeidlistContext* CPP14Parser::typeidlist(int precedence, antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	antlr4::ParserRuleContext *parentContext = parent;
	size_t parentState = getState();
	auto _localctx = std::make_unique<TypeidlistContext>(parentContext, parentState);//610
	auto ctx = _localctx.get();//609
	size_t startState = 388;
	enterRecursionRule(ctx, 388, CPP14Parser::RuleTypeidlist, precedence);

		

	auto onExit = finally([=,&_localctx]
{
		unrollRecursionContexts(parentContext, std::move(_localctx));
	});
	try
{
		size_t alt;
		enterOuterAlt(ctx, 1);
		setState(2407); //951
		thetypeid(ctx);
		setState(2409);//848
		_errHandler->sync(this, ctx);

		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 316, ctx))
		{
		case 1:
		{
			setState(2408);//958
			match(CPP14Parser::Ellipsis,ctx);
			break;
		}

		}
		ctx->stop = _input->LT(-1);
		setState(2419);//865
		_errHandler->sync(this, ctx);
		alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 318, ctx);
		while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
		{
			if (alt == 1)
		{
				if (!_parseListeners.empty())
					triggerExitRuleEvent(ctx);

				auto tmpContext = std::make_unique<TypeidlistContext>(parentContext, parentState);
				pushNewRecursionContext(std::move(_localctx), tmpContext.get(), startState, RuleTypeidlist);//1240
				_localctx = std::move(tmpContext);
				ctx = _localctx.get();
				setState(2411);//1002

				if (!(precpred(nullptr, 1))) throw FailedPredicateException(this, "precpred(nullptr, 1)", ctx);
				setState(2412);//958
				match(CPP14Parser::Comma,ctx);
				setState(2413); //951
				thetypeid(ctx);
				setState(2415);//848
				_errHandler->sync(this, ctx);

				switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 317, ctx))
				{
				case 1:
				{
					setState(2414);//958
					match(CPP14Parser::Ellipsis,ctx);
					break;
				}

				} 
			}
			setState(2421);//875
			_errHandler->sync(this, ctx);
			alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 318, ctx);
		}
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		_localctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}
	onExit();
	return ctx;
}

std::unique_ptr< CPP14Parser::TypeidlistContext> CPP14Parser::parsetypeidlist()
{
	typeidlist();
	auto result = std::unique_ptr<TypeidlistContext>(dynamic_cast<TypeidlistContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}

//----------------- NoexceptspecificationContext ------------------------------------------------------------------

CPP14Parser::NoexceptspecificationContext::NoexceptspecificationContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::NoexceptspecificationContext::Noexcept()
{
	return getToken(CPP14Parser::Noexcept, 0);
}

tree::TerminalNode* CPP14Parser::NoexceptspecificationContext::LeftParen()
{
	return getToken(CPP14Parser::LeftParen, 0);
}

CPP14Parser::ConstantexpressionContext* CPP14Parser::NoexceptspecificationContext::constantexpression()
{
	return getRuleContext<CPP14Parser::ConstantexpressionContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::NoexceptspecificationContext::RightParen()
{
	return getToken(CPP14Parser::RightParen, 0);
}


size_t CPP14Parser::NoexceptspecificationContext::getRuleIndex() const
{
	return CPP14Parser::RuleNoexceptspecification;//688
}

void CPP14Parser::NoexceptspecificationContext::copyFrom(NoexceptspecificationContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::NoexceptspecificationContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<NoexceptspecificationContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::NoexceptspecificationContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::NoexceptspecificationContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::NoexceptspecificationContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitNoexceptspecification(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::NoexceptspecificationContext* CPP14Parser::noexceptspecification( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<NoexceptspecificationContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 390, CPP14Parser::RuleNoexceptspecification);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(2428);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 319, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(2422);//958
			match(CPP14Parser::Noexcept,ctx);
			setState(2423);//958
			match(CPP14Parser::LeftParen,ctx);
			setState(2424); //951
			constantexpression(ctx);
			setState(2425);//958
			match(CPP14Parser::RightParen,ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(2427);//958
			match(CPP14Parser::Noexcept,ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::NoexceptspecificationContext> CPP14Parser::parsenoexceptspecification()
{
	noexceptspecification();
	auto result = std::unique_ptr<NoexceptspecificationContext>(dynamic_cast<NoexceptspecificationContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- RightShiftContext ------------------------------------------------------------------

CPP14Parser::RightShiftContext::RightShiftContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

std::vector<tree::TerminalNode *> CPP14Parser::RightShiftContext::GreaterThan()
{
	return getTokens(CPP14Parser::GreaterThan);
}

tree::TerminalNode* CPP14Parser::RightShiftContext::GreaterThan(size_t i)
{
	return getToken(CPP14Parser::GreaterThan, i);
}


size_t CPP14Parser::RightShiftContext::getRuleIndex() const
{
	return CPP14Parser::RuleRightShift;//688
}

void CPP14Parser::RightShiftContext::copyFrom(RightShiftContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::RightShiftContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<RightShiftContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::RightShiftContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::RightShiftContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::RightShiftContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitRightShift(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::RightShiftContext* CPP14Parser::rightShift( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<RightShiftContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 392, CPP14Parser::RuleRightShift);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(2430);//958
		match(CPP14Parser::GreaterThan,ctx);
		setState(2431);//958
		match(CPP14Parser::GreaterThan,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::RightShiftContext> CPP14Parser::parserightShift()
{
	rightShift();
	auto result = std::unique_ptr<RightShiftContext>(dynamic_cast<RightShiftContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- RightShiftAssignContext ------------------------------------------------------------------

CPP14Parser::RightShiftAssignContext::RightShiftAssignContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

std::vector<tree::TerminalNode *> CPP14Parser::RightShiftAssignContext::GreaterThan()
{
	return getTokens(CPP14Parser::GreaterThan);
}

tree::TerminalNode* CPP14Parser::RightShiftAssignContext::GreaterThan(size_t i)
{
	return getToken(CPP14Parser::GreaterThan, i);
}

tree::TerminalNode* CPP14Parser::RightShiftAssignContext::Assign()
{
	return getToken(CPP14Parser::Assign, 0);
}


size_t CPP14Parser::RightShiftAssignContext::getRuleIndex() const
{
	return CPP14Parser::RuleRightShiftAssign;//688
}

void CPP14Parser::RightShiftAssignContext::copyFrom(RightShiftAssignContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::RightShiftAssignContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<RightShiftAssignContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::RightShiftAssignContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::RightShiftAssignContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::RightShiftAssignContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitRightShiftAssign(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::RightShiftAssignContext* CPP14Parser::rightShiftAssign( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<RightShiftAssignContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 394, CPP14Parser::RuleRightShiftAssign);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(2433);//958
		match(CPP14Parser::GreaterThan,ctx);
		setState(2434);//958
		match(CPP14Parser::GreaterThan,ctx);
		setState(2435);//958
		match(CPP14Parser::Assign,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::RightShiftAssignContext> CPP14Parser::parserightShiftAssign()
{
	rightShiftAssign();
	auto result = std::unique_ptr<RightShiftAssignContext>(dynamic_cast<RightShiftAssignContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- TheoperatorContext ------------------------------------------------------------------

CPP14Parser::TheoperatorContext::TheoperatorContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::TheoperatorContext::New()
{
	return getToken(CPP14Parser::New, 0);
}

tree::TerminalNode* CPP14Parser::TheoperatorContext::Delete()
{
	return getToken(CPP14Parser::Delete, 0);
}

tree::TerminalNode* CPP14Parser::TheoperatorContext::LeftBracket()
{
	return getToken(CPP14Parser::LeftBracket, 0);
}

tree::TerminalNode* CPP14Parser::TheoperatorContext::RightBracket()
{
	return getToken(CPP14Parser::RightBracket, 0);
}

tree::TerminalNode* CPP14Parser::TheoperatorContext::Plus()
{
	return getToken(CPP14Parser::Plus, 0);
}

tree::TerminalNode* CPP14Parser::TheoperatorContext::Minus()
{
	return getToken(CPP14Parser::Minus, 0);
}

tree::TerminalNode* CPP14Parser::TheoperatorContext::Star()
{
	return getToken(CPP14Parser::Star, 0);
}

tree::TerminalNode* CPP14Parser::TheoperatorContext::Div()
{
	return getToken(CPP14Parser::Div, 0);
}

tree::TerminalNode* CPP14Parser::TheoperatorContext::Mod()
{
	return getToken(CPP14Parser::Mod, 0);
}

tree::TerminalNode* CPP14Parser::TheoperatorContext::Caret()
{
	return getToken(CPP14Parser::Caret, 0);
}

tree::TerminalNode* CPP14Parser::TheoperatorContext::And()
{
	return getToken(CPP14Parser::And, 0);
}

tree::TerminalNode* CPP14Parser::TheoperatorContext::Or()
{
	return getToken(CPP14Parser::Or, 0);
}

tree::TerminalNode* CPP14Parser::TheoperatorContext::Tilde()
{
	return getToken(CPP14Parser::Tilde, 0);
}

tree::TerminalNode* CPP14Parser::TheoperatorContext::Assign()
{
	return getToken(CPP14Parser::Assign, 0);
}

tree::TerminalNode* CPP14Parser::TheoperatorContext::Less()
{
	return getToken(CPP14Parser::Less, 0);
}

tree::TerminalNode* CPP14Parser::TheoperatorContext::GreaterThan()
{
	return getToken(CPP14Parser::GreaterThan, 0);
}

tree::TerminalNode* CPP14Parser::TheoperatorContext::PlusAssign()
{
	return getToken(CPP14Parser::PlusAssign, 0);
}

tree::TerminalNode* CPP14Parser::TheoperatorContext::MinusAssign()
{
	return getToken(CPP14Parser::MinusAssign, 0);
}

tree::TerminalNode* CPP14Parser::TheoperatorContext::StarAssign()
{
	return getToken(CPP14Parser::StarAssign, 0);
}

tree::TerminalNode* CPP14Parser::TheoperatorContext::DivAssign()
{
	return getToken(CPP14Parser::DivAssign, 0);
}

tree::TerminalNode* CPP14Parser::TheoperatorContext::ModAssign()
{
	return getToken(CPP14Parser::ModAssign, 0);
}

tree::TerminalNode* CPP14Parser::TheoperatorContext::XorAssign()
{
	return getToken(CPP14Parser::XorAssign, 0);
}

tree::TerminalNode* CPP14Parser::TheoperatorContext::AndAssign()
{
	return getToken(CPP14Parser::AndAssign, 0);
}

tree::TerminalNode* CPP14Parser::TheoperatorContext::OrAssign()
{
	return getToken(CPP14Parser::OrAssign, 0);
}

tree::TerminalNode* CPP14Parser::TheoperatorContext::LeftShift()
{
	return getToken(CPP14Parser::LeftShift, 0);
}

CPP14Parser::RightShiftContext* CPP14Parser::TheoperatorContext::rightShift()
{
	return getRuleContext<CPP14Parser::RightShiftContext>(0);//1165
}

CPP14Parser::RightShiftAssignContext* CPP14Parser::TheoperatorContext::rightShiftAssign()
{
	return getRuleContext<CPP14Parser::RightShiftAssignContext>(0);//1165
}

tree::TerminalNode* CPP14Parser::TheoperatorContext::LeftShiftAssign()
{
	return getToken(CPP14Parser::LeftShiftAssign, 0);
}

tree::TerminalNode* CPP14Parser::TheoperatorContext::Equal()
{
	return getToken(CPP14Parser::Equal, 0);
}

tree::TerminalNode* CPP14Parser::TheoperatorContext::NotEqual()
{
	return getToken(CPP14Parser::NotEqual, 0);
}

tree::TerminalNode* CPP14Parser::TheoperatorContext::LessEqual()
{
	return getToken(CPP14Parser::LessEqual, 0);
}

tree::TerminalNode* CPP14Parser::TheoperatorContext::GreaterEqual()
{
	return getToken(CPP14Parser::GreaterEqual, 0);
}

tree::TerminalNode* CPP14Parser::TheoperatorContext::PlusPlus()
{
	return getToken(CPP14Parser::PlusPlus, 0);
}

tree::TerminalNode* CPP14Parser::TheoperatorContext::MinusMinus()
{
	return getToken(CPP14Parser::MinusMinus, 0);
}

tree::TerminalNode* CPP14Parser::TheoperatorContext::Comma()
{
	return getToken(CPP14Parser::Comma, 0);
}

tree::TerminalNode* CPP14Parser::TheoperatorContext::ArrowStar()
{
	return getToken(CPP14Parser::ArrowStar, 0);
}

tree::TerminalNode* CPP14Parser::TheoperatorContext::Arrow()
{
	return getToken(CPP14Parser::Arrow, 0);
}

tree::TerminalNode* CPP14Parser::TheoperatorContext::LeftParen()
{
	return getToken(CPP14Parser::LeftParen, 0);
}

tree::TerminalNode* CPP14Parser::TheoperatorContext::RightParen()
{
	return getToken(CPP14Parser::RightParen, 0);
}


size_t CPP14Parser::TheoperatorContext::getRuleIndex() const
{
	return CPP14Parser::RuleTheoperator;//688
}

void CPP14Parser::TheoperatorContext::copyFrom(TheoperatorContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::TheoperatorContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<TheoperatorContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::TheoperatorContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::TheoperatorContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::TheoperatorContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitTheoperator(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::TheoperatorContext* CPP14Parser::theoperator( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<TheoperatorContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 396, CPP14Parser::RuleTheoperator);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(2488);//830
		_errHandler->sync(this, ctx);
		switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 320, ctx))
		{
		case 1:
		{
			enterOuterAlt(ctx, 1);
			setState(2437);//958
			match(CPP14Parser::New,ctx);
			break;
		}

		case 2:
		{
			enterOuterAlt(ctx, 2);
			setState(2438);//958
			match(CPP14Parser::Delete,ctx);
			break;
		}

		case 3:
		{
			enterOuterAlt(ctx, 3);
			setState(2439);//958
			match(CPP14Parser::New,ctx);
			setState(2440);//958
			match(CPP14Parser::LeftBracket,ctx);
			setState(2441);//958
			match(CPP14Parser::RightBracket,ctx);
			break;
		}

		case 4:
		{
			enterOuterAlt(ctx, 4);
			setState(2442);//958
			match(CPP14Parser::Delete,ctx);
			setState(2443);//958
			match(CPP14Parser::LeftBracket,ctx);
			setState(2444);//958
			match(CPP14Parser::RightBracket,ctx);
			break;
		}

		case 5:
		{
			enterOuterAlt(ctx, 5);
			setState(2445);//958
			match(CPP14Parser::Plus,ctx);
			break;
		}

		case 6:
		{
			enterOuterAlt(ctx, 6);
			setState(2446);//958
			match(CPP14Parser::Minus,ctx);
			break;
		}

		case 7:
		{
			enterOuterAlt(ctx, 7);
			setState(2447);//958
			match(CPP14Parser::Star,ctx);
			break;
		}

		case 8:
		{
			enterOuterAlt(ctx, 8);
			setState(2448);//958
			match(CPP14Parser::Div,ctx);
			break;
		}

		case 9:
		{
			enterOuterAlt(ctx, 9);
			setState(2449);//958
			match(CPP14Parser::Mod,ctx);
			break;
		}

		case 10:
		{
			enterOuterAlt(ctx, 10);
			setState(2450);//958
			match(CPP14Parser::Caret,ctx);
			break;
		}

		case 11:
		{
			enterOuterAlt(ctx, 11);
			setState(2451);//958
			match(CPP14Parser::And,ctx);
			break;
		}

		case 12:
		{
			enterOuterAlt(ctx, 12);
			setState(2452);//958
			match(CPP14Parser::Or,ctx);
			break;
		}

		case 13:
		{
			enterOuterAlt(ctx, 13);
			setState(2453);//958
			match(CPP14Parser::Tilde,ctx);
			break;
		}

		case 14:
		{
			enterOuterAlt(ctx, 14);
			setState(2454);//958
			match(CPP14Parser::T__0,ctx);
			break;
		}

		case 15:
		{
			enterOuterAlt(ctx, 15);
			setState(2455);//958
			match(CPP14Parser::T__1,ctx);
			break;
		}

		case 16:
		{
			enterOuterAlt(ctx, 16);
			setState(2456);//958
			match(CPP14Parser::Assign,ctx);
			break;
		}

		case 17:
		{
			enterOuterAlt(ctx, 17);
			setState(2457);//958
			match(CPP14Parser::Less,ctx);
			break;
		}

		case 18:
		{
			enterOuterAlt(ctx, 18);
			setState(2458);//958
			match(CPP14Parser::GreaterThan,ctx);
			break;
		}

		case 19:
		{
			enterOuterAlt(ctx, 19);
			setState(2459);//958
			match(CPP14Parser::PlusAssign,ctx);
			break;
		}

		case 20:
		{
			enterOuterAlt(ctx, 20);
			setState(2460);//958
			match(CPP14Parser::MinusAssign,ctx);
			break;
		}

		case 21:
		{
			enterOuterAlt(ctx, 21);
			setState(2461);//958
			match(CPP14Parser::StarAssign,ctx);
			break;
		}

		case 22:
		{
			enterOuterAlt(ctx, 22);
			setState(2462);//958
			match(CPP14Parser::DivAssign,ctx);
			break;
		}

		case 23:
		{
			enterOuterAlt(ctx, 23);
			setState(2463);//958
			match(CPP14Parser::ModAssign,ctx);
			break;
		}

		case 24:
		{
			enterOuterAlt(ctx, 24);
			setState(2464);//958
			match(CPP14Parser::XorAssign,ctx);
			break;
		}

		case 25:
		{
			enterOuterAlt(ctx, 25);
			setState(2465);//958
			match(CPP14Parser::AndAssign,ctx);
			break;
		}

		case 26:
		{
			enterOuterAlt(ctx, 26);
			setState(2466);//958
			match(CPP14Parser::OrAssign,ctx);
			break;
		}

		case 27:
		{
			enterOuterAlt(ctx, 27);
			setState(2467);//958
			match(CPP14Parser::LeftShift,ctx);
			break;
		}

		case 28:
		{
			enterOuterAlt(ctx, 28);
			setState(2468); //951
			rightShift(ctx);
			break;
		}

		case 29:
		{
			enterOuterAlt(ctx, 29);
			setState(2469); //951
			rightShiftAssign(ctx);
			break;
		}

		case 30:
		{
			enterOuterAlt(ctx, 30);
			setState(2470);//958
			match(CPP14Parser::LeftShiftAssign,ctx);
			break;
		}

		case 31:
		{
			enterOuterAlt(ctx, 31);
			setState(2471);//958
			match(CPP14Parser::Equal,ctx);
			break;
		}

		case 32:
		{
			enterOuterAlt(ctx, 32);
			setState(2472);//958
			match(CPP14Parser::NotEqual,ctx);
			break;
		}

		case 33:
		{
			enterOuterAlt(ctx, 33);
			setState(2473);//958
			match(CPP14Parser::LessEqual,ctx);
			break;
		}

		case 34:
		{
			enterOuterAlt(ctx, 34);
			setState(2474);//958
			match(CPP14Parser::GreaterEqual,ctx);
			break;
		}

		case 35:
		{
			enterOuterAlt(ctx, 35);
			setState(2475);//958
			match(CPP14Parser::T__2,ctx);
			break;
		}

		case 36:
		{
			enterOuterAlt(ctx, 36);
			setState(2476);//958
			match(CPP14Parser::T__3,ctx);
			break;
		}

		case 37:
		{
			enterOuterAlt(ctx, 37);
			setState(2477);//958
			match(CPP14Parser::T__4,ctx);
			break;
		}

		case 38:
		{
			enterOuterAlt(ctx, 38);
			setState(2478);//958
			match(CPP14Parser::T__5,ctx);
			break;
		}

		case 39:
		{
			enterOuterAlt(ctx, 39);
			setState(2479);//958
			match(CPP14Parser::PlusPlus,ctx);
			break;
		}

		case 40:
		{
			enterOuterAlt(ctx, 40);
			setState(2480);//958
			match(CPP14Parser::MinusMinus,ctx);
			break;
		}

		case 41:
		{
			enterOuterAlt(ctx, 41);
			setState(2481);//958
			match(CPP14Parser::Comma,ctx);
			break;
		}

		case 42:
		{
			enterOuterAlt(ctx, 42);
			setState(2482);//958
			match(CPP14Parser::ArrowStar,ctx);
			break;
		}

		case 43:
		{
			enterOuterAlt(ctx, 43);
			setState(2483);//958
			match(CPP14Parser::Arrow,ctx);
			break;
		}

		case 44:
		{
			enterOuterAlt(ctx, 44);
			setState(2484);//958
			match(CPP14Parser::LeftParen,ctx);
			setState(2485);//958
			match(CPP14Parser::RightParen,ctx);
			break;
		}

		case 45:
		{
			enterOuterAlt(ctx, 45);
			setState(2486);//958
			match(CPP14Parser::LeftBracket,ctx);
			setState(2487);//958
			match(CPP14Parser::RightBracket,ctx);
			break;
		}

		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::TheoperatorContext> CPP14Parser::parsetheoperator()
{
	theoperator();
	auto result = std::unique_ptr<TheoperatorContext>(dynamic_cast<TheoperatorContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- LiteralContext ------------------------------------------------------------------

CPP14Parser::LiteralContext::LiteralContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::LiteralContext::Integerliteral()
{
	return getToken(CPP14Parser::Integerliteral, 0);
}

tree::TerminalNode* CPP14Parser::LiteralContext::Characterliteral()
{
	return getToken(CPP14Parser::Characterliteral, 0);
}

tree::TerminalNode* CPP14Parser::LiteralContext::Floatingliteral()
{
	return getToken(CPP14Parser::Floatingliteral, 0);
}

tree::TerminalNode* CPP14Parser::LiteralContext::Stringliteral()
{
	return getToken(CPP14Parser::Stringliteral, 0);
}

CPP14Parser::BooleanliteralContext* CPP14Parser::LiteralContext::booleanliteral()
{
	return getRuleContext<CPP14Parser::BooleanliteralContext>(0);//1165
}

CPP14Parser::PointerliteralContext* CPP14Parser::LiteralContext::pointerliteral()
{
	return getRuleContext<CPP14Parser::PointerliteralContext>(0);//1165
}

CPP14Parser::UserdefinedliteralContext* CPP14Parser::LiteralContext::userdefinedliteral()
{
	return getRuleContext<CPP14Parser::UserdefinedliteralContext>(0);//1165
}


size_t CPP14Parser::LiteralContext::getRuleIndex() const
{
	return CPP14Parser::RuleLiteral;//688
}

void CPP14Parser::LiteralContext::copyFrom(LiteralContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::LiteralContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<LiteralContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::LiteralContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::LiteralContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::LiteralContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitLiteral(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::LiteralContext* CPP14Parser::literal( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<LiteralContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 398, CPP14Parser::RuleLiteral);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		setState(2497);//750
		_errHandler->sync(this, ctx);
		switch (_input->LA(1))
		{
			case CPP14Parser::Integerliteral:
			{
				enterOuterAlt(ctx, 1);
				setState(2490);//958
				match(CPP14Parser::Integerliteral,ctx);
				break;
			}

			case CPP14Parser::Characterliteral:
			{
				enterOuterAlt(ctx, 2);
				setState(2491);//958
				match(CPP14Parser::Characterliteral,ctx);
				break;
			}

			case CPP14Parser::Floatingliteral:
			{
				enterOuterAlt(ctx, 3);
				setState(2492);//958
				match(CPP14Parser::Floatingliteral,ctx);
				break;
			}

			case CPP14Parser::Stringliteral:
			{
				enterOuterAlt(ctx, 4);
				setState(2493);//958
				match(CPP14Parser::Stringliteral,ctx);
				break;
			}

			case CPP14Parser::False:
			case CPP14Parser::True:
			{
				enterOuterAlt(ctx, 5);
				setState(2494); //951
				booleanliteral(ctx);
				break;
			}

			case CPP14Parser::Nullptr:
			{
				enterOuterAlt(ctx, 6);
				setState(2495); //951
				pointerliteral(ctx);
				break;
			}

			case CPP14Parser::Userdefinedintegerliteral:
			case CPP14Parser::Userdefinedfloatingliteral:
			case CPP14Parser::Userdefinedstringliteral:
			case CPP14Parser::Userdefinedcharacterliteral:
			{
				enterOuterAlt(ctx, 7);
				setState(2496); //951
				userdefinedliteral(ctx);
				break;
			}

		default:
			throw NoViableAltException(this, ctx);
		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::LiteralContext> CPP14Parser::parseliteral()
{
	literal();
	auto result = std::unique_ptr<LiteralContext>(dynamic_cast<LiteralContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- BooleanliteralContext ------------------------------------------------------------------

CPP14Parser::BooleanliteralContext::BooleanliteralContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::BooleanliteralContext::False()
{
	return getToken(CPP14Parser::False, 0);
}

tree::TerminalNode* CPP14Parser::BooleanliteralContext::True()
{
	return getToken(CPP14Parser::True, 0);
}


size_t CPP14Parser::BooleanliteralContext::getRuleIndex() const
{
	return CPP14Parser::RuleBooleanliteral;//688
}

void CPP14Parser::BooleanliteralContext::copyFrom(BooleanliteralContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::BooleanliteralContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<BooleanliteralContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::BooleanliteralContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::BooleanliteralContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::BooleanliteralContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitBooleanliteral(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::BooleanliteralContext* CPP14Parser::booleanliteral( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<BooleanliteralContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 400, CPP14Parser::RuleBooleanliteral);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(2499);//970
		_la = _input->LA(1);
		if (!(_la == CPP14Parser::False

		|| _la == CPP14Parser::True))
		{
		_errHandler->recoverInline(this, ctx);
		}
		else
		{
			_errHandler->reportMatch(this);
			consume(ctx);
		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::BooleanliteralContext> CPP14Parser::parsebooleanliteral()
{
	booleanliteral();
	auto result = std::unique_ptr<BooleanliteralContext>(dynamic_cast<BooleanliteralContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- PointerliteralContext ------------------------------------------------------------------

CPP14Parser::PointerliteralContext::PointerliteralContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::PointerliteralContext::Nullptr()
{
	return getToken(CPP14Parser::Nullptr, 0);
}


size_t CPP14Parser::PointerliteralContext::getRuleIndex() const
{
	return CPP14Parser::RulePointerliteral;//688
}

void CPP14Parser::PointerliteralContext::copyFrom(PointerliteralContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::PointerliteralContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<PointerliteralContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::PointerliteralContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::PointerliteralContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::PointerliteralContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitPointerliteral(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::PointerliteralContext* CPP14Parser::pointerliteral( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<PointerliteralContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 402, CPP14Parser::RulePointerliteral);

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(2501);//958
		match(CPP14Parser::Nullptr,ctx);
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::PointerliteralContext> CPP14Parser::parsepointerliteral()
{
	pointerliteral();
	auto result = std::unique_ptr<PointerliteralContext>(dynamic_cast<PointerliteralContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


//----------------- UserdefinedliteralContext ------------------------------------------------------------------

CPP14Parser::UserdefinedliteralContext::UserdefinedliteralContext(antlr4::ParserRuleContext *parent, size_t invokingState)
	: antlr4::ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* CPP14Parser::UserdefinedliteralContext::Userdefinedintegerliteral()
{
	return getToken(CPP14Parser::Userdefinedintegerliteral, 0);
}

tree::TerminalNode* CPP14Parser::UserdefinedliteralContext::Userdefinedfloatingliteral()
{
	return getToken(CPP14Parser::Userdefinedfloatingliteral, 0);
}

tree::TerminalNode* CPP14Parser::UserdefinedliteralContext::Userdefinedstringliteral()
{
	return getToken(CPP14Parser::Userdefinedstringliteral, 0);
}

tree::TerminalNode* CPP14Parser::UserdefinedliteralContext::Userdefinedcharacterliteral()
{
	return getToken(CPP14Parser::Userdefinedcharacterliteral, 0);
}


size_t CPP14Parser::UserdefinedliteralContext::getRuleIndex() const
{
	return CPP14Parser::RuleUserdefinedliteral;//688
}

void CPP14Parser::UserdefinedliteralContext::copyFrom(UserdefinedliteralContext *ctx)
{
	antlr4::ParserRuleContext::copyFrom(ctx);
}

std::unique_ptr<antlr4::tree::ParseTree> CPP14Parser::UserdefinedliteralContext::clone(ParseTree* parent) const
{
	auto result = std::make_unique<UserdefinedliteralContext>();
	result->copyFrom(this);
	result->parent = parent;
	return result;
}
void CPP14Parser::UserdefinedliteralContext::enterRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->enter(this);
}

void CPP14Parser::UserdefinedliteralContext::exitRule(not_null<tree::ParseTreeListener*> listener)
{
	auto parserListener = dynamic_cast<CPP14Listener *>(listener.get());//1212
	if (parserListener != nullptr)
		parserListener->exit(this);
}


antlrcpp::Any CPP14Parser::UserdefinedliteralContext::accept(tree::ParseTreeVisitor *visitor)
{
	if (auto parserVisitor = dynamic_cast<CPP14Visitor*>(visitor))//1226
		return parserVisitor->visitUserdefinedliteral(this);
	else
		return visitor->visitChildren(this);
}

CPP14Parser::UserdefinedliteralContext* CPP14Parser::userdefinedliteral( antlr4::ParserRuleContext *parent)
{
#ifdef PARSER_DEBUG
	if(parent != nullptr)
		std::cout<<parent->getText()<<std::endl;
#endif
	auto _localctx = std::make_unique<UserdefinedliteralContext>(parent, getState());//549
	auto ctx = _localctx.get();//549
	enterRule(std::move(_localctx), 404, CPP14Parser::RuleUserdefinedliteral);
	size_t _la = 0;

	auto onExit = finally([=]
{
		exitRule(ctx);
	});
	try
{
		enterOuterAlt(ctx, 1);
		setState(2503);//970
		_la = _input->LA(1);
		if (!(((((_la - 140) & ~ 0x3fULL) == 0) &&
			((1ULL << (_la - 140)) & ((1ULL << (CPP14Parser::Userdefinedintegerliteral - 140))
			| (1ULL << (CPP14Parser::Userdefinedfloatingliteral - 140))
			| (1ULL << (CPP14Parser::Userdefinedstringliteral - 140))
			| (1ULL << (CPP14Parser::Userdefinedcharacterliteral - 140)))) != 0)))
		{
		_errHandler->recoverInline(this, ctx);
		}
		else
		{
			_errHandler->reportMatch(this);
			consume(ctx);
		}
	 
	}
	catch (RecognitionException &e)
{
		_errHandler->reportError(this, e, ctx);
		ctx->exception = std::current_exception();
		_errHandler->recover(this, ctx->exception, ctx);
	}

	return ctx;
}

std::unique_ptr< CPP14Parser::UserdefinedliteralContext> CPP14Parser::parseuserdefinedliteral()
{
	userdefinedliteral();
	auto result = std::unique_ptr<UserdefinedliteralContext>(dynamic_cast<UserdefinedliteralContext*>(_root.release()));
	assert(result != nullptr);
	return result;
}


bool CPP14Parser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex)
{
	switch (ruleIndex)
{
		case 5: return nestednamespecifierSempred(dynamic_cast<NestednamespecifierContext *>(context), predicateIndex);

		case 10: return capturelistSempred(dynamic_cast<CapturelistContext *>(context), predicateIndex);

		case 15: return postfixexpressionSempred(dynamic_cast<PostfixexpressionContext *>(context), predicateIndex);

		case 26: return noptrnewdeclaratorSempred(dynamic_cast<NoptrnewdeclaratorContext *>(context), predicateIndex);

		case 31: return pmexpressionSempred(dynamic_cast<PmexpressionContext *>(context), predicateIndex);

		case 32: return multiplicativeexpressionSempred(dynamic_cast<MultiplicativeexpressionContext *>(context), predicateIndex);

		case 33: return additiveexpressionSempred(dynamic_cast<AdditiveexpressionContext *>(context), predicateIndex);

		case 34: return shiftexpressionSempred(dynamic_cast<ShiftexpressionContext *>(context), predicateIndex);

		case 36: return relationalexpressionSempred(dynamic_cast<RelationalexpressionContext *>(context), predicateIndex);

		case 37: return equalityexpressionSempred(dynamic_cast<EqualityexpressionContext *>(context), predicateIndex);

		case 38: return andexpressionSempred(dynamic_cast<AndexpressionContext *>(context), predicateIndex);

		case 39: return exclusiveorexpressionSempred(dynamic_cast<ExclusiveorexpressionContext *>(context), predicateIndex);

		case 40: return inclusiveorexpressionSempred(dynamic_cast<InclusiveorexpressionContext *>(context), predicateIndex);

		case 41: return logicalandexpressionSempred(dynamic_cast<LogicalandexpressionContext *>(context), predicateIndex);

		case 42: return logicalorexpressionSempred(dynamic_cast<LogicalorexpressionContext *>(context), predicateIndex);

		case 46: return expressionSempred(dynamic_cast<ExpressionContext *>(context), predicateIndex);

		case 52: return statementseqSempred(dynamic_cast<StatementseqContext *>(context), predicateIndex);

		case 89: return enumeratorlistSempred(dynamic_cast<EnumeratorlistContext *>(context), predicateIndex);

		case 107: return attributespecifierseqSempred(dynamic_cast<AttributespecifierseqContext *>(context), predicateIndex);

		case 110: return attributelistSempred(dynamic_cast<AttributelistContext *>(context), predicateIndex);

		case 116: return balancedtokenseqSempred(dynamic_cast<BalancedtokenseqContext *>(context), predicateIndex);

		case 118: return initdeclaratorlistSempred(dynamic_cast<InitdeclaratorlistContext *>(context), predicateIndex);

		case 122: return noptrdeclaratorSempred(dynamic_cast<NoptrdeclaratorContext *>(context), predicateIndex);

		case 133: return noptrabstractdeclaratorSempred(dynamic_cast<NoptrabstractdeclaratorContext *>(context), predicateIndex);

		case 135: return noptrabstractpackdeclaratorSempred(dynamic_cast<NoptrabstractpackdeclaratorContext *>(context), predicateIndex);

		case 137: return parameterdeclarationlistSempred(dynamic_cast<ParameterdeclarationlistContext *>(context), predicateIndex);

		case 144: return initializerlistSempred(dynamic_cast<InitializerlistContext *>(context), predicateIndex);

		case 154: return memberdeclaratorlistSempred(dynamic_cast<MemberdeclaratorlistContext *>(context), predicateIndex);

		case 156: return virtspecifierseqSempred(dynamic_cast<VirtspecifierseqContext *>(context), predicateIndex);

		case 160: return basespecifierlistSempred(dynamic_cast<BasespecifierlistContext *>(context), predicateIndex);

		case 175: return templateparameterlistSempred(dynamic_cast<TemplateparameterlistContext *>(context), predicateIndex);

		case 181: return templateargumentlistSempred(dynamic_cast<TemplateargumentlistContext *>(context), predicateIndex);

		case 194: return typeidlistSempred(dynamic_cast<TypeidlistContext *>(context), predicateIndex);//430

	default:
		break;
	}
	return true;
}

bool CPP14Parser::nestednamespecifierSempred(NestednamespecifierContext *_localctx, size_t predicateIndex)
{
	switch (predicateIndex)
{
		case 0: return precpred(nullptr, 2);
		case 1: return precpred(nullptr, 1);

	default:
		break;
	}
	return true;
}

bool CPP14Parser::capturelistSempred(CapturelistContext *_localctx, size_t predicateIndex)
{
	switch (predicateIndex)
{
		case 2: return precpred(nullptr, 1);

	default:
		break;
	}
	return true;
}

bool CPP14Parser::postfixexpressionSempred(PostfixexpressionContext *_localctx, size_t predicateIndex)
{
	switch (predicateIndex)
{
		case 3: return precpred(nullptr, 19);
		case 4: return precpred(nullptr, 18);
		case 5: return precpred(nullptr, 17);
		case 6: return precpred(nullptr, 12);
		case 7: return precpred(nullptr, 11);
		case 8: return precpred(nullptr, 10);
		case 9: return precpred(nullptr, 9);
		case 10: return precpred(nullptr, 8);
		case 11: return precpred(nullptr, 7);

	default:
		break;
	}
	return true;
}

bool CPP14Parser::noptrnewdeclaratorSempred(NoptrnewdeclaratorContext *_localctx, size_t predicateIndex)
{
	switch (predicateIndex)
{
		case 12: return precpred(nullptr, 1);

	default:
		break;
	}
	return true;
}

bool CPP14Parser::pmexpressionSempred(PmexpressionContext *_localctx, size_t predicateIndex)
{
	switch (predicateIndex)
{
		case 13: return precpred(nullptr, 2);
		case 14: return precpred(nullptr, 1);

	default:
		break;
	}
	return true;
}

bool CPP14Parser::multiplicativeexpressionSempred(MultiplicativeexpressionContext *_localctx, size_t predicateIndex)
{
	switch (predicateIndex)
{
		case 15: return precpred(nullptr, 3);
		case 16: return precpred(nullptr, 2);
		case 17: return precpred(nullptr, 1);

	default:
		break;
	}
	return true;
}

bool CPP14Parser::additiveexpressionSempred(AdditiveexpressionContext *_localctx, size_t predicateIndex)
{
	switch (predicateIndex)
{
		case 18: return precpred(nullptr, 2);
		case 19: return precpred(nullptr, 1);

	default:
		break;
	}
	return true;
}

bool CPP14Parser::shiftexpressionSempred(ShiftexpressionContext *_localctx, size_t predicateIndex)
{
	switch (predicateIndex)
{
		case 20: return precpred(nullptr, 1);

	default:
		break;
	}
	return true;
}

bool CPP14Parser::relationalexpressionSempred(RelationalexpressionContext *_localctx, size_t predicateIndex)
{
	switch (predicateIndex)
{
		case 21: return precpred(nullptr, 4);
		case 22: return precpred(nullptr, 3);
		case 23: return precpred(nullptr, 2);
		case 24: return precpred(nullptr, 1);

	default:
		break;
	}
	return true;
}

bool CPP14Parser::equalityexpressionSempred(EqualityexpressionContext *_localctx, size_t predicateIndex)
{
	switch (predicateIndex)
{
		case 25: return precpred(nullptr, 2);
		case 26: return precpred(nullptr, 1);

	default:
		break;
	}
	return true;
}

bool CPP14Parser::andexpressionSempred(AndexpressionContext *_localctx, size_t predicateIndex)
{
	switch (predicateIndex)
{
		case 27: return precpred(nullptr, 1);

	default:
		break;
	}
	return true;
}

bool CPP14Parser::exclusiveorexpressionSempred(ExclusiveorexpressionContext *_localctx, size_t predicateIndex)
{
	switch (predicateIndex)
{
		case 28: return precpred(nullptr, 1);

	default:
		break;
	}
	return true;
}

bool CPP14Parser::inclusiveorexpressionSempred(InclusiveorexpressionContext *_localctx, size_t predicateIndex)
{
	switch (predicateIndex)
{
		case 29: return precpred(nullptr, 1);

	default:
		break;
	}
	return true;
}

bool CPP14Parser::logicalandexpressionSempred(LogicalandexpressionContext *_localctx, size_t predicateIndex)
{
	switch (predicateIndex)
{
		case 30: return precpred(nullptr, 2);
		case 31: return precpred(nullptr, 1);

	default:
		break;
	}
	return true;
}

bool CPP14Parser::logicalorexpressionSempred(LogicalorexpressionContext *_localctx, size_t predicateIndex)
{
	switch (predicateIndex)
{
		case 32: return precpred(nullptr, 2);
		case 33: return precpred(nullptr, 1);

	default:
		break;
	}
	return true;
}

bool CPP14Parser::expressionSempred(ExpressionContext *_localctx, size_t predicateIndex)
{
	switch (predicateIndex)
{
		case 34: return precpred(nullptr, 1);

	default:
		break;
	}
	return true;
}

bool CPP14Parser::statementseqSempred(StatementseqContext *_localctx, size_t predicateIndex)
{
	switch (predicateIndex)
{
		case 35: return precpred(nullptr, 1);

	default:
		break;
	}
	return true;
}

bool CPP14Parser::enumeratorlistSempred(EnumeratorlistContext *_localctx, size_t predicateIndex)
{
	switch (predicateIndex)
{
		case 36: return precpred(nullptr, 1);

	default:
		break;
	}
	return true;
}

bool CPP14Parser::attributespecifierseqSempred(AttributespecifierseqContext *_localctx, size_t predicateIndex)
{
	switch (predicateIndex)
{
		case 37: return precpred(nullptr, 1);

	default:
		break;
	}
	return true;
}

bool CPP14Parser::attributelistSempred(AttributelistContext *_localctx, size_t predicateIndex)
{
	switch (predicateIndex)
{
		case 38: return precpred(nullptr, 3);
		case 39: return precpred(nullptr, 1);

	default:
		break;
	}
	return true;
}

bool CPP14Parser::balancedtokenseqSempred(BalancedtokenseqContext *_localctx, size_t predicateIndex)
{
	switch (predicateIndex)
{
		case 40: return precpred(nullptr, 1);

	default:
		break;
	}
	return true;
}

bool CPP14Parser::initdeclaratorlistSempred(InitdeclaratorlistContext *_localctx, size_t predicateIndex)
{
	switch (predicateIndex)
{
		case 41: return precpred(nullptr, 1);

	default:
		break;
	}
	return true;
}

bool CPP14Parser::noptrdeclaratorSempred(NoptrdeclaratorContext *_localctx, size_t predicateIndex)
{
	switch (predicateIndex)
{
		case 42: return precpred(nullptr, 3);
		case 43: return precpred(nullptr, 2);

	default:
		break;
	}
	return true;
}

bool CPP14Parser::noptrabstractdeclaratorSempred(NoptrabstractdeclaratorContext *_localctx, size_t predicateIndex)
{
	switch (predicateIndex)
{
		case 44: return precpred(nullptr, 5);
		case 45: return precpred(nullptr, 3);

	default:
		break;
	}
	return true;
}

bool CPP14Parser::noptrabstractpackdeclaratorSempred(NoptrabstractpackdeclaratorContext *_localctx, size_t predicateIndex)
{
	switch (predicateIndex)
{
		case 46: return precpred(nullptr, 3);
		case 47: return precpred(nullptr, 2);

	default:
		break;
	}
	return true;
}

bool CPP14Parser::parameterdeclarationlistSempred(ParameterdeclarationlistContext *_localctx, size_t predicateIndex)
{
	switch (predicateIndex)
{
		case 48: return precpred(nullptr, 1);

	default:
		break;
	}
	return true;
}

bool CPP14Parser::initializerlistSempred(InitializerlistContext *_localctx, size_t predicateIndex)
{
	switch (predicateIndex)
{
		case 49: return precpred(nullptr, 1);

	default:
		break;
	}
	return true;
}

bool CPP14Parser::memberdeclaratorlistSempred(MemberdeclaratorlistContext *_localctx, size_t predicateIndex)
{
	switch (predicateIndex)
{
		case 50: return precpred(nullptr, 1);

	default:
		break;
	}
	return true;
}

bool CPP14Parser::virtspecifierseqSempred(VirtspecifierseqContext *_localctx, size_t predicateIndex)
{
	switch (predicateIndex)
{
		case 51: return precpred(nullptr, 1);

	default:
		break;
	}
	return true;
}

bool CPP14Parser::basespecifierlistSempred(BasespecifierlistContext *_localctx, size_t predicateIndex)
{
	switch (predicateIndex)
{
		case 52: return precpred(nullptr, 1);

	default:
		break;
	}
	return true;
}

bool CPP14Parser::templateparameterlistSempred(TemplateparameterlistContext *_localctx, size_t predicateIndex)
{
	switch (predicateIndex)
{
		case 53: return precpred(nullptr, 1);

	default:
		break;
	}
	return true;
}

bool CPP14Parser::templateargumentlistSempred(TemplateargumentlistContext *_localctx, size_t predicateIndex)
{
	switch (predicateIndex)
{
		case 54: return precpred(nullptr, 1);

	default:
		break;
	}
	return true;
}

bool CPP14Parser::typeidlistSempred(TypeidlistContext *_localctx, size_t predicateIndex)
{
	switch (predicateIndex)
{
		case 55: return precpred(nullptr, 1);

	default:
		break;
	}
	return true;
}

// Static vars and initialization.
std::vector<dfa::DFA> CPP14Parser::_decisionToDFA;
atn::PredictionContextCache CPP14Parser::_sharedContextCache;

// We own the ATN which in turn owns the ATN states.
atn::ATN CPP14Parser::_atn;
std::vector<uint16_t> CPP14Parser::_serializedATN;

std::vector<std::string_view> CPP14Parser::_ruleNames =
{
	"translationunit", "primaryexpression", "idexpression", "unqualifiedid", 
	"qualifiedid", "nestednamespecifier", "lambdaexpression", "lambdaintroducer", 
	"lambdacapture", "capturedefault", "capturelist", "capture", "simplecapture", 
	"initcapture", "lambdadeclarator", "postfixexpression", "typeidofexpr", 
	"typeidofthetypeid", "expressionlist", "pseudodestructorname", "unaryexpression", 
	"unaryoperator", "newexpression", "newplacement", "newtypeid", "newdeclarator", 
	"noptrnewdeclarator", "newinitializer", "deleteexpression", "noexceptexpression", 
	"castexpression", "pmexpression", "multiplicativeexpression", "additiveexpression", 
	"shiftexpression", "shiftoperator", "relationalexpression", "equalityexpression", 
	"andexpression", "exclusiveorexpression", "inclusiveorexpression", "logicalandexpression", 
	"logicalorexpression", "conditionalexpression", "assignmentexpression", 
	"assignmentoperator", "expression", "constantexpression", "statement", 
	"labeledstatement", "expressionstatement", "compoundstatement", "statementseq", 
	"selectionstatement", "condition", "iterationstatement", "forinitstatement", 
	"forrangedeclaration", "forrangeinitializer", "jumpstatement", "declarationstatement", 
	"declarationseq", "declaration", "preprocessorDirective", "blockdeclaration", 
	"aliasdeclaration", "simpledeclaration", "static_assertdeclaration", "emptydeclaration", 
	"attributedeclaration", "declspecifier", "declspecifierseq", "storageclassspecifier", 
	"functionspecifier", "typedefname", "typespecifier", "trailingtypespecifier", 
	"typespecifierseq", "trailingtypespecifierseq", "simpletypespecifier", 
	"thetypename", "decltypespecifier", "elaboratedtypespecifier", "enumname", 
	"enumspecifier", "enumhead", "opaqueenumdeclaration", "enumkey", "enumbase", 
	"enumeratorlist", "enumeratordefinition", "enumerator", "namespacename", 
	"originalnamespacename", "namespacedefinition", "namednamespacedefinition", 
	"originalnamespacedefinition", "extensionnamespacedefinition", "unnamednamespacedefinition", 
	"namespacebody", "namespacealias", "namespacealiasdefinition", "qualifiednamespacespecifier", 
	"usingdeclaration", "usingdirective", "asmdefinition", "linkagespecification", 
	"attributespecifierseq", "attributespecifier", "alignmentspecifier", "attributelist", 
	"attribute", "attributetoken", "attributescopedtoken", "attributenamespace", 
	"attributeargumentclause", "balancedtokenseq", "balancedtoken", "initdeclaratorlist", 
	"initdeclarator", "declarator", "ptrdeclarator", "noptrdeclarator", "parametersandqualifiers", 
	"trailingreturntype", "ptroperator", "cvqualifierseq", "cvqualifier", "refqualifier", 
	"declaratorid", "thetypeid", "abstractdeclarator", "ptrabstractdeclarator", 
	"noptrabstractdeclarator", "abstractpackdeclarator", "noptrabstractpackdeclarator", 
	"parameterdeclarationclause", "parameterdeclarationlist", "parameterdeclaration", 
	"functiondefinition", "functionbody", "initializer", "braceorequalinitializer", 
	"initializerclause", "initializerlist", "bracedinitlist", "classname", 
	"classspecifier", "classhead", "classheadname", "classvirtspecifier", "classkey", 
	"memberspecification", "memberdeclaration", "memberdeclaratorlist", "memberdeclarator", 
	"virtspecifierseq", "virtspecifier", "purespecifier", "baseclause", "basespecifierlist", 
	"basespecifier", "classordecltype", "basetypespecifier", "accessspecifier", 
	"conversionfunctionid", "conversiontypeid", "conversiondeclarator", "ctorinitializer", 
	"meminitializerlist", "meminitializer", "meminitializerid", "operatorfunctionid", 
	"literaloperatorid", "templatedeclaration", "templateparameterlist", "templateparameter", 
	"typeparameter", "simpletemplateid", "templateid", "templatename", "templateargumentlist", 
	"templateargument", "typenamespecifier", "explicitinstantiation", "explicitspecialization", 
	"tryblock", "functiontryblock", "handlerseq", "handler", "exceptiondeclaration", 
	"throwexpression", "exceptionspecification", "dynamicexceptionspecification", 
	"typeidlist", "noexceptspecification", "rightShift", "rightShiftAssign", 
	"theoperator", "literal", "booleanliteral", "pointerliteral", "userdefinedliteral"
};

std::vector<std::string_view> CPP14Parser::_literalNames =
{
	"", "'!'", "'not'", "'&&'", "'and'", "'||'", "'or'", "", "", "'alignas'", 
	"'alignof'", "'asm'", "'auto'", "'bool'", "'break'", "'case'", "'catch'", 
	"'char'", "'char16_t'", "'char32_t'", "'class'", "'const'", "'constexpr'", 
	"'const_cast'", "'continue'", "'decltype'", "'default'", "'delete'", "'do'", 
	"'double'", "'dynamic_cast'", "'else'", "'enum'", "'explicit'", "'export'", 
	"'extern'", "'false'", "'final'", "'float'", "'for'", "'friend'", "'goto'", 
	"'if'", "'inline'", "'int'", "'long'", "'mutable'", "'namespace'", "'new'", 
	"'noexcept'", "'nullptr'", "'operator'", "'override'", "'private'", "'protected'", 
	"'public'", "'register'", "'reinterpret_cast'", "'return'", "'short'", 
	"'signed'", "'sizeof'", "'static'", "'static_assert'", "'static_cast'", 
	"'struct'", "'switch'", "'template'", "'this'", "'thread_local'", "'throw'", 
	"'true'", "'try'", "'typedef'", "'typeid'", "'typename'", "'union'", "'unsigned'", 
	"'using'", "'virtual'", "'void'", "'volatile'", "'wchar_t'", "'while'", 
	"'('", "')'", "'['", "']'", "'{'", "'}'", "'+'", "'-'", "'*'", "'/'", "'%'", 
	"'^'", "'&'", "'|'", "'~'", "", "'='", "'<'", "'+='", "'-='", "'*='", "'/='", 
	"'%='", "'^='", "'&='", "'|='", "'<<'", "'<<='", "'=='", "'!='", "'<='", 
	"'>='", "", "", "'++'", "'--'", "','", "'->*'", "'->'", "'?'", "':'", "'::'", 
	"';'", "'.'", "'.*'", "'...'", "", "", "", "", "", "", "", "", "", "", 
	"", "", "", "", "", "", "", "", "'>'"
};

std::vector<std::string_view> CPP14Parser::_symbolicNames =
{
	"", "", "", "", "", "", "", "MultiLineMacro", "Directive", "Alignas", "Alignof", 
	"Asm", "Auto", "Bool", "Break", "Case", "Catch", "Char", "Char16", "Char32", 
	"Class", "Const", "Constexpr", "Const_cast", "Continue", "Decltype", "Default", 
	"Delete", "Do", "Double", "Dynamic_cast", "Else", "Enum", "Explicit", "Export", 
	"Extern", "False", "Final", "Float", "For", "Friend", "Goto", "If", "Inline", 
	"Int", "Long", "Mutable", "Namespace", "New", "Noexcept", "Nullptr", "Operator", 
	"Override", "Private", "Protected", "Public", "Register", "Reinterpret_cast", 
	"Return", "Short", "Signed", "Sizeof", "Static", "Static_assert", "Static_cast", 
	"Struct", "Switch", "Template", "This", "Thread_local", "Throw", "True", 
	"Try", "Typedef", "Typeid_", "Typename_", "Union", "Unsigned", "Using", 
	"Virtual", "Void", "Volatile", "Wchar", "While", "LeftParen", "RightParen", 
	"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "Plus", "Minus", 
	"Star", "Div", "Mod", "Caret", "And", "Or", "Tilde", "Not", "Assign", "Less", 
	"PlusAssign", "MinusAssign", "StarAssign", "DivAssign", "ModAssign", "XorAssign", 
	"AndAssign", "OrAssign", "LeftShift", "LeftShiftAssign", "Equal", "NotEqual", 
	"LessEqual", "GreaterEqual", "AndAnd", "OrOr", "PlusPlus", "MinusMinus", 
	"Comma", "ArrowStar", "Arrow", "Question", "Colon", "Doublecolon", "Semi", 
	"Dot", "DotStar", "Ellipsis", "Identifier", "Integerliteral", "Decimalliteral", 
	"Octalliteral", "Hexadecimalliteral", "Binaryliteral", "Integersuffix", 
	"Characterliteral", "Floatingliteral", "Stringliteral", "Userdefinedintegerliteral", 
	"Userdefinedfloatingliteral", "Userdefinedstringliteral", "Userdefinedcharacterliteral", 
	"Whitespace", "Newline", "BlockComment", "LineComment", "GreaterThan"
};

dfa::Vocabulary CPP14Parser::_vocabulary(_literalNames, _symbolicNames);

std::vector<std::string_view> CPP14Parser::_tokenNames;

CPP14Parser::Initializer::Initializer()
{
	for (size_t i = 0; i < _symbolicNames.size(); ++i)
{
		auto name = _vocabulary.getLiteralName(i);
		if (name.empty())
{
			name = _vocabulary.getSymbolicName(i);
		}

		if (name.empty())
{
			_tokenNames.push_back("<INVALID>");
		} else
{
			_tokenNames.push_back(name);
		}
	}

	static uint16_t serializedATNSegment0[] =
	{
		0x3, 0x608b, 0xa72a, 0x8133, 0xb9ed, 0x417c, 0x3be7, 0x7786, 0x5964, 0x3, 
			 0x96, 0x9cc, 0x4, 0x2, 0x9, 0x2, 0x4, 0x3, 0x9, 0x3, 0x4, 0x4, 0x9, 
			 0x4, 0x4, 0x5, 0x9, 0x5, 0x4, 0x6, 0x9, 0x6, 0x4, 0x7, 0x9, 0x7, 0x4, 
			 0x8, 0x9, 0x8, 0x4, 0x9, 0x9, 0x9, 0x4, 0xa, 0x9, 0xa, 0x4, 0xb, 0x9, 
			 0xb, 0x4, 0xc, 0x9, 0xc, 0x4, 0xd, 0x9, 0xd, 0x4, 0xe, 0x9, 0xe, 0x4, 
			 0xf, 0x9, 0xf, 0x4, 0x10, 0x9, 0x10, 0x4, 0x11, 0x9, 0x11, 0x4, 0x12, 
			 0x9, 0x12, 0x4, 0x13, 0x9, 0x13, 0x4, 0x14, 0x9, 0x14, 0x4, 0x15, 0x9, 
			 0x15, 0x4, 0x16, 0x9, 0x16, 0x4, 0x17, 0x9, 0x17, 0x4, 0x18, 0x9, 0x18, 
			 0x4, 0x19, 0x9, 0x19, 0x4, 0x1a, 0x9, 0x1a, 0x4, 0x1b, 0x9, 0x1b, 0x4, 
			 0x1c, 0x9, 0x1c, 0x4, 0x1d, 0x9, 0x1d, 0x4, 0x1e, 0x9, 0x1e, 0x4, 0x1f, 
			 0x9, 0x1f, 0x4, 0x20, 0x9, 0x20, 0x4, 0x21, 0x9, 0x21, 0x4, 0x22, 0x9, 
			 0x22, 0x4, 0x23, 0x9, 0x23, 0x4, 0x24, 0x9, 0x24, 0x4, 0x25, 0x9, 0x25, 
			 0x4, 0x26, 0x9, 0x26, 0x4, 0x27, 0x9, 0x27, 0x4, 0x28, 0x9, 0x28, 0x4, 
			 0x29, 0x9, 0x29, 0x4, 0x2a, 0x9, 0x2a, 0x4, 0x2b, 0x9, 0x2b, 0x4, 0x2c, 
			 0x9, 0x2c, 0x4, 0x2d, 0x9, 0x2d, 0x4, 0x2e, 0x9, 0x2e, 0x4, 0x2f, 0x9, 
			 0x2f, 0x4, 0x30, 0x9, 0x30, 0x4, 0x31, 0x9, 0x31, 0x4, 0x32, 0x9, 0x32, 
			 0x4, 0x33, 0x9, 0x33, 0x4, 0x34, 0x9, 0x34, 0x4, 0x35, 0x9, 0x35, 0x4, 
			 0x36, 0x9, 0x36, 0x4, 0x37, 0x9, 0x37, 0x4, 0x38, 0x9, 0x38, 0x4, 0x39, 
			 0x9, 0x39, 0x4, 0x3a, 0x9, 0x3a, 0x4, 0x3b, 0x9, 0x3b, 0x4, 0x3c, 0x9, 
			 0x3c, 0x4, 0x3d, 0x9, 0x3d, 0x4, 0x3e, 0x9, 0x3e, 0x4, 0x3f, 0x9, 0x3f, 
			 0x4, 0x40, 0x9, 0x40, 0x4, 0x41, 0x9, 0x41, 0x4, 0x42, 0x9, 0x42, 0x4, 
			 0x43, 0x9, 0x43, 0x4, 0x44, 0x9, 0x44, 0x4, 0x45, 0x9, 0x45, 0x4, 0x46, 
			 0x9, 0x46, 0x4, 0x47, 0x9, 0x47, 0x4, 0x48, 0x9, 0x48, 0x4, 0x49, 0x9, 
			 0x49, 0x4, 0x4a, 0x9, 0x4a, 0x4, 0x4b, 0x9, 0x4b, 0x4, 0x4c, 0x9, 0x4c, 
			 0x4, 0x4d, 0x9, 0x4d, 0x4, 0x4e, 0x9, 0x4e, 0x4, 0x4f, 0x9, 0x4f, 0x4, 
			 0x50, 0x9, 0x50, 0x4, 0x51, 0x9, 0x51, 0x4, 0x52, 0x9, 0x52, 0x4, 0x53, 
			 0x9, 0x53, 0x4, 0x54, 0x9, 0x54, 0x4, 0x55, 0x9, 0x55, 0x4, 0x56, 0x9, 
			 0x56, 0x4, 0x57, 0x9, 0x57, 0x4, 0x58, 0x9, 0x58, 0x4, 0x59, 0x9, 0x59, 
			 0x4, 0x5a, 0x9, 0x5a, 0x4, 0x5b, 0x9, 0x5b, 0x4, 0x5c, 0x9, 0x5c, 0x4, 
			 0x5d, 0x9, 0x5d, 0x4, 0x5e, 0x9, 0x5e, 0x4, 0x5f, 0x9, 0x5f, 0x4, 0x60, 
			 0x9, 0x60, 0x4, 0x61, 0x9, 0x61, 0x4, 0x62, 0x9, 0x62, 0x4, 0x63, 0x9, 
			 0x63, 0x4, 0x64, 0x9, 0x64, 0x4, 0x65, 0x9, 0x65, 0x4, 0x66, 0x9, 0x66, 
			 0x4, 0x67, 0x9, 0x67, 0x4, 0x68, 0x9, 0x68, 0x4, 0x69, 0x9, 0x69, 0x4, 
			 0x6a, 0x9, 0x6a, 0x4, 0x6b, 0x9, 0x6b, 0x4, 0x6c, 0x9, 0x6c, 0x4, 0x6d, 
			 0x9, 0x6d, 0x4, 0x6e, 0x9, 0x6e, 0x4, 0x6f, 0x9, 0x6f, 0x4, 0x70, 0x9, 
			 0x70, 0x4, 0x71, 0x9, 0x71, 0x4, 0x72, 0x9, 0x72, 0x4, 0x73, 0x9, 0x73, 
			 0x4, 0x74, 0x9, 0x74, 0x4, 0x75, 0x9, 0x75, 0x4, 0x76, 0x9, 0x76, 0x4, 
			 0x77, 0x9, 0x77, 0x4, 0x78, 0x9, 0x78, 0x4, 0x79, 0x9, 0x79, 0x4, 0x7a, 
			 0x9, 0x7a, 0x4, 0x7b, 0x9, 0x7b, 0x4, 0x7c, 0x9, 0x7c, 0x4, 0x7d, 0x9, 
			 0x7d, 0x4, 0x7e, 0x9, 0x7e, 0x4, 0x7f, 0x9, 0x7f, 0x4, 0x80, 0x9, 0x80, 
			 0x4, 0x81, 0x9, 0x81, 0x4, 0x82, 0x9, 0x82, 0x4, 0x83, 0x9, 0x83, 0x4, 
			 0x84, 0x9, 0x84, 0x4, 0x85, 0x9, 0x85, 0x4, 0x86, 0x9, 0x86, 0x4, 0x87, 
			 0x9, 0x87, 0x4, 0x88, 0x9, 0x88, 0x4, 0x89, 0x9, 0x89, 0x4, 0x8a, 0x9, 
			 0x8a, 0x4, 0x8b, 0x9, 0x8b, 0x4, 0x8c, 0x9, 0x8c, 0x4, 0x8d, 0x9, 0x8d, 
			 0x4, 0x8e, 0x9, 0x8e, 0x4, 0x8f, 0x9, 0x8f, 0x4, 0x90, 0x9, 0x90, 0x4, 
			 0x91, 0x9, 0x91, 0x4, 0x92, 0x9, 0x92, 0x4, 0x93, 0x9, 0x93, 0x4, 0x94, 
			 0x9, 0x94, 0x4, 0x95, 0x9, 0x95, 0x4, 0x96, 0x9, 0x96, 0x4, 0x97, 0x9, 
			 0x97, 0x4, 0x98, 0x9, 0x98, 0x4, 0x99, 0x9, 0x99, 0x4, 0x9a, 0x9, 0x9a, 
			 0x4, 0x9b, 0x9, 0x9b, 0x4, 0x9c, 0x9, 0x9c, 0x4, 0x9d, 0x9, 0x9d, 0x4, 
			 0x9e, 0x9, 0x9e, 0x4, 0x9f, 0x9, 0x9f, 0x4, 0xa0, 0x9, 0xa0, 0x4, 0xa1, 
			 0x9, 0xa1, 0x4, 0xa2, 0x9, 0xa2, 0x4, 0xa3, 0x9, 0xa3, 0x4, 0xa4, 0x9, 
			 0xa4, 0x4, 0xa5, 0x9, 0xa5, 0x4, 0xa6, 0x9, 0xa6, 0x4, 0xa7, 0x9, 0xa7, 
			 0x4, 0xa8, 0x9, 0xa8, 0x4, 0xa9, 0x9, 0xa9, 0x4, 0xaa, 0x9, 0xaa, 0x4, 
			 0xab, 0x9, 0xab, 0x4, 0xac, 0x9, 0xac, 0x4, 0xad, 0x9, 0xad, 0x4, 0xae, 
			 0x9, 0xae, 0x4, 0xaf, 0x9, 0xaf, 0x4, 0xb0, 0x9, 0xb0, 0x4, 0xb1, 0x9, 
			 0xb1, 0x4, 0xb2, 0x9, 0xb2, 0x4, 0xb3, 0x9, 0xb3, 0x4, 0xb4, 0x9, 0xb4, 
			 0x4, 0xb5, 0x9, 0xb5, 0x4, 0xb6, 0x9, 0xb6, 0x4, 0xb7, 0x9, 0xb7, 0x4, 
			 0xb8, 0x9, 0xb8, 0x4, 0xb9, 0x9, 0xb9, 0x4, 0xba, 0x9, 0xba, 0x4, 0xbb, 
			 0x9, 0xbb, 0x4, 0xbc, 0x9, 0xbc, 0x4, 0xbd, 0x9, 0xbd, 0x4, 0xbe, 0x9, 
			 0xbe, 0x4, 0xbf, 0x9, 0xbf, 0x4, 0xc0, 0x9, 0xc0, 0x4, 0xc1, 0x9, 0xc1, 
			 0x4, 0xc2, 0x9, 0xc2, 0x4, 0xc3, 0x9, 0xc3, 0x4, 0xc4, 0x9, 0xc4, 0x4, 
			 0xc5, 0x9, 0xc5, 0x4, 0xc6, 0x9, 0xc6, 0x4, 0xc7, 0x9, 0xc7, 0x4, 0xc8, 
			 0x9, 0xc8, 0x4, 0xc9, 0x9, 0xc9, 0x4, 0xca, 0x9, 0xca, 0x4, 0xcb, 0x9, 
			 0xcb, 0x4, 0xcc, 0x9, 0xcc, 0x3, 0x2, 0x5, 0x2, 0x19a, 0xa, 0x2, 0x3, 
			 0x2, 0x3, 0x2, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 
			 0x3, 0x3, 0x3, 0x3, 0x3, 0x5, 0x3, 0x1a6, 0xa, 0x3, 0x3, 0x4, 0x3, 0x4, 
			 0x5, 0x4, 0x1aa, 0xa, 0x4, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 
			 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x5, 0x5, 0x1b5, 0xa, 0x5, 
			 0x3, 0x6, 0x3, 0x6, 0x5, 0x6, 0x1b9, 0xa, 0x6, 0x3, 0x6, 0x3, 0x6, 0x3, 
			 0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 
			 0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x5, 0x7, 0x1c8, 0xa, 0x7, 0x3, 0x7, 
			 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x5, 0x7, 0x1cf, 0xa, 0x7, 0x3, 
			 0x7, 0x3, 0x7, 0x3, 0x7, 0x7, 0x7, 0x1d4, 0xa, 0x7, 0xc, 0x7, 0xe, 0x7, 
			 0x1d7, 0xb, 0x7, 0x3, 0x8, 0x3, 0x8, 0x5, 0x8, 0x1db, 0xa, 0x8, 0x3, 
			 0x8, 0x3, 0x8, 0x3, 0x9, 0x3, 0x9, 0x5, 0x9, 0x1e1, 0xa, 0x9, 0x3, 0x9, 
			 0x3, 0x9, 0x3, 0xa, 0x3, 0xa, 0x3, 0xa, 0x3, 0xa, 0x3, 0xa, 0x3, 0xa, 
			 0x5, 0xa, 0x1eb, 0xa, 0xa, 0x3, 0xb, 0x3, 0xb, 0x3, 0xc, 0x3, 0xc, 0x3, 
			 0xc, 0x5, 0xc, 0x1f2, 0xa, 0xc, 0x3, 0xc, 0x3, 0xc, 0x3, 0xc, 0x3, 0xc, 
			 0x5, 0xc, 0x1f8, 0xa, 0xc, 0x7, 0xc, 0x1fa, 0xa, 0xc, 0xc, 0xc, 0xe, 
			 0xc, 0x1fd, 0xb, 0xc, 0x3, 0xd, 0x3, 0xd, 0x5, 0xd, 0x201, 0xa, 0xd, 
			 0x3, 0xe, 0x3, 0xe, 0x3, 0xe, 0x3, 0xe, 0x5, 0xe, 0x207, 0xa, 0xe, 0x3, 
			 0xf, 0x3, 0xf, 0x3, 0xf, 0x3, 0xf, 0x3, 0xf, 0x5, 0xf, 0x20e, 0xa, 0xf, 
			 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x5, 0x10, 0x214, 0xa, 0x10, 
			 0x3, 0x10, 0x5, 0x10, 0x217, 0xa, 0x10, 0x3, 0x10, 0x5, 0x10, 0x21a, 
			 0xa, 0x10, 0x3, 0x10, 0x5, 0x10, 0x21d, 0xa, 0x10, 0x3, 0x11, 0x3, 0x11, 
			 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x5, 0x11, 0x224, 0xa, 0x11, 0x3, 0x11, 
			 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x5, 0x11, 0x22b, 0xa, 0x11, 
			 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 
			 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 
			 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 
			 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 
			 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 
			 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 
			 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 
			 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x5, 0x11, 0x25f, 
			 0xa, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 
			 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 
			 0x3, 0x11, 0x5, 0x11, 0x26e, 0xa, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 
			 0x3, 0x11, 0x5, 0x11, 0x274, 0xa, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 
			 0x3, 0x11, 0x5, 0x11, 0x27a, 0xa, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 
			 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 
			 0x11, 0x3, 0x11, 0x7, 0x11, 0x287, 0xa, 0x11, 0xc, 0x11, 0xe, 0x11, 
			 0x28a, 0xb, 0x11, 0x3, 0x12, 0x3, 0x12, 0x3, 0x13, 0x3, 0x13, 0x3, 0x14, 
			 0x3, 0x14, 0x3, 0x15, 0x5, 0x15, 0x293, 0xa, 0x15, 0x3, 0x15, 0x3, 0x15, 
			 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 
			 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x5, 0x15, 0x2a2, 
			 0xa, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x5, 0x15, 0x2a8, 
			 0xa, 0x15, 0x3, 0x16, 0x3, 0x16, 0x3, 0x16, 0x3, 0x16, 0x3, 0x16, 0x3, 
			 0x16, 0x3, 0x16, 0x3, 0x16, 0x3, 0x16, 0x3, 0x16, 0x3, 0x16, 0x3, 0x16, 
			 0x3, 0x16, 0x3, 0x16, 0x3, 0x16, 0x3, 0x16, 0x3, 0x16, 0x3, 0x16, 0x3, 
			 0x16, 0x3, 0x16, 0x3, 0x16, 0x3, 0x16, 0x3, 0x16, 0x3, 0x16, 0x3, 0x16, 
			 0x3, 0x16, 0x3, 0x16, 0x3, 0x16, 0x5, 0x16, 0x2c6, 0xa, 0x16, 0x3, 0x17, 
			 0x3, 0x17, 0x3, 0x18, 0x5, 0x18, 0x2cb, 0xa, 0x18, 0x3, 0x18, 0x3, 0x18, 
			 0x5, 0x18, 0x2cf, 0xa, 0x18, 0x3, 0x18, 0x3, 0x18, 0x5, 0x18, 0x2d3, 
			 0xa, 0x18, 0x3, 0x18, 0x5, 0x18, 0x2d6, 0xa, 0x18, 0x3, 0x18, 0x3, 0x18, 
			 0x5, 0x18, 0x2da, 0xa, 0x18, 0x3, 0x18, 0x3, 0x18, 0x3, 0x18, 0x3, 0x18, 
			 0x5, 0x18, 0x2e0, 0xa, 0x18, 0x5, 0x18, 0x2e2, 0xa, 0x18, 0x3, 0x19, 
			 0x3, 0x19, 0x3, 0x19, 0x3, 0x19, 0x3, 0x1a, 0x3, 0x1a, 0x5, 0x1a, 0x2ea, 
			 0xa, 0x1a, 0x3, 0x1b, 0x3, 0x1b, 0x5, 0x1b, 0x2ee, 0xa, 0x1b, 0x3, 0x1b, 
			 0x3, 0x1b, 0x5, 0x1b, 0x2f2, 0xa, 0x1b, 0x3, 0x1c, 0x3, 0x1c, 0x3, 0x1c, 
			 0x3, 0x1c, 0x3, 0x1c, 0x5, 0x1c, 0x2f9, 0xa, 0x1c, 0x3, 0x1c, 0x3, 0x1c, 
			 0x3, 0x1c, 0x3, 0x1c, 0x3, 0x1c, 0x5, 0x1c, 0x300, 0xa, 0x1c, 0x7, 0x1c, 
			 0x302, 0xa, 0x1c, 0xc, 0x1c, 0xe, 0x1c, 0x305, 0xb, 0x1c, 0x3, 0x1d, 
			 0x3, 0x1d, 0x5, 0x1d, 0x309, 0xa, 0x1d, 0x3, 0x1d, 0x3, 0x1d, 0x5, 0x1d, 
			 0x30d, 0xa, 0x1d, 0x3, 0x1e, 0x5, 0x1e, 0x310, 0xa, 0x1e, 0x3, 0x1e, 
			 0x3, 0x1e, 0x3, 0x1e, 0x5, 0x1e, 0x315, 0xa, 0x1e, 0x3, 0x1e, 0x3, 0x1e, 
			 0x3, 0x1e, 0x3, 0x1e, 0x5, 0x1e, 0x31b, 0xa, 0x1e, 0x3, 0x1f, 0x3, 0x1f, 
			 0x3, 0x1f, 0x3, 0x1f, 0x3, 0x1f, 0x3, 0x20, 0x3, 0x20, 0x3, 0x20, 0x3, 
			 0x20, 0x3, 0x20, 0x3, 0x20, 0x5, 0x20, 0x328, 0xa, 0x20, 0x3, 0x21, 
			 0x3, 0x21, 0x3, 0x21, 0x3, 0x21, 0x3, 0x21, 0x3, 0x21, 0x3, 0x21, 0x3, 
			 0x21, 0x3, 0x21, 0x7, 0x21, 0x333, 0xa, 0x21, 0xc, 0x21, 0xe, 0x21, 
			 0x336, 0xb, 0x21, 0x3, 0x22, 0x3, 0x22, 0x3, 0x22, 0x3, 0x22, 0x3, 0x22, 
			 0x3, 0x22, 0x3, 0x22, 0x3, 0x22, 0x3, 0x22, 0x3, 0x22, 0x3, 0x22, 0x3, 
			 0x22, 0x7, 0x22, 0x344, 0xa, 0x22, 0xc, 0x22, 0xe, 0x22, 0x347, 0xb, 
			 0x22, 0x3, 0x23, 0x3, 0x23, 0x3, 0x23, 0x3, 0x23, 0x3, 0x23, 0x3, 0x23, 
			 0x3, 0x23, 0x3, 0x23, 0x3, 0x23, 0x7, 0x23, 0x352, 0xa, 0x23, 0xc, 0x23, 
			 0xe, 0x23, 0x355, 0xb, 0x23, 0x3, 0x24, 0x3, 0x24, 0x3, 0x24, 0x3, 0x24, 
			 0x3, 0x24, 0x3, 0x24, 0x3, 0x24, 0x7, 0x24, 0x35e, 0xa, 0x24, 0xc, 0x24, 
			 0xe, 0x24, 0x361, 0xb, 0x24, 0x3, 0x25, 0x3, 0x25, 0x5, 0x25, 0x365, 
			 0xa, 0x25, 0x3, 0x26, 0x3, 0x26, 0x3, 0x26, 0x3, 0x26, 0x3, 0x26, 0x3, 
			 0x26, 0x3, 0x26, 0x3, 0x26, 0x3, 0x26, 0x3, 0x26, 0x3, 0x26, 0x3, 0x26, 
			 0x3, 0x26, 0x3, 0x26, 0x3, 0x26, 0x7, 0x26, 0x376, 0xa, 0x26, 0xc, 0x26, 
			 0xe, 0x26, 0x379, 0xb, 0x26, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 
			 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x7, 0x27, 0x384, 
			 0xa, 0x27, 0xc, 0x27, 0xe, 0x27, 0x387, 0xb, 0x27, 0x3, 0x28, 0x3, 0x28, 
			 0x3, 0x28, 0x3, 0x28, 0x3, 0x28, 0x3, 0x28, 0x7, 0x28, 0x38f, 0xa, 0x28, 
			 0xc, 0x28, 0xe, 0x28, 0x392, 0xb, 0x28, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 
			 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x7, 0x29, 0x39a, 0xa, 0x29, 0xc, 0x29, 
			 0xe, 0x29, 0x39d, 0xb, 0x29, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 
			 0x3, 0x2a, 0x3, 0x2a, 0x7, 0x2a, 0x3a5, 0xa, 0x2a, 0xc, 0x2a, 0xe, 0x2a, 
			 0x3a8, 0xb, 0x2a, 0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 
			 0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x7, 0x2b, 0x3b3, 0xa, 0x2b, 
			 0xc, 0x2b, 0xe, 0x2b, 0x3b6, 0xb, 0x2b, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 
			 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x7, 
			 0x2c, 0x3c1, 0xa, 0x2c, 0xc, 0x2c, 0xe, 0x2c, 0x3c4, 0xb, 0x2c, 0x3, 
			 0x2d, 0x3, 0x2d, 0x3, 0x2d, 0x3, 0x2d, 0x3, 0x2d, 0x3, 0x2d, 0x3, 0x2d, 
			 0x5, 0x2d, 0x3cd, 0xa, 0x2d, 0x3, 0x2e, 0x3, 0x2e, 0x3, 0x2e, 0x3, 0x2e, 
			 0x3, 0x2e, 0x3, 0x2e, 0x5, 0x2e, 0x3d5, 0xa, 0x2e, 0x3, 0x2f, 0x3, 0x2f, 
			 0x3, 0x2f, 0x3, 0x2f, 0x3, 0x2f, 0x3, 0x2f, 0x3, 0x2f, 0x3, 0x2f, 0x3, 
			 0x2f, 0x3, 0x2f, 0x3, 0x2f, 0x5, 0x2f, 0x3e2, 0xa, 0x2f, 0x3, 0x30, 
			 0x3, 0x30, 0x3, 0x30, 0x3, 0x30, 0x3, 0x30, 0x3, 0x30, 0x7, 0x30, 0x3ea, 
			 0xa, 0x30, 0xc, 0x30, 0xe, 0x30, 0x3ed, 0xb, 0x30, 0x3, 0x31, 0x3, 0x31, 
			 0x3, 0x32, 0x3, 0x32, 0x5, 0x32, 0x3f3, 0xa, 0x32, 0x3, 0x32, 0x3, 0x32, 
			 0x5, 0x32, 0x3f7, 0xa, 0x32, 0x3, 0x32, 0x3, 0x32, 0x5, 0x32, 0x3fb, 
			 0xa, 0x32, 0x3, 0x32, 0x3, 0x32, 0x5, 0x32, 0x3ff, 0xa, 0x32, 0x3, 0x32, 
			 0x3, 0x32, 0x5, 0x32, 0x403, 0xa, 0x32, 0x3, 0x32, 0x3, 0x32, 0x3, 0x32, 
			 0x5, 0x32, 0x408, 0xa, 0x32, 0x3, 0x32, 0x5, 0x32, 0x40b, 0xa, 0x32, 
			 0x3, 0x33, 0x5, 0x33, 0x40e, 0xa, 0x33, 0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 
			 0x3, 0x33, 0x5, 0x33, 0x414, 0xa, 0x33, 0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 
			 0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 0x5, 0x33, 0x41c, 0xa, 0x33, 0x3, 0x33, 
			 0x3, 0x33, 0x3, 0x33, 0x5, 0x33, 0x421, 0xa, 0x33, 0x3, 0x34, 0x5, 0x34, 
			 0x424, 0xa, 0x34, 0x3, 0x34, 0x3, 0x34, 0x3, 0x35, 0x3, 0x35, 0x5, 0x35, 
			 0x42a, 0xa, 0x35, 0x3, 0x35, 0x3, 0x35, 0x3, 0x36, 0x3, 0x36, 0x3, 0x36, 
			 0x3, 0x36, 0x3, 0x36, 0x7, 0x36, 0x433, 0xa, 0x36, 0xc, 0x36, 0xe, 0x36, 
			 0x436, 0xb, 0x36, 0x3, 0x37, 0x3, 0x37, 0x3, 0x37, 0x3, 0x37, 0x3, 0x37, 
			 0x3, 0x37, 0x3, 0x37, 0x3, 0x37, 0x3, 0x37, 0x3, 0x37, 0x3, 0x37, 0x3, 
			 0x37, 0x3, 0x37, 0x3, 0x37, 0x3, 0x37, 0x3, 0x37, 0x3, 0x37, 0x3, 0x37, 
			 0x3, 0x37, 0x3, 0x37, 0x5, 0x37, 0x44c, 0xa, 0x37, 0x3, 0x38, 0x3, 0x38, 
			 0x5, 0x38, 0x450, 0xa, 0x38, 0x3, 0x38, 0x3, 0x38, 0x3, 0x38, 0x3, 0x38, 
			 0x3, 0x38, 0x3, 0x38, 0x5, 0x38, 0x458, 0xa, 0x38, 0x3, 0x38, 0x3, 0x38, 
			 0x3, 0x38, 0x3, 0x38, 0x5, 0x38, 0x45e, 0xa, 0x38, 0x3, 0x39, 0x3, 0x39, 
			 0x3, 0x39, 0x3, 0x39, 0x3, 0x39, 0x3, 0x39, 0x3, 0x39, 0x3, 0x39, 0x3, 
			 0x39, 0x3, 0x39, 0x3, 0x39, 0x3, 0x39, 0x3, 0x39, 0x3, 0x39, 0x3, 0x39, 
			 0x3, 0x39, 0x3, 0x39, 0x3, 0x39, 0x5, 0x39, 0x472, 0xa, 0x39, 0x3, 0x39, 
			 0x3, 0x39, 0x5, 0x39, 0x476, 0xa, 0x39, 0x3, 0x39, 0x3, 0x39, 0x3, 0x39, 
			 0x3, 0x39, 0x3, 0x39, 0x3, 0x39, 0x3, 0x39, 0x3, 0x39, 0x3, 0x39, 0x3, 
			 0x39, 0x3, 0x39, 0x5, 0x39, 0x483, 0xa, 0x39, 0x3, 0x3a, 0x3, 0x3a, 
			 0x5, 0x3a, 0x487, 0xa, 0x3a, 0x3, 0x3b, 0x5, 0x3b, 0x48a, 0xa, 0x3b, 
			 0x3, 0x3b, 0x3, 0x3b, 0x3, 0x3b, 0x3, 0x3c, 0x3, 0x3c, 0x5, 0x3c, 0x491, 
			 0xa, 0x3c, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 
			 0x3d, 0x5, 0x3d, 0x499, 0xa, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 
			 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x5, 0x3d, 0x4a3, 
			 0xa, 0x3d, 0x3, 0x3e, 0x3, 0x3e, 0x3, 0x3f, 0x7, 0x3f, 0x4a8, 0xa, 0x3f, 
			 0xc, 0x3f, 0xe, 0x3f, 0x4ab, 0xb, 0x3f, 0x3, 0x40, 0x3, 0x40, 0x3, 0x40, 
			 0x3, 0x40, 0x3, 0x40, 0x3, 0x40, 0x3, 0x40, 0x3, 0x40, 0x3, 0x40, 0x3, 
			 0x40, 0x5, 0x40, 0x4b7, 0xa, 0x40, 0x3, 0x41, 0x3, 0x41, 0x3, 0x42, 
			 0x3, 0x42, 0x3, 0x42, 0x3, 0x42, 0x3, 0x42, 0x3, 0x42, 0x3, 0x42, 0x3, 
			 0x42, 0x5, 0x42, 0x4c3, 0xa, 0x42, 0x3, 0x43, 0x3, 0x43, 0x3, 0x43, 
			 0x5, 0x43, 0x4c8, 0xa, 0x43, 0x3, 0x43, 0x3, 0x43, 0x3, 0x43, 0x3, 0x43, 
			 0x3, 0x44, 0x5, 0x44, 0x4cf, 0xa, 0x44, 0x3, 0x44, 0x5, 0x44, 0x4d2, 
			 0xa, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x5, 0x44, 0x4d7, 0xa, 0x44, 
			 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x5, 0x44, 0x4dc, 0xa, 0x44, 0x3, 0x45, 
			 0x3, 0x45, 0x3, 0x45, 0x3, 0x45, 0x3, 0x45, 0x3, 0x45, 0x3, 0x45, 0x3, 
			 0x45, 0x3, 0x46, 0x3, 0x46, 0x3, 0x47, 0x3, 0x47, 0x3, 0x47, 0x3, 0x48, 
			 0x3, 0x48, 0x3, 0x48, 0x3, 0x48, 0x3, 0x48, 0x3, 0x48, 0x5, 0x48, 0x4f1, 
			 0xa, 0x48, 0x3, 0x49, 0x3, 0x49, 0x5, 0x49, 0x4f5, 0xa, 0x49, 0x3, 0x49, 
			 0x3, 0x49, 0x3, 0x49, 0x5, 0x49, 0x4fa, 0xa, 0x49, 0x3, 0x4a, 0x3, 0x4a, 
			 0x3, 0x4b, 0x3, 0x4b, 0x3, 0x4c, 0x3, 0x4c, 0x3, 0x4d, 0x3, 0x4d, 0x3, 
			 0x4d, 0x5, 0x4d, 0x505, 0xa, 0x4d, 0x3, 0x4e, 0x3, 0x4e, 0x3, 0x4e, 
			 0x3, 0x4e, 0x5, 0x4e, 0x50b, 0xa, 0x4e, 0x3, 0x4f, 0x3, 0x4f, 0x5, 0x4f, 
			 0x50f, 0xa, 0x4f, 0x3, 0x4f, 0x3, 0x4f, 0x3, 0x4f, 0x5, 0x4f, 0x514, 
			 0xa, 0x4f, 0x3, 0x50, 0x3, 0x50, 0x5, 0x50, 0x518, 0xa, 0x50, 0x3, 0x50, 
			 0x3, 0x50, 0x3, 0x50, 0x5, 0x50, 0x51d, 0xa, 0x50, 0x3, 0x51, 0x5, 0x51, 
			 0x520, 0xa, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 
			 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 
			 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 
			 0x3, 0x51, 0x3, 0x51, 0x5, 0x51, 0x536, 0xa, 0x51, 0x3, 0x52, 0x3, 0x52, 
			 0x3, 0x52, 0x3, 0x52, 0x5, 0x52, 0x53c, 0xa, 0x52, 0x3, 0x53, 0x3, 0x53, 
			 0x3, 0x53, 0x3, 0x53, 0x3, 0x53, 0x3, 0x53, 0x3, 0x53, 0x3, 0x53, 0x3, 
			 0x53, 0x5, 0x53, 0x547, 0xa, 0x53, 0x3, 0x54, 0x3, 0x54, 0x5, 0x54, 
			 0x54b, 0xa, 0x54, 0x3, 0x54, 0x5, 0x54, 0x54e, 0xa, 0x54, 0x3, 0x54, 
			 0x3, 0x54, 0x3, 0x54, 0x3, 0x54, 0x3, 0x54, 0x3, 0x54, 0x3, 0x54, 0x3, 
			 0x54, 0x5, 0x54, 0x558, 0xa, 0x54, 0x3, 0x54, 0x3, 0x54, 0x3, 0x54, 
			 0x3, 0x54, 0x5, 0x54, 0x55e, 0xa, 0x54, 0x3, 0x54, 0x5, 0x54, 0x561, 
			 0xa, 0x54, 0x3, 0x55, 0x3, 0x55, 0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x5, 
			 0x56, 0x568, 0xa, 0x56, 0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 
			 0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x5, 0x56, 0x572, 0xa, 0x56, 
			 0x3, 0x57, 0x3, 0x57, 0x5, 0x57, 0x576, 0xa, 0x57, 0x3, 0x57, 0x5, 0x57, 
			 0x579, 0xa, 0x57, 0x3, 0x57, 0x5, 0x57, 0x57c, 0xa, 0x57, 0x3, 0x57, 
			 0x3, 0x57, 0x5, 0x57, 0x580, 0xa, 0x57, 0x3, 0x57, 0x3, 0x57, 0x3, 0x57, 
			 0x5, 0x57, 0x585, 0xa, 0x57, 0x5, 0x57, 0x587, 0xa, 0x57, 0x3, 0x58, 
			 0x3, 0x58, 0x5, 0x58, 0x58b, 0xa, 0x58, 0x3, 0x58, 0x3, 0x58, 0x5, 0x58, 
			 0x58f, 0xa, 0x58, 0x3, 0x58, 0x3, 0x58, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 
			 0x3, 0x59, 0x3, 0x59, 0x5, 0x59, 0x598, 0xa, 0x59, 0x3, 0x5a, 0x3, 0x5a, 
			 0x3, 0x5a, 0x3, 0x5b, 0x3, 0x5b, 0x3, 0x5b, 0x3, 0x5b, 0x3, 0x5b, 0x3, 
			 0x5b, 0x7, 0x5b, 0x5a3, 0xa, 0x5b, 0xc, 0x5b, 0xe, 0x5b, 0x5a6, 0xb, 
			 0x5b, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x5, 0x5c, 
			 0x5ad, 0xa, 0x5c, 0x3, 0x5d, 0x3, 0x5d, 0x3, 0x5e, 0x3, 0x5e, 0x5, 0x5e, 
			 0x5b3, 0xa, 0x5e, 0x3, 0x5f, 0x3, 0x5f, 0x3, 0x60, 0x3, 0x60, 0x5, 0x60, 
			 0x5b9, 0xa, 0x60, 0x3, 0x61, 0x3, 0x61, 0x5, 0x61, 0x5bd, 0xa, 0x61, 
			 0x3, 0x62, 0x5, 0x62, 0x5c0, 0xa, 0x62, 0x3, 0x62, 0x3, 0x62, 0x3, 0x62, 
			 0x3, 0x62, 0x3, 0x62, 0x3, 0x62, 0x3, 0x63, 0x5, 0x63, 0x5c9, 0xa, 0x63, 
			 0x3, 0x63, 0x3, 0x63, 0x3, 0x63, 0x3, 0x63, 0x3, 0x63, 0x3, 0x63, 0x3, 
			 0x64, 0x5, 0x64, 0x5d2, 0xa, 0x64, 0x3, 0x64, 0x3, 0x64, 0x3, 0x64, 
			 0x3, 0x64, 0x3, 0x64, 0x3, 0x65, 0x5, 0x65, 0x5da, 0xa, 0x65, 0x3, 0x66, 
			 0x3, 0x66, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 
			 0x67, 0x3, 0x68, 0x5, 0x68, 0x5e5, 0xa, 0x68, 0x3, 0x68, 0x3, 0x68, 
			 0x3, 0x69, 0x3, 0x69, 0x5, 0x69, 0x5eb, 0xa, 0x69, 0x3, 0x69, 0x3, 0x69, 
			 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 
			 0x69, 0x5, 0x69, 0x5f6, 0xa, 0x69, 0x3, 0x6a, 0x5, 0x6a, 0x5f9, 0xa, 
			 0x6a, 0x3, 0x6a, 0x3, 0x6a, 0x3, 0x6a, 0x5, 0x6a, 0x5fe, 0xa, 0x6a, 
			 0x3, 0x6a, 0x3, 0x6a, 0x3, 0x6a, 0x3, 0x6b, 0x3, 0x6b, 0x3, 0x6b, 0x3, 
			 0x6b, 0x3, 0x6b, 0x3, 0x6b, 0x3, 0x6c, 0x3, 0x6c, 0x3, 0x6c, 0x3, 0x6c, 
			 0x5, 0x6c, 0x60d, 0xa, 0x6c, 0x3, 0x6c, 0x3, 0x6c, 0x3, 0x6c, 0x3, 0x6c, 
			 0x5, 0x6c, 0x613, 0xa, 0x6c, 0x3, 0x6d, 0x3, 0x6d, 0x3, 0x6d, 0x3, 0x6d, 
			 0x3, 0x6d, 0x7, 0x6d, 0x61a, 0xa, 0x6d, 0xc, 0x6d, 0xe, 0x6d, 0x61d, 
			 0xb, 0x6d, 0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x3, 
			 0x6e, 0x3, 0x6e, 0x5, 0x6e, 0x626, 0xa, 0x6e, 0x3, 0x6f, 0x3, 0x6f, 
			 0x3, 0x6f, 0x3, 0x6f, 0x5, 0x6f, 0x62c, 0xa, 0x6f, 0x3, 0x6f, 0x3, 0x6f, 
			 0x3, 0x6f, 0x3, 0x6f, 0x3, 0x6f, 0x3, 0x6f, 0x5, 0x6f, 0x634, 0xa, 0x6f, 
			 0x3, 0x6f, 0x3, 0x6f, 0x5, 0x6f, 0x638, 0xa, 0x6f, 0x3, 0x70, 0x3, 0x70, 
			 0x5, 0x70, 0x63c, 0xa, 0x70, 0x3, 0x70, 0x3, 0x70, 0x3, 0x70, 0x5, 0x70, 
			 0x641, 0xa, 0x70, 0x3, 0x70, 0x3, 0x70, 0x3, 0x70, 0x5, 0x70, 0x646, 
			 0xa, 0x70, 0x3, 0x70, 0x3, 0x70, 0x3, 0x70, 0x3, 0x70, 0x3, 0x70, 0x7, 
			 0x70, 0x64d, 0xa, 0x70, 0xc, 0x70, 0xe, 0x70, 0x650, 0xb, 0x70, 0x3, 
			 0x71, 0x3, 0x71, 0x5, 0x71, 0x654, 0xa, 0x71, 0x3, 0x72, 0x3, 0x72, 
			 0x5, 0x72, 0x658, 0xa, 0x72, 0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 
			 0x3, 0x74, 0x3, 0x74, 0x3, 0x75, 0x3, 0x75, 0x3, 0x75, 0x3, 0x75, 0x3, 
			 0x76, 0x3, 0x76, 0x5, 0x76, 0x666, 0xa, 0x76, 0x3, 0x76, 0x3, 0x76, 
			 0x7, 0x76, 0x66a, 0xa, 0x76, 0xc, 0x76, 0xe, 0x76, 0x66d, 0xb, 0x76, 
			 0x3, 0x77, 0x3, 0x77, 0x3, 0x77, 0x3, 0x77, 0x3, 0x77, 0x3, 0x77, 0x3, 
			 0x77, 0x3, 0x77, 0x3, 0x77, 0x3, 0x77, 0x3, 0x77, 0x3, 0x77, 0x3, 0x77, 
			 0x6, 0x77, 0x67c, 0xa, 0x77, 0xd, 0x77, 0xe, 0x77, 0x67d, 0x5, 0x77, 
			 0x680, 0xa, 0x77, 0x3, 0x78, 0x3, 0x78, 0x3, 0x78, 0x3, 0x78, 0x3, 0x78, 
			 0x3, 0x78, 0x7, 0x78, 0x688, 0xa, 0x78, 0xc, 0x78, 0xe, 0x78, 0x68b, 
			 0xb, 0x78, 0x3, 0x79, 0x3, 0x79, 0x5, 0x79, 0x68f, 0xa, 0x79, 0x3, 0x7a, 
			 0x3, 0x7a, 0x3, 0x7a, 0x3, 0x7a, 0x3, 0x7a, 0x5, 0x7a, 0x696, 0xa, 0x7a, 
			 0x3, 0x7b, 0x3, 0x7b, 0x3, 0x7b, 0x3, 0x7b, 0x5, 0x7b, 0x69c, 0xa, 0x7b, 
			 0x3, 0x7c, 0x3, 0x7c, 0x3, 0x7c, 0x5, 0x7c, 0x6a1, 0xa, 0x7c, 0x3, 0x7c, 
			 0x3, 0x7c, 0x3, 0x7c, 0x3, 0x7c, 0x5, 0x7c, 0x6a7, 0xa, 0x7c, 0x3, 0x7c, 
			 0x3, 0x7c, 0x3, 0x7c, 0x3, 0x7c, 0x3, 0x7c, 0x5, 0x7c, 0x6ae, 0xa, 0x7c, 
			 0x3, 0x7c, 0x3, 0x7c, 0x5, 0x7c, 0x6b2, 0xa, 0x7c, 0x7, 0x7c, 0x6b4, 
			 0xa, 0x7c, 0xc, 0x7c, 0xe, 0x7c, 0x6b7, 0xb, 0x7c, 0x3, 0x7d, 0x3, 0x7d, 
			 0x3, 0x7d, 0x3, 0x7d, 0x5, 0x7d, 0x6bd, 0xa, 0x7d, 0x3, 0x7d, 0x5, 0x7d, 
			 0x6c0, 0xa, 0x7d, 0x3, 0x7d, 0x5, 0x7d, 0x6c3, 0xa, 0x7d, 0x3, 0x7d, 
			 0x5, 0x7d, 0x6c6, 0xa, 0x7d, 0x3, 0x7e, 0x3, 0x7e, 0x3, 0x7e, 0x5, 0x7e, 
			 0x6cb, 0xa, 0x7e, 0x3, 0x7f, 0x3, 0x7f, 0x5, 0x7f, 0x6cf, 0xa, 0x7f, 
			 0x3, 0x7f, 0x5, 0x7f, 0x6d2, 0xa, 0x7f, 0x3, 0x7f, 0x3, 0x7f, 0x5, 0x7f, 
			 0x6d6, 0xa, 0x7f, 0x3, 0x7f, 0x3, 0x7f, 0x5, 0x7f, 0x6da, 0xa, 0x7f, 
			 0x3, 0x7f, 0x3, 0x7f, 0x3, 0x7f, 0x5, 0x7f, 0x6df, 0xa, 0x7f, 0x3, 0x7f, 
			 0x5, 0x7f, 0x6e2, 0xa, 0x7f, 0x5, 0x7f, 0x6e4, 0xa, 0x7f, 0x3, 0x80, 
			 0x3, 0x80, 0x5, 0x80, 0x6e8, 0xa, 0x80, 0x3, 0x81, 0x3, 0x81, 0x3, 0x82, 
			 0x3, 0x82, 0x3, 0x83, 0x5, 0x83, 0x6ef, 0xa, 0x83, 0x3, 0x83, 0x3, 0x83, 
			 0x3, 0x84, 0x3, 0x84, 0x5, 0x84, 0x6f5, 0xa, 0x84, 0x3, 0x85, 0x3, 0x85, 
			 0x5, 0x85, 0x6f9, 0xa, 0x85, 0x3, 0x85, 0x3, 0x85, 0x3, 0x85, 0x3, 0x85, 
			 0x5, 0x85, 0x6ff, 0xa, 0x85, 0x3, 0x86, 0x3, 0x86, 0x3, 0x86, 0x5, 0x86, 
			 0x704, 0xa, 0x86, 0x5, 0x86, 0x706, 0xa, 0x86, 0x3, 0x87, 0x3, 0x87, 
			 0x3, 0x87, 0x3, 0x87, 0x5, 0x87, 0x70c, 0xa, 0x87, 0x3, 0x87, 0x3, 0x87, 
			 0x5, 0x87, 0x710, 0xa, 0x87, 0x3, 0x87, 0x3, 0x87, 0x3, 0x87, 0x3, 0x87, 
			 0x5, 0x87, 0x716, 0xa, 0x87, 0x3, 0x87, 0x3, 0x87, 0x3, 0x87, 0x3, 0x87, 
			 0x3, 0x87, 0x5, 0x87, 0x71d, 0xa, 0x87, 0x3, 0x87, 0x3, 0x87, 0x5, 0x87, 
			 0x721, 0xa, 0x87, 0x7, 0x87, 0x723, 0xa, 0x87, 0xc, 0x87, 0xe, 0x87, 
			 0x726, 0xb, 0x87, 0x3, 0x88, 0x3, 0x88, 0x3, 0x88, 0x3, 0x88, 0x5, 0x88, 
			 0x72c, 0xa, 0x88, 0x3, 0x89, 0x3, 0x89, 0x3, 0x89, 0x3, 0x89, 0x3, 0x89, 
			 0x3, 0x89, 0x3, 0x89, 0x3, 0x89, 0x5, 0x89, 0x736, 0xa, 0x89, 0x3, 0x89, 
			 0x3, 0x89, 0x5, 0x89, 0x73a, 0xa, 0x89, 0x7, 0x89, 0x73c, 0xa, 0x89, 
			 0xc, 0x89, 0xe, 0x89, 0x73f, 0xb, 0x89, 0x3, 0x8a, 0x5, 0x8a, 0x742, 
			 0xa, 0x8a, 0x3, 0x8a, 0x5, 0x8a, 0x745, 0xa, 0x8a, 0x3, 0x8a, 0x3, 0x8a, 
			 0x3, 0x8a, 0x3, 0x8a, 0x5, 0x8a, 0x74b, 0xa, 0x8a, 0x3, 0x8b, 0x3, 0x8b, 
			 0x3, 0x8b, 0x3, 0x8b, 0x3, 0x8b, 0x3, 0x8b, 0x7, 0x8b, 0x753, 0xa, 0x8b, 
			 0xc, 0x8b, 0xe, 0x8b, 0x756, 0xb, 0x8b, 0x3, 0x8c, 0x5, 0x8c, 0x759, 
			 0xa, 0x8c, 0x3, 0x8c, 0x3, 0x8c, 0x3, 0x8c, 0x5, 0x8c, 0x75e, 0xa, 0x8c, 
			 0x3, 0x8c, 0x5, 0x8c, 0x761, 0xa, 0x8c, 0x3, 0x8c, 0x3, 0x8c, 0x3, 0x8c, 
			 0x5, 0x8c, 0x766, 0xa, 0x8c, 0x3, 0x8c, 0x3, 0x8c, 0x3, 0x8c, 0x3, 0x8c, 
			 0x5, 0x8c, 0x76c, 0xa, 0x8c, 0x3, 0x8c, 0x3, 0x8c, 0x5, 0x8c, 0x770, 
			 0xa, 0x8c, 0x3, 0x8c, 0x5, 0x8c, 0x773, 0xa, 0x8c, 0x3, 0x8c, 0x5, 0x8c, 
			 0x776, 0xa, 0x8c, 0x3, 0x8c, 0x3, 0x8c, 0x5, 0x8c, 0x77a, 0xa, 0x8c, 
			 0x3, 0x8c, 0x5, 0x8c, 0x77d, 0xa, 0x8c, 0x3, 0x8c, 0x3, 0x8c, 0x3, 0x8c, 
			 0x5, 0x8c, 0x782, 0xa, 0x8c, 0x3, 0x8d, 0x5, 0x8d, 0x785, 0xa, 0x8d, 
			 0x3, 0x8d, 0x5, 0x8d, 0x788, 0xa, 0x8d, 0x3, 0x8d, 0x3, 0x8d, 0x5, 0x8d, 
			 0x78c, 0xa, 0x8d, 0x3, 0x8d, 0x3, 0x8d, 0x3, 0x8e, 0x5, 0x8e, 0x791, 
			 0xa, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x3, 
			 0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x5, 0x8e, 0x79b, 0xa, 0x8e, 0x3, 0x8f, 
			 0x3, 0x8f, 0x3, 0x8f, 0x3, 0x8f, 0x3, 0x8f, 0x5, 0x8f, 0x7a2, 0xa, 0x8f, 
			 0x3, 0x90, 0x3, 0x90, 0x3, 0x90, 0x5, 0x90, 0x7a7, 0xa, 0x90, 0x3, 0x91, 
			 0x3, 0x91, 0x5, 0x91, 0x7ab, 0xa, 0x91, 0x3, 0x92, 0x3, 0x92, 0x3, 0x92, 
			 0x5, 0x92, 0x7b0, 0xa, 0x92, 0x3, 0x92, 0x3, 0x92, 0x3, 0x92, 0x3, 0x92, 
			 0x5, 0x92, 0x7b6, 0xa, 0x92, 0x7, 0x92, 0x7b8, 0xa, 0x92, 0xc, 0x92, 
			 0xe, 0x92, 0x7bb, 0xb, 0x92, 0x3, 0x93, 0x3, 0x93, 0x3, 0x93, 0x5, 0x93, 
			 0x7c0, 0xa, 0x93, 0x3, 0x93, 0x3, 0x93, 0x3, 0x93, 0x3, 0x93, 0x5, 0x93, 
			 0x7c6, 0xa, 0x93, 0x3, 0x94, 0x3, 0x94, 0x5, 0x94, 0x7ca, 0xa, 0x94, 
			 0x3, 0x95, 0x3, 0x95, 0x3, 0x95, 0x5, 0x95, 0x7cf, 0xa, 0x95, 0x3, 0x95, 
			 0x3, 0x95, 0x3, 0x96, 0x3, 0x96, 0x5, 0x96, 0x7d5, 0xa, 0x96, 0x3, 0x96, 
			 0x3, 0x96, 0x5, 0x96, 0x7d9, 0xa, 0x96, 0x3, 0x96, 0x5, 0x96, 0x7dc, 
			 0xa, 0x96, 0x3, 0x96, 0x3, 0x96, 0x5, 0x96, 0x7e0, 0xa, 0x96, 0x3, 0x96, 
			 0x5, 0x96, 0x7e3, 0xa, 0x96, 0x5, 0x96, 0x7e5, 0xa, 0x96, 0x3, 0x97, 
			 0x5, 0x97, 0x7e8, 0xa, 0x97, 0x3, 0x97, 0x3, 0x97, 0x3, 0x98, 0x3, 0x98, 
			 0x3, 0x99, 0x3, 0x99, 0x3, 0x9a, 0x3, 0x9a, 0x5, 0x9a, 0x7f2, 0xa, 0x9a, 
			 0x3, 0x9a, 0x3, 0x9a, 0x3, 0x9a, 0x5, 0x9a, 0x7f7, 0xa, 0x9a, 0x5, 0x9a, 
			 0x7f9, 0xa, 0x9a, 0x3, 0x9b, 0x5, 0x9b, 0x7fc, 0xa, 0x9b, 0x3, 0x9b, 
			 0x5, 0x9b, 0x7ff, 0xa, 0x9b, 0x3, 0x9b, 0x5, 0x9b, 0x802, 0xa, 0x9b, 
			 0x3, 0x9b, 0x3, 0x9b, 0x3, 0x9b, 0x3, 0x9b, 0x3, 0x9b, 0x3, 0x9b, 0x3, 
			 0x9b, 0x5, 0x9b, 0x80b, 0xa, 0x9b, 0x3, 0x9c, 0x3, 0x9c, 0x3, 0x9c, 
			 0x3, 0x9c, 0x3, 0x9c, 0x3, 0x9c, 0x7, 0x9c, 0x813, 0xa, 0x9c, 0xc, 0x9c, 
			 0xe, 0x9c, 0x816, 0xb, 0x9c, 0x3, 0x9d, 0x3, 0x9d, 0x5, 0x9d, 0x81a, 
			 0xa, 0x9d, 0x3, 0x9d, 0x5, 0x9d, 0x81d, 0xa, 0x9d, 0x3, 0x9d, 0x3, 0x9d, 
			 0x5, 0x9d, 0x821, 0xa, 0x9d, 0x3, 0x9d, 0x5, 0x9d, 0x824, 0xa, 0x9d, 
			 0x3, 0x9d, 0x5, 0x9d, 0x827, 0xa, 0x9d, 0x3, 0x9d, 0x3, 0x9d, 0x5, 0x9d, 
			 0x82b, 0xa, 0x9d, 0x3, 0x9e, 0x3, 0x9e, 0x3, 0x9e, 0x3, 0x9e, 0x3, 0x9e, 
			 0x7, 0x9e, 0x832, 0xa, 0x9e, 0xc, 0x9e, 0xe, 0x9e, 0x835, 0xb, 0x9e, 
			 0x3, 0x9f, 0x3, 0x9f, 0x3, 0xa0, 0x3, 0xa0, 0x3, 0xa0, 0x3, 0xa1, 0x3, 
			 0xa1, 0x3, 0xa1, 0x3, 0xa2, 0x3, 0xa2, 0x3, 0xa2, 0x5, 0xa2, 0x842, 
			 0xa, 0xa2, 0x3, 0xa2, 0x3, 0xa2, 0x3, 0xa2, 0x3, 0xa2, 0x5, 0xa2, 0x848, 
			 0xa, 0xa2, 0x7, 0xa2, 0x84a, 0xa, 0xa2, 0xc, 0xa2, 0xe, 0xa2, 0x84d, 
			 0xb, 0xa2, 0x3, 0xa3, 0x5, 0xa3, 0x850, 0xa, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 
			 0x5, 0xa3, 0x854, 0xa, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x5, 0xa3, 0x858, 
			 0xa, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x5, 0xa3, 0x85c, 0xa, 0xa3, 0x3, 0xa3, 
			 0x3, 0xa3, 0x5, 0xa3, 0x860, 0xa, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x5, 0xa3, 
			 0x864, 0xa, 0xa3, 0x3, 0xa4, 0x5, 0xa4, 0x867, 0xa, 0xa4, 0x3, 0xa4, 
			 0x3, 0xa4, 0x5, 0xa4, 0x86b, 0xa, 0xa4, 0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa6, 
			 0x3, 0xa6, 0x3, 0xa7, 0x3, 0xa7, 0x3, 0xa7, 0x3, 0xa8, 0x3, 0xa8, 0x5, 
			 0xa8, 0x876, 0xa, 0xa8, 0x3, 0xa9, 0x3, 0xa9, 0x5, 0xa9, 0x87a, 0xa, 
			 0xa9, 0x3, 0xaa, 0x3, 0xaa, 0x3, 0xaa, 0x3, 0xab, 0x3, 0xab, 0x5, 0xab, 
			 0x881, 0xa, 0xab, 0x3, 0xab, 0x3, 0xab, 0x5, 0xab, 0x885, 0xa, 0xab, 
			 0x3, 0xab, 0x3, 0xab, 0x3, 0xab, 0x5, 0xab, 0x88a, 0xa, 0xab, 0x3, 0xac, 
			 0x3, 0xac, 0x3, 0xac, 0x5, 0xac, 0x88f, 0xa, 0xac, 0x3, 0xac, 0x3, 0xac, 
			 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 0x5, 0xac, 0x896, 0xa, 0xac, 0x3, 0xad, 
			 0x3, 0xad, 0x5, 0xad, 0x89a, 0xa, 0xad, 0x3, 0xae, 0x3, 0xae, 0x3, 0xae, 
			 0x3, 0xaf, 0x3, 0xaf, 0x3, 0xaf, 0x3, 0xaf, 0x3, 0xaf, 0x5, 0xaf, 0x8a4, 
			 0xa, 0xaf, 0x3, 0xb0, 0x3, 0xb0, 0x3, 0xb0, 0x3, 0xb0, 0x3, 0xb0, 0x3, 
			 0xb0, 0x3, 0xb1, 0x3, 0xb1, 0x3, 0xb1, 0x3, 0xb1, 0x3, 0xb1, 0x3, 0xb1, 
			 0x7, 0xb1, 0x8b2, 0xa, 0xb1, 0xc, 0xb1, 0xe, 0xb1, 0x8b5, 0xb, 0xb1, 
			 0x3, 0xb2, 0x3, 0xb2, 0x5, 0xb2, 0x8b9, 0xa, 0xb2, 0x3, 0xb3, 0x3, 0xb3, 
			 0x5, 0xb3, 0x8bd, 0xa, 0xb3, 0x3, 0xb3, 0x5, 0xb3, 0x8c0, 0xa, 0xb3, 
			 0x3, 0xb3, 0x3, 0xb3, 0x5, 0xb3, 0x8c4, 0xa, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 
			 0x3, 0xb3, 0x3, 0xb3, 0x5, 0xb3, 0x8ca, 0xa, 0xb3, 0x3, 0xb3, 0x5, 0xb3, 
			 0x8cd, 0xa, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x5, 0xb3, 0x8d1, 0xa, 0xb3, 
			 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 
			 0xb3, 0x3, 0xb3, 0x5, 0xb3, 0x8db, 0xa, 0xb3, 0x3, 0xb3, 0x5, 0xb3, 
			 0x8de, 0xa, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 
			 0x3, 0xb3, 0x5, 0xb3, 0x8e6, 0xa, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 
			 0x5, 0xb3, 0x8eb, 0xa, 0xb3, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x5, 0xb4, 
			 0x8f0, 0xa, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb5, 0x3, 0xb5, 0x3, 0xb5, 
			 0x3, 0xb5, 0x5, 0xb5, 0x8f8, 0xa, 0xb5, 0x3, 0xb5, 0x3, 0xb5, 0x3, 0xb5, 
			 0x3, 0xb5, 0x3, 0xb5, 0x5, 0xb5, 0x8ff, 0xa, 0xb5, 0x3, 0xb5, 0x3, 0xb5, 
			 0x5, 0xb5, 0x903, 0xa, 0xb5, 0x3, 0xb6, 0x3, 0xb6, 0x3, 0xb7, 0x3, 0xb7, 
			 0x3, 0xb7, 0x5, 0xb7, 0x90a, 0xa, 0xb7, 0x3, 0xb7, 0x3, 0xb7, 0x3, 0xb7, 
			 0x3, 0xb7, 0x5, 0xb7, 0x910, 0xa, 0xb7, 0x7, 0xb7, 0x912, 0xa, 0xb7, 
			 0xc, 0xb7, 0xe, 0xb7, 0x915, 0xb, 0xb7, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 
			 0x3, 0xb8, 0x5, 0xb8, 0x91b, 0xa, 0xb8, 0x3, 0xb9, 0x3, 0xb9, 0x3, 0xb9, 
			 0x3, 0xb9, 0x3, 0xb9, 0x3, 0xb9, 0x3, 0xb9, 0x5, 0xb9, 0x924, 0xa, 0xb9, 
			 0x3, 0xb9, 0x3, 0xb9, 0x5, 0xb9, 0x928, 0xa, 0xb9, 0x3, 0xba, 0x5, 0xba, 
			 0x92b, 0xa, 0xba, 0x3, 0xba, 0x3, 0xba, 0x3, 0xba, 0x3, 0xbb, 0x3, 0xbb, 
			 0x3, 0xbb, 0x3, 0xbb, 0x3, 0xbb, 0x3, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x3, 
			 0xbc, 0x3, 0xbd, 0x3, 0xbd, 0x5, 0xbd, 0x93b, 0xa, 0xbd, 0x3, 0xbd, 
			 0x3, 0xbd, 0x3, 0xbd, 0x3, 0xbe, 0x3, 0xbe, 0x5, 0xbe, 0x942, 0xa, 0xbe, 
			 0x3, 0xbf, 0x3, 0xbf, 0x3, 0xbf, 0x3, 0xbf, 0x3, 0xbf, 0x3, 0xbf, 0x3, 
			 0xc0, 0x5, 0xc0, 0x94b, 0xa, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 
			 0x3, 0xc0, 0x5, 0xc0, 0x951, 0xa, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 0x5, 0xc0, 
			 0x955, 0xa, 0xc0, 0x3, 0xc0, 0x5, 0xc0, 0x958, 0xa, 0xc0, 0x3, 0xc1, 
			 0x3, 0xc1, 0x5, 0xc1, 0x95c, 0xa, 0xc1, 0x3, 0xc2, 0x3, 0xc2, 0x5, 0xc2, 
			 0x960, 0xa, 0xc2, 0x3, 0xc3, 0x3, 0xc3, 0x3, 0xc3, 0x5, 0xc3, 0x965, 
			 0xa, 0xc3, 0x3, 0xc3, 0x3, 0xc3, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x5, 
			 0xc4, 0x96c, 0xa, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 
			 0x5, 0xc4, 0x972, 0xa, 0xc4, 0x7, 0xc4, 0x974, 0xa, 0xc4, 0xc, 0xc4, 
			 0xe, 0xc4, 0x977, 0xb, 0xc4, 0x3, 0xc5, 0x3, 0xc5, 0x3, 0xc5, 0x3, 0xc5, 
			 0x3, 0xc5, 0x3, 0xc5, 0x5, 0xc5, 0x97f, 0xa, 0xc5, 0x3, 0xc6, 0x3, 0xc6, 
			 0x3, 0xc6, 0x3, 0xc7, 0x3, 0xc7, 0x3, 0xc7, 0x3, 0xc7, 0x3, 0xc8, 0x3, 
			 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 
			 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 
			 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 
			 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 
			 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 
			 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 
			 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 
			 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x5, 0xc8, 0x9bb, 0xa, 0xc8, 
			 0x3, 0xc9, 0x3, 0xc9, 0x3, 0xc9, 0x3, 0xc9, 0x3, 0xc9, 0x3, 0xc9, 0x3, 
			 0xc9, 0x5, 0xc9, 0x9c4, 0xa, 0xc9, 0x3, 0xca, 0x3, 0xca, 0x3, 0xcb, 
			 0x3, 0xcb, 0x3, 0xcc, 0x3, 0xcc, 0x3, 0xcc, 0x2, 0x23, 0xc, 0x16, 0x20, 
			 0x36, 0x40, 0x42, 0x44, 0x46, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 
			 0x5e, 0x6a, 0xb4, 0xd8, 0xde, 0xea, 0xee, 0xf6, 0x10c, 0x110, 0x114, 
			 0x122, 0x136, 0x13a, 0x142, 0x160, 0x16c, 0x186, 0xcd, 0x2, 0x4, 0x6, 
			 0x8, 0xa, 0xc, 0xe, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e, 
			 0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 
			 0x38, 0x3a, 0x3c, 0x3e, 0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 
			 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e, 0x60, 0x62, 0x64, 0x66, 
			 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e, 
			 0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 
			 0x98, 0x9a, 0x9c, 0x9e, 0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 
			 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe, 0xc0, 0xc2, 0xc4, 0xc6, 
			 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde, 
			 0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 
			 0xf8, 0xfa, 0xfc, 0xfe, 0x100, 0x102, 0x104, 0x106, 0x108, 0x10a, 0x10c, 
			 0x10e, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11a, 0x11c, 0x11e, 0x120, 
			 0x122, 0x124, 0x126, 0x128, 0x12a, 0x12c, 0x12e, 0x130, 0x132, 0x134, 
			 0x136, 0x138, 0x13a, 0x13c, 0x13e, 0x140, 0x142, 0x144, 0x146, 0x148, 
			 0x14a, 0x14c, 0x14e, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15a, 0x15c, 
			 0x15e, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16a, 0x16c, 0x16e, 0x170, 
			 0x172, 0x174, 0x176, 0x178, 0x17a, 0x17c, 0x17e, 0x180, 0x182, 0x184, 
			 0x186, 0x188, 0x18a, 0x18c, 0x18e, 0x190, 0x192, 0x194, 0x196, 0x2, 
			 0xf, 0x4, 0x2, 0x62, 0x62, 0x66, 0x66, 0x5, 0x2, 0x3, 0x4, 0x5c, 0x5e, 
			 0x62, 0x64, 0x3, 0x2, 0x9, 0xa, 0x7, 0x2, 0x25, 0x25, 0x30, 0x30, 0x3a, 
			 0x3a, 0x40, 0x40, 0x47, 0x47, 0x5, 0x2, 0x23, 0x23, 0x2d, 0x2d, 0x51, 
			 0x51, 0x3, 0x2, 0x56, 0x5b, 0x4, 0x2, 0x17, 0x17, 0x53, 0x53, 0x4, 0x2, 
			 0x5, 0x5, 0x62, 0x62, 0x5, 0x2, 0x16, 0x16, 0x43, 0x43, 0x4e, 0x4e, 
			 0x4, 0x2, 0x27, 0x27, 0x36, 0x36, 0x3, 0x2, 0x37, 0x39, 0x4, 0x2, 0x26, 
			 0x26, 0x49, 0x49, 0x3, 0x2, 0x8e, 0x91, 0x2, 0xaf7, 0x2, 0x199, 0x3, 
			 0x2, 0x2, 0x2, 0x4, 0x1a5, 0x3, 0x2, 0x2, 0x2, 0x6, 0x1a9, 0x3, 0x2, 
			 0x2, 0x2, 0x8, 0x1b4, 0x3, 0x2, 0x2, 0x2, 0xa, 0x1b6, 0x3, 0x2, 0x2, 
			 0x2, 0xc, 0x1c7, 0x3, 0x2, 0x2, 0x2, 0xe, 0x1d8, 0x3, 0x2, 0x2, 0x2, 
			 0x10, 0x1de, 0x3, 0x2, 0x2, 0x2, 0x12, 0x1ea, 0x3, 0x2, 0x2, 0x2, 0x14, 
			 0x1ec, 0x3, 0x2, 0x2, 0x2, 0x16, 0x1ee, 0x3, 0x2, 0x2, 0x2, 0x18, 0x200, 
			 0x3, 0x2, 0x2, 0x2, 0x1a, 0x206, 0x3, 0x2, 0x2, 0x2, 0x1c, 0x20d, 0x3, 
			 0x2, 0x2, 0x2, 0x1e, 0x20f, 0x3, 0x2, 0x2, 0x2, 0x20, 0x25e, 0x3, 0x2, 
			 0x2, 0x2, 0x22, 0x28b, 0x3, 0x2, 0x2, 0x2, 0x24, 0x28d, 0x3, 0x2, 0x2, 
			 0x2, 0x26, 0x28f, 0x3, 0x2, 0x2, 0x2, 0x28, 0x2a7, 0x3, 0x2, 0x2, 0x2, 
			 0x2a, 0x2c5, 0x3, 0x2, 0x2, 0x2, 0x2c, 0x2c7, 0x3, 0x2, 0x2, 0x2, 0x2e, 
			 0x2e1, 0x3, 0x2, 0x2, 0x2, 0x30, 0x2e3, 0x3, 0x2, 0x2, 0x2, 0x32, 0x2e7, 
			 0x3, 0x2, 0x2, 0x2, 0x34, 0x2f1, 0x3, 0x2, 0x2, 0x2, 0x36, 0x2f3, 0x3, 
			 0x2, 0x2, 0x2, 0x38, 0x30c, 0x3, 0x2, 0x2, 0x2, 0x3a, 0x31a, 0x3, 0x2, 
			 0x2, 0x2, 0x3c, 0x31c, 0x3, 0x2, 0x2, 0x2, 0x3e, 0x327, 0x3, 0x2, 0x2, 
			 0x2, 0x40, 0x329, 0x3, 0x2, 0x2, 0x2, 0x42, 0x337, 0x3, 0x2, 0x2, 0x2, 
			 0x44, 0x348, 0x3, 0x2, 0x2, 0x2, 0x46, 0x356, 0x3, 0x2, 0x2, 0x2, 0x48, 
			 0x364, 0x3, 0x2, 0x2, 0x2, 0x4a, 0x366, 0x3, 0x2, 0x2, 0x2, 0x4c, 0x37a, 
			 0x3, 0x2, 0x2, 0x2, 0x4e, 0x388, 0x3, 0x2, 0x2, 0x2, 0x50, 0x393, 0x3, 
			 0x2, 0x2, 0x2, 0x52, 0x39e, 0x3, 0x2, 0x2, 0x2, 0x54, 0x3a9, 0x3, 0x2, 
			 0x2, 0x2, 0x56, 0x3b7, 0x3, 0x2, 0x2, 0x2, 0x58, 0x3cc, 0x3, 0x2, 0x2, 
			 0x2, 0x5a, 0x3d4, 0x3, 0x2, 0x2, 0x2, 0x5c, 0x3e1, 0x3, 0x2, 0x2, 0x2, 
			 0x5e, 0x3e3, 0x3, 0x2, 0x2, 0x2, 0x60, 0x3ee, 0x3, 0x2, 0x2, 0x2, 0x62, 
			 0x40a, 0x3, 0x2, 0x2, 0x2, 0x64, 0x420, 0x3, 0x2, 0x2, 0x2, 0x66, 0x423, 
			 0x3, 0x2, 0x2, 0x2, 0x68, 0x427, 0x3, 0x2, 0x2, 0x2, 0x6a, 0x42d, 0x3, 
			 0x2, 0x2, 0x2, 0x6c, 0x44b, 0x3, 0x2, 0x2, 0x2, 0x6e, 0x45d, 0x3, 0x2, 
			 0x2, 0x2, 0x70, 0x482, 0x3, 0x2, 0x2, 0x2, 0x72, 0x486, 0x3, 0x2, 0x2, 
			 0x2, 0x74, 0x489, 0x3, 0x2, 0x2, 0x2, 0x76, 0x490, 0x3, 0x2, 0x2, 0x2, 
			 0x78, 0x4a2, 0x3, 0x2, 0x2, 0x2, 0x7a, 0x4a4, 0x3, 0x2, 0x2, 0x2, 0x7c, 
			 0x4a9, 0x3, 0x2, 0x2, 0x2, 0x7e, 0x4b6, 0x3, 0x2, 0x2, 0x2, 0x80, 0x4b8, 
			 0x3, 0x2, 0x2, 0x2, 0x82, 0x4c2, 0x3, 0x2, 0x2, 0x2, 0x84, 0x4c4, 0x3, 
			 0x2, 0x2, 0x2, 0x86, 0x4db, 0x3, 0x2, 0x2, 0x2, 0x88, 0x4dd, 0x3, 0x2, 
			 0x2, 0x2, 0x8a, 0x4e5, 0x3, 0x2, 0x2, 0x2, 0x8c, 0x4e7, 0x3, 0x2, 0x2, 
			 0x2, 0x8e, 0x4f0, 0x3, 0x2, 0x2, 0x2, 0x90, 0x4f9, 0x3, 0x2, 0x2, 0x2, 
			 0x92, 0x4fb, 0x3, 0x2, 0x2, 0x2, 0x94, 0x4fd, 0x3, 0x2, 0x2, 0x2, 0x96, 
			 0x4ff, 0x3, 0x2, 0x2, 0x2, 0x98, 0x504, 0x3, 0x2, 0x2, 0x2, 0x9a, 0x50a, 
			 0x3, 0x2, 0x2, 0x2, 0x9c, 0x513, 0x3, 0x2, 0x2, 0x2, 0x9e, 0x51c, 0x3, 
			 0x2, 0x2, 0x2, 0xa0, 0x535, 0x3, 0x2, 0x2, 0x2, 0xa2, 0x53b, 0x3, 0x2, 
			 0x2, 0x2, 0xa4, 0x546, 0x3, 0x2, 0x2, 0x2, 0xa6, 0x560, 0x3, 0x2, 0x2, 
			 0x2, 0xa8, 0x562, 0x3, 0x2, 0x2, 0x2, 0xaa, 0x571, 0x3, 0x2, 0x2, 0x2, 
			 0xac, 0x586, 0x3, 0x2, 0x2, 0x2, 0xae, 0x588, 0x3, 0x2, 0x2, 0x2, 0xb0, 
			 0x597, 0x3, 0x2, 0x2, 0x2, 0xb2, 0x599, 0x3, 0x2, 0x2, 0x2, 0xb4, 0x59c, 
			 0x3, 0x2, 0x2, 0x2, 0xb6, 0x5ac, 0x3, 0x2, 0x2, 0x2, 0xb8, 0x5ae, 0x3, 
			 0x2, 0x2, 0x2, 0xba, 0x5b2, 0x3, 0x2, 0x2, 0x2, 0xbc, 0x5b4, 0x3, 0x2, 
			 0x2, 0x2, 0xbe, 0x5b8, 0x3, 0x2, 0x2, 0x2, 0xc0, 0x5bc, 0x3, 0x2, 0x2, 
			 0x2, 0xc2, 0x5bf, 0x3, 0x2, 0x2, 0x2, 0xc4, 0x5c8, 0x3, 0x2, 0x2, 0x2, 
			 0xc6, 0x5d1, 0x3, 0x2, 0x2, 0x2, 0xc8, 0x5d9, 0x3, 0x2, 0x2, 0x2, 0xca, 
			 0x5db, 0x3, 0x2, 0x2, 0x2, 0xcc, 0x5dd, 0x3, 0x2, 0x2, 0x2, 0xce, 0x5e4, 
			 0x3, 0x2, 0x2, 0x2, 0xd0, 0x5f5, 0x3, 0x2, 0x2, 0x2, 0xd2, 0x5f8, 0x3, 
			 0x2, 0x2, 0x2, 0xd4, 0x602, 0x3, 0x2, 0x2, 0x2, 0xd6, 0x612, 0x3, 0x2, 
			 0x2, 0x2, 0xd8, 0x614, 0x3, 0x2, 0x2, 0x2, 0xda, 0x625, 0x3, 0x2, 0x2, 
			 0x2, 0xdc, 0x637, 0x3, 0x2, 0x2, 0x2, 0xde, 0x640, 0x3, 0x2, 0x2, 0x2, 
			 0xe0, 0x651, 0x3, 0x2, 0x2, 0x2, 0xe2, 0x657, 0x3, 0x2, 0x2, 0x2, 0xe4, 
			 0x659, 0x3, 0x2, 0x2, 0x2, 0xe6, 0x65d, 0x3, 0x2, 0x2, 0x2, 0xe8, 0x65f, 
			 0x3, 0x2, 0x2, 0x2, 0xea, 0x663, 0x3, 0x2, 0x2, 0x2, 0xec, 0x67f, 0x3, 
			 0x2, 0x2, 0x2, 0xee, 0x681, 0x3, 0x2, 0x2, 0x2, 0xf0, 0x68c, 0x3, 0x2, 
			 0x2, 0x2, 0xf2, 0x695, 0x3, 0x2, 0x2, 0x2, 0xf4, 0x69b, 0x3, 0x2, 0x2, 
			 0x2, 0xf6, 0x6a6, 0x3, 0x2, 0x2, 0x2, 0xf8, 0x6b8, 0x3, 0x2, 0x2, 0x2, 
			 0xfa, 0x6c7, 0x3, 0x2, 0x2, 0x2, 0xfc, 0x6e3, 0x3, 0x2, 0x2, 0x2, 0xfe, 
			 0x6e5, 0x3, 0x2, 0x2, 0x2, 0x100, 0x6e9, 0x3, 0x2, 0x2, 0x2, 0x102, 
			 0x6eb, 0x3, 0x2, 0x2, 0x2, 0x104, 0x6ee, 0x3, 0x2, 0x2, 0x2, 0x106, 
			 0x6f2, 0x3, 0x2, 0x2, 0x2, 0x108, 0x6fe, 0x3, 0x2, 0x2, 0x2, 0x10a, 
			 0x705, 0x3, 0x2, 0x2, 0x2, 0x10c, 0x715, 0x3, 0x2, 0x2, 0x2, 0x10e, 
			 0x72b, 0x3, 0x2, 0x2, 0x2, 0x110, 0x72d, 0x3, 0x2, 0x2, 0x2, 0x112, 
			 0x74a, 0x3, 0x2, 0x2, 0x2, 0x114, 0x74c, 0x3, 0x2, 0x2, 0x2, 0x116, 
			 0x781, 0x3, 0x2, 0x2, 0x2, 0x118, 0x784, 0x3, 0x2, 0x2, 0x2, 0x11a, 
			 0x79a, 0x3, 0x2, 0x2, 0x2, 0x11c, 0x7a1, 0x3, 0x2, 0x2, 0x2, 0x11e, 
			 0x7a6, 0x3, 0x2, 0x2, 0x2, 0x120, 0x7aa, 0x3, 0x2, 0x2, 0x2, 0x122, 
			 0x7ac, 0x3, 0x2, 0x2, 0x2, 0x124, 0x7c5, 0x3, 0x2, 0x2, 0x2, 0x126, 
			 0x7c9, 0x3, 0x2, 0x2, 0x2, 0x128, 0x7cb, 0x3, 0x2, 0x2, 0x2, 0x12a, 
			 0x7e4, 0x3, 0x2, 0x2, 0x2, 0x12c, 0x7e7, 0x3, 0x2, 0x2, 0x2, 0x12e, 
			 0x7eb, 0x3, 0x2, 0x2, 0x2, 0x130, 0x7ed, 0x3, 0x2, 0x2, 0x2, 0x132, 
			 0x7f8, 0x3, 0x2, 0x2, 0x2, 0x134, 0x80a, 0x3, 0x2, 0x2, 0x2, 0x136, 
			 0x80c, 0x3, 0x2, 0x2, 0x2, 0x138, 0x82a, 0x3, 0x2, 0x2, 0x2, 0x13a, 
			 0x82c, 0x3, 0x2, 0x2, 0x2, 0x13c, 0x836, 0x3, 0x2, 0x2, 0x2, 0x13e, 
			 0x838, 0x3, 0x2, 0x2, 0x2, 0x140, 0x83b, 0x3, 0x2, 0x2, 0x2, 0x142, 
			 0x83e, 0x3, 0x2, 0x2, 0x2, 0x144, 0x863, 0x3, 0x2, 0x2, 0x2, 0x146, 
			 0x86a, 0x3, 0x2, 0x2, 0x2, 0x148, 0x86c, 0x3, 0x2, 0x2, 0x2, 0x14a, 
			 0x86e, 0x3, 0x2, 0x2, 0x2, 0x14c, 0x870, 0x3, 0x2, 0x2, 0x2, 0x14e, 
			 0x873, 0x3, 0x2, 0x2, 0x2, 0x150, 0x877, 0x3, 0x2, 0x2, 0x2, 0x152, 
			 0x87b, 0x3, 0x2, 0x2, 0x2, 0x154, 0x889, 0x3, 0x2, 0x2, 0x2, 0x156, 
			 0x895, 0x3, 0x2, 0x2, 0x2, 0x158, 0x899, 0x3, 0x2, 0x2, 0x2, 0x15a, 
			 0x89b, 0x3, 0x2, 0x2, 0x2, 0x15c, 0x8a3, 0x3, 0x2, 0x2, 0x2, 0x15e, 
			 0x8a5, 0x3, 0x2, 0x2, 0x2, 0x160, 0x8ab, 0x3, 0x2, 0x2, 0x2, 0x162, 
			 0x8b8, 0x3, 0x2, 0x2, 0x2, 0x164, 0x8ea, 0x3, 0x2, 0x2, 0x2, 0x166, 
			 0x8ec, 0x3, 0x2, 0x2, 0x2, 0x168, 0x902, 0x3, 0x2, 0x2, 0x2, 0x16a, 
			 0x904, 0x3, 0x2, 0x2, 0x2, 0x16c, 0x906, 0x3, 0x2, 0x2, 0x2, 0x16e, 
			 0x91a, 0x3, 0x2, 0x2, 0x2, 0x170, 0x927, 0x3, 0x2, 0x2, 0x2, 0x172, 
			 0x92a, 0x3, 0x2, 0x2, 0x2, 0x174, 0x92f, 0x3, 0x2, 0x2, 0x2, 0x176, 
			 0x934, 0x3, 0x2, 0x2, 0x2, 0x178, 0x938, 0x3, 0x2, 0x2, 0x2, 0x17a, 
			 0x93f, 0x3, 0x2, 0x2, 0x2, 0x17c, 0x943, 0x3, 0x2, 0x2, 0x2, 0x17e, 
			 0x957, 0x3, 0x2, 0x2, 0x2, 0x180, 0x959, 0x3, 0x2, 0x2, 0x2, 0x182, 
			 0x95f, 0x3, 0x2, 0x2, 0x2, 0x184, 0x961, 0x3, 0x2, 0x2, 0x2, 0x186, 
			 0x968, 0x3, 0x2, 0x2, 0x2, 0x188, 0x97e, 0x3, 0x2, 0x2, 0x2, 0x18a, 
			 0x980, 0x3, 0x2, 0x2, 0x2, 0x18c, 0x983, 0x3, 0x2, 0x2, 0x2, 0x18e, 
			 0x9ba, 0x3, 0x2, 0x2, 0x2, 0x190, 0x9c3, 0x3, 0x2, 0x2, 0x2, 0x192, 
			 0x9c5, 0x3, 0x2, 0x2, 0x2, 0x194, 0x9c7, 0x3, 0x2, 0x2, 0x2, 0x196, 
			 0x9c9, 0x3, 0x2, 0x2, 0x2, 0x198, 0x19a, 0x5, 0x7c, 0x3f, 0x2, 0x199, 
			 0x198, 0x3, 0x2, 0x2, 0x2, 0x199, 0x19a, 0x3, 0x2, 0x2, 0x2, 0x19a, 
			 0x19b, 0x3, 0x2, 0x2, 0x2, 0x19b, 0x19c, 0x7, 0x2, 0x2, 0x3, 0x19c, 
			 0x3, 0x3, 0x2, 0x2, 0x2, 0x19d, 0x1a6, 0x5, 0x190, 0xc9, 0x2, 0x19e, 
			 0x1a6, 0x7, 0x46, 0x2, 0x2, 0x19f, 0x1a0, 0x7, 0x56, 0x2, 0x2, 0x1a0, 
			 0x1a1, 0x5, 0x5e, 0x30, 0x2, 0x1a1, 0x1a2, 0x7, 0x57, 0x2, 0x2, 0x1a2, 
			 0x1a6, 0x3, 0x2, 0x2, 0x2, 0x1a3, 0x1a6, 0x5, 0x6, 0x4, 0x2, 0x1a4, 
			 0x1a6, 0x5, 0xe, 0x8, 0x2, 0x1a5, 0x19d, 0x3, 0x2, 0x2, 0x2, 0x1a5, 
			 0x19e, 0x3, 0x2, 0x2, 0x2, 0x1a5, 0x19f, 0x3, 0x2, 0x2, 0x2, 0x1a5, 
			 0x1a3, 0x3, 0x2, 0x2, 0x2, 0x1a5, 0x1a4, 0x3, 0x2, 0x2, 0x2, 0x1a6, 
			 0x5, 0x3, 0x2, 0x2, 0x2, 0x1a7, 0x1aa, 0x5, 0x8, 0x5, 0x2, 0x1a8, 0x1aa, 
			 0x5, 0xa, 0x6, 0x2, 0x1a9, 0x1a7, 0x3, 0x2, 0x2, 0x2, 0x1a9, 0x1a8, 
			 0x3, 0x2, 0x2, 0x2, 0x1aa, 0x7, 0x3, 0x2, 0x2, 0x2, 0x1ab, 0x1b5, 0x7, 
			 0x84, 0x2, 0x2, 0x1ac, 0x1b5, 0x5, 0x15a, 0xae, 0x2, 0x1ad, 0x1b5, 0x5, 
			 0x14c, 0xa7, 0x2, 0x1ae, 0x1b5, 0x5, 0x15c, 0xaf, 0x2, 0x1af, 0x1b0, 
			 0x7, 0x64, 0x2, 0x2, 0x1b0, 0x1b5, 0x5, 0x126, 0x94, 0x2, 0x1b1, 0x1b2, 
			 0x7, 0x64, 0x2, 0x2, 0x1b2, 0x1b5, 0x5, 0xa4, 0x53, 0x2, 0x1b3, 0x1b5, 
			 0x5, 0x168, 0xb5, 0x2, 0x1b4, 0x1ab, 0x3, 0x2, 0x2, 0x2, 0x1b4, 0x1ac, 
			 0x3, 0x2, 0x2, 0x2, 0x1b4, 0x1ad, 0x3, 0x2, 0x2, 0x2, 0x1b4, 0x1ae, 
			 0x3, 0x2, 0x2, 0x2, 0x1b4, 0x1af, 0x3, 0x2, 0x2, 0x2, 0x1b4, 0x1b1, 
			 0x3, 0x2, 0x2, 0x2, 0x1b4, 0x1b3, 0x3, 0x2, 0x2, 0x2, 0x1b5, 0x9, 0x3, 
			 0x2, 0x2, 0x2, 0x1b6, 0x1b8, 0x5, 0xc, 0x7, 0x2, 0x1b7, 0x1b9, 0x7, 
			 0x45, 0x2, 0x2, 0x1b8, 0x1b7, 0x3, 0x2, 0x2, 0x2, 0x1b8, 0x1b9, 0x3, 
			 0x2, 0x2, 0x2, 0x1b9, 0x1ba, 0x3, 0x2, 0x2, 0x2, 0x1ba, 0x1bb, 0x5, 
			 0x8, 0x5, 0x2, 0x1bb, 0xb, 0x3, 0x2, 0x2, 0x2, 0x1bc, 0x1bd, 0x8, 0x7, 
			 0x1, 0x2, 0x1bd, 0x1c8, 0x7, 0x7f, 0x2, 0x2, 0x1be, 0x1bf, 0x5, 0xa2, 
			 0x52, 0x2, 0x1bf, 0x1c0, 0x7, 0x7f, 0x2, 0x2, 0x1c0, 0x1c8, 0x3, 0x2, 
			 0x2, 0x2, 0x1c1, 0x1c2, 0x5, 0xba, 0x5e, 0x2, 0x1c2, 0x1c3, 0x7, 0x7f, 
			 0x2, 0x2, 0x1c3, 0x1c8, 0x3, 0x2, 0x2, 0x2, 0x1c4, 0x1c5, 0x5, 0xa4, 
			 0x53, 0x2, 0x1c5, 0x1c6, 0x7, 0x7f, 0x2, 0x2, 0x1c6, 0x1c8, 0x3, 0x2, 
			 0x2, 0x2, 0x1c7, 0x1bc, 0x3, 0x2, 0x2, 0x2, 0x1c7, 0x1be, 0x3, 0x2, 
			 0x2, 0x2, 0x1c7, 0x1c1, 0x3, 0x2, 0x2, 0x2, 0x1c7, 0x1c4, 0x3, 0x2, 
			 0x2, 0x2, 0x1c8, 0x1d5, 0x3, 0x2, 0x2, 0x2, 0x1c9, 0x1ca, 0xc, 0x4, 
			 0x2, 0x2, 0x1ca, 0x1cb, 0x7, 0x84, 0x2, 0x2, 0x1cb, 0x1d4, 0x7, 0x7f, 
			 0x2, 0x2, 0x1cc, 0x1ce, 0xc, 0x3, 0x2, 0x2, 0x1cd, 0x1cf, 0x7, 0x45, 
			 0x2, 0x2, 0x1ce, 0x1cd, 0x3, 0x2, 0x2, 0x2, 0x1ce, 0x1cf, 0x3, 0x2, 
			 0x2, 0x2, 0x1cf, 0x1d0, 0x3, 0x2, 0x2, 0x2, 0x1d0, 0x1d1, 0x5, 0x166, 
			 0xb4, 0x2, 0x1d1, 0x1d2, 0x7, 0x7f, 0x2, 0x2, 0x1d2, 0x1d4, 0x3, 0x2, 
			 0x2, 0x2, 0x1d3, 0x1c9, 0x3, 0x2, 0x2, 0x2, 0x1d3, 0x1cc, 0x3, 0x2, 
			 0x2, 0x2, 0x1d4, 0x1d7, 0x3, 0x2, 0x2, 0x2, 0x1d5, 0x1d3, 0x3, 0x2, 
			 0x2, 0x2, 0x1d5, 0x1d6, 0x3, 0x2, 0x2, 0x2, 0x1d6, 0xd, 0x3, 0x2, 0x2, 
			 0x2, 0x1d7, 0x1d5, 0x3, 0x2, 0x2, 0x2, 0x1d8, 0x1da, 0x5, 0x10, 0x9, 
			 0x2, 0x1d9, 0x1db, 0x5, 0x1e, 0x10, 0x2, 0x1da, 0x1d9, 0x3, 0x2, 0x2, 
			 0x2, 0x1da, 0x1db, 0x3, 0x2, 0x2, 0x2, 0x1db, 0x1dc, 0x3, 0x2, 0x2, 
			 0x2, 0x1dc, 0x1dd, 0x5, 0x68, 0x35, 0x2, 0x1dd, 0xf, 0x3, 0x2, 0x2, 
			 0x2, 0x1de, 0x1e0, 0x7, 0x58, 0x2, 0x2, 0x1df, 0x1e1, 0x5, 0x12, 0xa, 
			 0x2, 0x1e0, 0x1df, 0x3, 0x2, 0x2, 0x2, 0x1e0, 0x1e1, 0x3, 0x2, 0x2, 
			 0x2, 0x1e1, 0x1e2, 0x3, 0x2, 0x2, 0x2, 0x1e2, 0x1e3, 0x7, 0x59, 0x2, 
			 0x2, 0x1e3, 0x11, 0x3, 0x2, 0x2, 0x2, 0x1e4, 0x1eb, 0x5, 0x14, 0xb, 
			 0x2, 0x1e5, 0x1eb, 0x5, 0x16, 0xc, 0x2, 0x1e6, 0x1e7, 0x5, 0x14, 0xb, 
			 0x2, 0x1e7, 0x1e8, 0x7, 0x7a, 0x2, 0x2, 0x1e8, 0x1e9, 0x5, 0x16, 0xc, 
			 0x2, 0x1e9, 0x1eb, 0x3, 0x2, 0x2, 0x2, 0x1ea, 0x1e4, 0x3, 0x2, 0x2, 
			 0x2, 0x1ea, 0x1e5, 0x3, 0x2, 0x2, 0x2, 0x1ea, 0x1e6, 0x3, 0x2, 0x2, 
			 0x2, 0x1eb, 0x13, 0x3, 0x2, 0x2, 0x2, 0x1ec, 0x1ed, 0x9, 0x2, 0x2, 0x2, 
			 0x1ed, 0x15, 0x3, 0x2, 0x2, 0x2, 0x1ee, 0x1ef, 0x8, 0xc, 0x1, 0x2, 0x1ef, 
			 0x1f1, 0x5, 0x18, 0xd, 0x2, 0x1f0, 0x1f2, 0x7, 0x83, 0x2, 0x2, 0x1f1, 
			 0x1f0, 0x3, 0x2, 0x2, 0x2, 0x1f1, 0x1f2, 0x3, 0x2, 0x2, 0x2, 0x1f2, 
			 0x1fb, 0x3, 0x2, 0x2, 0x2, 0x1f3, 0x1f4, 0xc, 0x3, 0x2, 0x2, 0x1f4, 
			 0x1f5, 0x7, 0x7a, 0x2, 0x2, 0x1f5, 0x1f7, 0x5, 0x18, 0xd, 0x2, 0x1f6, 
			 0x1f8, 0x7, 0x83, 0x2, 0x2, 0x1f7, 0x1f6, 0x3, 0x2, 0x2, 0x2, 0x1f7, 
			 0x1f8, 0x3, 0x2, 0x2, 0x2, 0x1f8, 0x1fa, 0x3, 0x2, 0x2, 0x2, 0x1f9, 
			 0x1f3, 0x3, 0x2, 0x2, 0x2, 0x1fa, 0x1fd, 0x3, 0x2, 0x2, 0x2, 0x1fb, 
			 0x1f9, 0x3, 0x2, 0x2, 0x2, 0x1fb, 0x1fc, 0x3, 0x2, 0x2, 0x2, 0x1fc, 
			 0x17, 0x3, 0x2, 0x2, 0x2, 0x1fd, 0x1fb, 0x3, 0x2, 0x2, 0x2, 0x1fe, 0x201, 
			 0x5, 0x1a, 0xe, 0x2, 0x1ff, 0x201, 0x5, 0x1c, 0xf, 0x2, 0x200, 0x1fe, 
			 0x3, 0x2, 0x2, 0x2, 0x200, 0x1ff, 0x3, 0x2, 0x2, 0x2, 0x201, 0x19, 0x3, 
			 0x2, 0x2, 0x2, 0x202, 0x207, 0x7, 0x84, 0x2, 0x2, 0x203, 0x204, 0x7, 
			 0x62, 0x2, 0x2, 0x204, 0x207, 0x7, 0x84, 0x2, 0x2, 0x205, 0x207, 0x7, 
			 0x46, 0x2, 0x2, 0x206, 0x202, 0x3, 0x2, 0x2, 0x2, 0x206, 0x203, 0x3, 
			 0x2, 0x2, 0x2, 0x206, 0x205, 0x3, 0x2, 0x2, 0x2, 0x207, 0x1b, 0x3, 0x2, 
			 0x2, 0x2, 0x208, 0x209, 0x7, 0x84, 0x2, 0x2, 0x209, 0x20e, 0x5, 0x11c, 
			 0x8f, 0x2, 0x20a, 0x20b, 0x7, 0x62, 0x2, 0x2, 0x20b, 0x20c, 0x7, 0x84, 
			 0x2, 0x2, 0x20c, 0x20e, 0x5, 0x11c, 0x8f, 0x2, 0x20d, 0x208, 0x3, 0x2, 
			 0x2, 0x2, 0x20d, 0x20a, 0x3, 0x2, 0x2, 0x2, 0x20e, 0x1d, 0x3, 0x2, 0x2, 
			 0x2, 0x20f, 0x210, 0x7, 0x56, 0x2, 0x2, 0x210, 0x211, 0x5, 0x112, 0x8a, 
			 0x2, 0x211, 0x213, 0x7, 0x57, 0x2, 0x2, 0x212, 0x214, 0x7, 0x30, 0x2, 
			 0x2, 0x213, 0x212, 0x3, 0x2, 0x2, 0x2, 0x213, 0x214, 0x3, 0x2, 0x2, 
			 0x2, 0x214, 0x216, 0x3, 0x2, 0x2, 0x2, 0x215, 0x217, 0x5, 0x182, 0xc2, 
			 0x2, 0x216, 0x215, 0x3, 0x2, 0x2, 0x2, 0x216, 0x217, 0x3, 0x2, 0x2, 
			 0x2, 0x217, 0x219, 0x3, 0x2, 0x2, 0x2, 0x218, 0x21a, 0x5, 0xd8, 0x6d, 
			 0x2, 0x219, 0x218, 0x3, 0x2, 0x2, 0x2, 0x219, 0x21a, 0x3, 0x2, 0x2, 
			 0x2, 0x21a, 0x21c, 0x3, 0x2, 0x2, 0x2, 0x21b, 0x21d, 0x5, 0xfa, 0x7e, 
			 0x2, 0x21c, 0x21b, 0x3, 0x2, 0x2, 0x2, 0x21c, 0x21d, 0x3, 0x2, 0x2, 
			 0x2, 0x21d, 0x1f, 0x3, 0x2, 0x2, 0x2, 0x21e, 0x21f, 0x8, 0x11, 0x1, 
			 0x2, 0x21f, 0x25f, 0x5, 0x4, 0x3, 0x2, 0x220, 0x221, 0x5, 0xa0, 0x51, 
			 0x2, 0x221, 0x223, 0x7, 0x56, 0x2, 0x2, 0x222, 0x224, 0x5, 0x26, 0x14, 
			 0x2, 0x223, 0x222, 0x3, 0x2, 0x2, 0x2, 0x223, 0x224, 0x3, 0x2, 0x2, 
			 0x2, 0x224, 0x225, 0x3, 0x2, 0x2, 0x2, 0x225, 0x226, 0x7, 0x57, 0x2, 
			 0x2, 0x226, 0x25f, 0x3, 0x2, 0x2, 0x2, 0x227, 0x228, 0x5, 0x170, 0xb9, 
			 0x2, 0x228, 0x22a, 0x7, 0x56, 0x2, 0x2, 0x229, 0x22b, 0x5, 0x26, 0x14, 
			 0x2, 0x22a, 0x229, 0x3, 0x2, 0x2, 0x2, 0x22a, 0x22b, 0x3, 0x2, 0x2, 
			 0x2, 0x22b, 0x22c, 0x3, 0x2, 0x2, 0x2, 0x22c, 0x22d, 0x7, 0x57, 0x2, 
			 0x2, 0x22d, 0x25f, 0x3, 0x2, 0x2, 0x2, 0x22e, 0x22f, 0x5, 0xa0, 0x51, 
			 0x2, 0x22f, 0x230, 0x5, 0x124, 0x93, 0x2, 0x230, 0x25f, 0x3, 0x2, 0x2, 
			 0x2, 0x231, 0x232, 0x5, 0x170, 0xb9, 0x2, 0x232, 0x233, 0x5, 0x124, 
			 0x93, 0x2, 0x233, 0x25f, 0x3, 0x2, 0x2, 0x2, 0x234, 0x235, 0x7, 0x20, 
			 0x2, 0x2, 0x235, 0x236, 0x7, 0x67, 0x2, 0x2, 0x236, 0x237, 0x5, 0x106, 
			 0x84, 0x2, 0x237, 0x238, 0x7, 0x96, 0x2, 0x2, 0x238, 0x239, 0x7, 0x56, 
			 0x2, 0x2, 0x239, 0x23a, 0x5, 0x5e, 0x30, 0x2, 0x23a, 0x23b, 0x7, 0x57, 
			 0x2, 0x2, 0x23b, 0x25f, 0x3, 0x2, 0x2, 0x2, 0x23c, 0x23d, 0x7, 0x42, 
			 0x2, 0x2, 0x23d, 0x23e, 0x7, 0x67, 0x2, 0x2, 0x23e, 0x23f, 0x5, 0x106, 
			 0x84, 0x2, 0x23f, 0x240, 0x7, 0x96, 0x2, 0x2, 0x240, 0x241, 0x7, 0x56, 
			 0x2, 0x2, 0x241, 0x242, 0x5, 0x5e, 0x30, 0x2, 0x242, 0x243, 0x7, 0x57, 
			 0x2, 0x2, 0x243, 0x25f, 0x3, 0x2, 0x2, 0x2, 0x244, 0x245, 0x7, 0x3b, 
			 0x2, 0x2, 0x245, 0x246, 0x7, 0x67, 0x2, 0x2, 0x246, 0x247, 0x5, 0x106, 
			 0x84, 0x2, 0x247, 0x248, 0x7, 0x96, 0x2, 0x2, 0x248, 0x249, 0x7, 0x56, 
			 0x2, 0x2, 0x249, 0x24a, 0x5, 0x5e, 0x30, 0x2, 0x24a, 0x24b, 0x7, 0x57, 
			 0x2, 0x2, 0x24b, 0x25f, 0x3, 0x2, 0x2, 0x2, 0x24c, 0x24d, 0x7, 0x19, 
			 0x2, 0x2, 0x24d, 0x24e, 0x7, 0x67, 0x2, 0x2, 0x24e, 0x24f, 0x5, 0x106, 
			 0x84, 0x2, 0x24f, 0x250, 0x7, 0x96, 0x2, 0x2, 0x250, 0x251, 0x7, 0x56, 
			 0x2, 0x2, 0x251, 0x252, 0x5, 0x5e, 0x30, 0x2, 0x252, 0x253, 0x7, 0x57, 
			 0x2, 0x2, 0x253, 0x25f, 0x3, 0x2, 0x2, 0x2, 0x254, 0x255, 0x5, 0x24, 
			 0x13, 0x2, 0x255, 0x256, 0x7, 0x56, 0x2, 0x2, 0x256, 0x257, 0x5, 0x5e, 
			 0x30, 0x2, 0x257, 0x258, 0x7, 0x57, 0x2, 0x2, 0x258, 0x25f, 0x3, 0x2, 
			 0x2, 0x2, 0x259, 0x25a, 0x5, 0x24, 0x13, 0x2, 0x25a, 0x25b, 0x7, 0x56, 
			 0x2, 0x2, 0x25b, 0x25c, 0x5, 0x106, 0x84, 0x2, 0x25c, 0x25d, 0x7, 0x57, 
			 0x2, 0x2, 0x25d, 0x25f, 0x3, 0x2, 0x2, 0x2, 0x25e, 0x21e, 0x3, 0x2, 
			 0x2, 0x2, 0x25e, 0x220, 0x3, 0x2, 0x2, 0x2, 0x25e, 0x227, 0x3, 0x2, 
			 0x2, 0x2, 0x25e, 0x22e, 0x3, 0x2, 0x2, 0x2, 0x25e, 0x231, 0x3, 0x2, 
			 0x2, 0x2, 0x25e, 0x234, 0x3, 0x2, 0x2, 0x2, 0x25e, 0x23c, 0x3, 0x2, 
			 0x2, 0x2, 0x25e, 0x244, 0x3, 0x2, 0x2, 0x2, 0x25e, 0x24c, 0x3, 0x2, 
			 0x2, 0x2, 0x25e, 0x254, 0x3, 0x2, 0x2, 0x2, 0x25e, 0x259, 0x3, 0x2, 
			 0x2, 0x2, 0x25f, 0x288, 0x3, 0x2, 0x2, 0x2, 0x260, 0x261, 0xc, 0x15, 
			 0x2, 0x2, 0x261, 0x262, 0x7, 0x58, 0x2, 0x2, 0x262, 0x263, 0x5, 0x5e, 
			 0x30, 0x2, 0x263, 0x264, 0x7, 0x59, 0x2, 0x2, 0x264, 0x287, 0x3, 0x2, 
			 0x2, 0x2, 0x265, 0x266, 0xc, 0x14, 0x2, 0x2, 0x266, 0x267, 0x7, 0x58, 
			 0x2, 0x2, 0x267, 0x268, 0x5, 0x124, 0x93, 0x2, 0x268, 0x269, 0x7, 0x59, 
			 0x2, 0x2, 0x269, 0x287, 0x3, 0x2, 0x2, 0x2, 0x26a, 0x26b, 0xc, 0x13, 
			 0x2, 0x2, 0x26b, 0x26d, 0x7, 0x56, 0x2, 0x2, 0x26c, 0x26e, 0x5, 0x26, 
			 0x14, 0x2, 0x26d, 0x26c, 0x3, 0x2, 0x2, 0x2, 0x26d, 0x26e, 0x3, 0x2, 
			 0x2, 0x2, 0x26e, 0x26f, 0x3, 0x2, 0x2, 0x2, 0x26f, 0x287, 0x7, 0x57, 
			 0x2, 0x2, 0x270, 0x271, 0xc, 0xe, 0x2, 0x2, 0x271, 0x273, 0x7, 0x81, 
			 0x2, 0x2, 0x272, 0x274, 0x7, 0x45, 0x2, 0x2, 0x273, 0x272, 0x3, 0x2, 
			 0x2, 0x2, 0x273, 0x274, 0x3, 0x2, 0x2, 0x2, 0x274, 0x275, 0x3, 0x2, 
			 0x2, 0x2, 0x275, 0x287, 0x5, 0x6, 0x4, 0x2, 0x276, 0x277, 0xc, 0xd, 
			 0x2, 0x2, 0x277, 0x279, 0x7, 0x7c, 0x2, 0x2, 0x278, 0x27a, 0x7, 0x45, 
			 0x2, 0x2, 0x279, 0x278, 0x3, 0x2, 0x2, 0x2, 0x279, 0x27a, 0x3, 0x2, 
			 0x2, 0x2, 0x27a, 0x27b, 0x3, 0x2, 0x2, 0x2, 0x27b, 0x287, 0x5, 0x6, 
			 0x4, 0x2, 0x27c, 0x27d, 0xc, 0xc, 0x2, 0x2, 0x27d, 0x27e, 0x7, 0x81, 
			 0x2, 0x2, 0x27e, 0x287, 0x5, 0x28, 0x15, 0x2, 0x27f, 0x280, 0xc, 0xb, 
			 0x2, 0x2, 0x280, 0x281, 0x7, 0x7c, 0x2, 0x2, 0x281, 0x287, 0x5, 0x28, 
			 0x15, 0x2, 0x282, 0x283, 0xc, 0xa, 0x2, 0x2, 0x283, 0x287, 0x7, 0x78, 
			 0x2, 0x2, 0x284, 0x285, 0xc, 0x9, 0x2, 0x2, 0x285, 0x287, 0x7, 0x79, 
			 0x2, 0x2, 0x286, 0x260, 0x3, 0x2, 0x2, 0x2, 0x286, 0x265, 0x3, 0x2, 
			 0x2, 0x2, 0x286, 0x26a, 0x3, 0x2, 0x2, 0x2, 0x286, 0x270, 0x3, 0x2, 
			 0x2, 0x2, 0x286, 0x276, 0x3, 0x2, 0x2, 0x2, 0x286, 0x27c, 0x3, 0x2, 
			 0x2, 0x2, 0x286, 0x27f, 0x3, 0x2, 0x2, 0x2, 0x286, 0x282, 0x3, 0x2, 
			 0x2, 0x2, 0x286, 0x284, 0x3, 0x2, 0x2, 0x2, 0x287, 0x28a, 0x3, 0x2, 
			 0x2, 0x2, 0x288, 0x286, 0x3, 0x2, 0x2, 0x2, 0x288, 0x289, 0x3, 0x2, 
			 0x2, 0x2, 0x289, 0x21, 0x3, 0x2, 0x2, 0x2, 0x28a, 0x288, 0x3, 0x2, 0x2, 
			 0x2, 0x28b, 0x28c, 0x7, 0x4c, 0x2, 0x2, 0x28c, 0x23, 0x3, 0x2, 0x2, 
			 0x2, 0x28d, 0x28e, 0x7, 0x4c, 0x2, 0x2, 0x28e, 0x25, 0x3, 0x2, 0x2, 
			 0x2, 0x28f, 0x290, 0x5, 0x122, 0x92, 0x2, 0x290, 0x27, 0x3, 0x2, 0x2, 
			 0x2, 0x291, 0x293, 0x5, 0xc, 0x7, 0x2, 0x292, 0x291, 0x3, 0x2, 0x2, 
			 0x2, 0x292, 0x293, 0x3, 0x2, 0x2, 0x2, 0x293, 0x294, 0x3, 0x2, 0x2, 
			 0x2, 0x294, 0x295, 0x5, 0xa2, 0x52, 0x2, 0x295, 0x296, 0x7, 0x7f, 0x2, 
			 0x2, 0x296, 0x297, 0x7, 0x64, 0x2, 0x2, 0x297, 0x298, 0x5, 0xa2, 0x52, 
			 0x2, 0x298, 0x2a8, 0x3, 0x2, 0x2, 0x2, 0x299, 0x29a, 0x5, 0xc, 0x7, 
			 0x2, 0x29a, 0x29b, 0x7, 0x45, 0x2, 0x2, 0x29b, 0x29c, 0x5, 0x166, 0xb4, 
			 0x2, 0x29c, 0x29d, 0x7, 0x7f, 0x2, 0x2, 0x29d, 0x29e, 0x7, 0x64, 0x2, 
			 0x2, 0x29e, 0x29f, 0x5, 0xa2, 0x52, 0x2, 0x29f, 0x2a8, 0x3, 0x2, 0x2, 
			 0x2, 0x2a0, 0x2a2, 0x5, 0xc, 0x7, 0x2, 0x2a1, 0x2a0, 0x3, 0x2, 0x2, 
			 0x2, 0x2a1, 0x2a2, 0x3, 0x2, 0x2, 0x2, 0x2a2, 0x2a3, 0x3, 0x2, 0x2, 
			 0x2, 0x2a3, 0x2a4, 0x7, 0x64, 0x2, 0x2, 0x2a4, 0x2a8, 0x5, 0xa2, 0x52, 
			 0x2, 0x2a5, 0x2a6, 0x7, 0x64, 0x2, 0x2, 0x2a6, 0x2a8, 0x5, 0xa4, 0x53, 
			 0x2, 0x2a7, 0x292, 0x3, 0x2, 0x2, 0x2, 0x2a7, 0x299, 0x3, 0x2, 0x2, 
			 0x2, 0x2a7, 0x2a1, 0x3, 0x2, 0x2, 0x2, 0x2a7, 0x2a5, 0x3, 0x2, 0x2, 
			 0x2, 0x2a8, 0x29, 0x3, 0x2, 0x2, 0x2, 0x2a9, 0x2c6, 0x5, 0x20, 0x11, 
			 0x2, 0x2aa, 0x2ab, 0x7, 0x78, 0x2, 0x2, 0x2ab, 0x2c6, 0x5, 0x3e, 0x20, 
			 0x2, 0x2ac, 0x2ad, 0x7, 0x79, 0x2, 0x2, 0x2ad, 0x2c6, 0x5, 0x3e, 0x20, 
			 0x2, 0x2ae, 0x2af, 0x5, 0x2c, 0x17, 0x2, 0x2af, 0x2b0, 0x5, 0x3e, 0x20, 
			 0x2, 0x2b0, 0x2c6, 0x3, 0x2, 0x2, 0x2, 0x2b1, 0x2b2, 0x7, 0x3f, 0x2, 
			 0x2, 0x2b2, 0x2c6, 0x5, 0x2a, 0x16, 0x2, 0x2b3, 0x2b4, 0x7, 0x3f, 0x2, 
			 0x2, 0x2b4, 0x2b5, 0x7, 0x56, 0x2, 0x2, 0x2b5, 0x2b6, 0x5, 0x106, 0x84, 
			 0x2, 0x2b6, 0x2b7, 0x7, 0x57, 0x2, 0x2, 0x2b7, 0x2c6, 0x3, 0x2, 0x2, 
			 0x2, 0x2b8, 0x2b9, 0x7, 0x3f, 0x2, 0x2, 0x2b9, 0x2ba, 0x7, 0x83, 0x2, 
			 0x2, 0x2ba, 0x2bb, 0x7, 0x56, 0x2, 0x2, 0x2bb, 0x2bc, 0x7, 0x84, 0x2, 
			 0x2, 0x2bc, 0x2c6, 0x7, 0x57, 0x2, 0x2, 0x2bd, 0x2be, 0x7, 0xc, 0x2, 
			 0x2, 0x2be, 0x2bf, 0x7, 0x56, 0x2, 0x2, 0x2bf, 0x2c0, 0x5, 0x106, 0x84, 
			 0x2, 0x2c0, 0x2c1, 0x7, 0x57, 0x2, 0x2, 0x2c1, 0x2c6, 0x3, 0x2, 0x2, 
			 0x2, 0x2c2, 0x2c6, 0x5, 0x3c, 0x1f, 0x2, 0x2c3, 0x2c6, 0x5, 0x2e, 0x18, 
			 0x2, 0x2c4, 0x2c6, 0x5, 0x3a, 0x1e, 0x2, 0x2c5, 0x2a9, 0x3, 0x2, 0x2, 
			 0x2, 0x2c5, 0x2aa, 0x3, 0x2, 0x2, 0x2, 0x2c5, 0x2ac, 0x3, 0x2, 0x2, 
			 0x2, 0x2c5, 0x2ae, 0x3, 0x2, 0x2, 0x2, 0x2c5, 0x2b1, 0x3, 0x2, 0x2, 
			 0x2, 0x2c5, 0x2b3, 0x3, 0x2, 0x2, 0x2, 0x2c5, 0x2b8, 0x3, 0x2, 0x2, 
			 0x2, 0x2c5, 0x2bd, 0x3, 0x2, 0x2, 0x2, 0x2c5, 0x2c2, 0x3, 0x2, 0x2, 
			 0x2, 0x2c5, 0x2c3, 0x3, 0x2, 0x2, 0x2, 0x2c5, 0x2c4, 0x3, 0x2, 0x2, 
			 0x2, 0x2c6, 0x2b, 0x3, 0x2, 0x2, 0x2, 0x2c7, 0x2c8, 0x9, 0x3, 0x2, 0x2, 
			 0x2c8, 0x2d, 0x3, 0x2, 0x2, 0x2, 0x2c9, 0x2cb, 0x7, 0x7f, 0x2, 0x2, 
			 0x2ca, 0x2c9, 0x3, 0x2, 0x2, 0x2, 0x2ca, 0x2cb, 0x3, 0x2, 0x2, 0x2, 
			 0x2cb, 0x2cc, 0x3, 0x2, 0x2, 0x2, 0x2cc, 0x2ce, 0x7, 0x32, 0x2, 0x2, 
			 0x2cd, 0x2cf, 0x5, 0x30, 0x19, 0x2, 0x2ce, 0x2cd, 0x3, 0x2, 0x2, 0x2, 
			 0x2ce, 0x2cf, 0x3, 0x2, 0x2, 0x2, 0x2cf, 0x2d0, 0x3, 0x2, 0x2, 0x2, 
			 0x2d0, 0x2d2, 0x5, 0x32, 0x1a, 0x2, 0x2d1, 0x2d3, 0x5, 0x38, 0x1d, 0x2, 
			 0x2d2, 0x2d1, 0x3, 0x2, 0x2, 0x2, 0x2d2, 0x2d3, 0x3, 0x2, 0x2, 0x2, 
			 0x2d3, 0x2e2, 0x3, 0x2, 0x2, 0x2, 0x2d4, 0x2d6, 0x7, 0x7f, 0x2, 0x2, 
			 0x2d5, 0x2d4, 0x3, 0x2, 0x2, 0x2, 0x2d5, 0x2d6, 0x3, 0x2, 0x2, 0x2, 
			 0x2d6, 0x2d7, 0x3, 0x2, 0x2, 0x2, 0x2d7, 0x2d9, 0x7, 0x32, 0x2, 0x2, 
			 0x2d8, 0x2da, 0x5, 0x30, 0x19, 0x2, 0x2d9, 0x2d8, 0x3, 0x2, 0x2, 0x2, 
			 0x2d9, 0x2da, 0x3, 0x2, 0x2, 0x2, 0x2da, 0x2db, 0x3, 0x2, 0x2, 0x2, 
			 0x2db, 0x2dc, 0x7, 0x56, 0x2, 0x2, 0x2dc, 0x2dd, 0x5, 0x106, 0x84, 0x2, 
			 0x2dd, 0x2df, 0x7, 0x57, 0x2, 0x2, 0x2de, 0x2e0, 0x5, 0x38, 0x1d, 0x2, 
			 0x2df, 0x2de, 0x3, 0x2, 0x2, 0x2, 0x2df, 0x2e0, 0x3, 0x2, 0x2, 0x2, 
			 0x2e0, 0x2e2, 0x3, 0x2, 0x2, 0x2, 0x2e1, 0x2ca, 0x3, 0x2, 0x2, 0x2, 
			 0x2e1, 0x2d5, 0x3, 0x2, 0x2, 0x2, 0x2e2, 0x2f, 0x3, 0x2, 0x2, 0x2, 0x2e3, 
			 0x2e4, 0x7, 0x56, 0x2, 0x2, 0x2e4, 0x2e5, 0x5, 0x26, 0x14, 0x2, 0x2e5, 
			 0x2e6, 0x7, 0x57, 0x2, 0x2, 0x2e6, 0x31, 0x3, 0x2, 0x2, 0x2, 0x2e7, 
			 0x2e9, 0x5, 0x9c, 0x4f, 0x2, 0x2e8, 0x2ea, 0x5, 0x34, 0x1b, 0x2, 0x2e9, 
			 0x2e8, 0x3, 0x2, 0x2, 0x2, 0x2e9, 0x2ea, 0x3, 0x2, 0x2, 0x2, 0x2ea, 
			 0x33, 0x3, 0x2, 0x2, 0x2, 0x2eb, 0x2ed, 0x5, 0xfc, 0x7f, 0x2, 0x2ec, 
			 0x2ee, 0x5, 0x34, 0x1b, 0x2, 0x2ed, 0x2ec, 0x3, 0x2, 0x2, 0x2, 0x2ed, 
			 0x2ee, 0x3, 0x2, 0x2, 0x2, 0x2ee, 0x2f2, 0x3, 0x2, 0x2, 0x2, 0x2ef, 
			 0x2f2, 0x5, 0x36, 0x1c, 0x2, 0x2f0, 0x2f2, 0x5, 0x108, 0x85, 0x2, 0x2f1, 
			 0x2eb, 0x3, 0x2, 0x2, 0x2, 0x2f1, 0x2ef, 0x3, 0x2, 0x2, 0x2, 0x2f1, 
			 0x2f0, 0x3, 0x2, 0x2, 0x2, 0x2f2, 0x35, 0x3, 0x2, 0x2, 0x2, 0x2f3, 0x2f4, 
			 0x8, 0x1c, 0x1, 0x2, 0x2f4, 0x2f5, 0x7, 0x58, 0x2, 0x2, 0x2f5, 0x2f6, 
			 0x5, 0x5e, 0x30, 0x2, 0x2f6, 0x2f8, 0x7, 0x59, 0x2, 0x2, 0x2f7, 0x2f9, 
			 0x5, 0xd8, 0x6d, 0x2, 0x2f8, 0x2f7, 0x3, 0x2, 0x2, 0x2, 0x2f8, 0x2f9, 
			 0x3, 0x2, 0x2, 0x2, 0x2f9, 0x303, 0x3, 0x2, 0x2, 0x2, 0x2fa, 0x2fb, 
			 0xc, 0x3, 0x2, 0x2, 0x2fb, 0x2fc, 0x7, 0x58, 0x2, 0x2, 0x2fc, 0x2fd, 
			 0x5, 0x60, 0x31, 0x2, 0x2fd, 0x2ff, 0x7, 0x59, 0x2, 0x2, 0x2fe, 0x300, 
			 0x5, 0xd8, 0x6d, 0x2, 0x2ff, 0x2fe, 0x3, 0x2, 0x2, 0x2, 0x2ff, 0x300, 
			 0x3, 0x2, 0x2, 0x2, 0x300, 0x302, 0x3, 0x2, 0x2, 0x2, 0x301, 0x2fa, 
			 0x3, 0x2, 0x2, 0x2, 0x302, 0x305, 0x3, 0x2, 0x2, 0x2, 0x303, 0x301, 
			 0x3, 0x2, 0x2, 0x2, 0x303, 0x304, 0x3, 0x2, 0x2, 0x2, 0x304, 0x37, 0x3, 
			 0x2, 0x2, 0x2, 0x305, 0x303, 0x3, 0x2, 0x2, 0x2, 0x306, 0x308, 0x7, 
			 0x56, 0x2, 0x2, 0x307, 0x309, 0x5, 0x26, 0x14, 0x2, 0x308, 0x307, 0x3, 
			 0x2, 0x2, 0x2, 0x308, 0x309, 0x3, 0x2, 0x2, 0x2, 0x309, 0x30a, 0x3, 
			 0x2, 0x2, 0x2, 0x30a, 0x30d, 0x7, 0x57, 0x2, 0x2, 0x30b, 0x30d, 0x5, 
			 0x124, 0x93, 0x2, 0x30c, 0x306, 0x3, 0x2, 0x2, 0x2, 0x30c, 0x30b, 0x3, 
			 0x2, 0x2, 0x2, 0x30d, 0x39, 0x3, 0x2, 0x2, 0x2, 0x30e, 0x310, 0x7, 0x7f, 
			 0x2, 0x2, 0x30f, 0x30e, 0x3, 0x2, 0x2, 0x2, 0x30f, 0x310, 0x3, 0x2, 
			 0x2, 0x2, 0x310, 0x311, 0x3, 0x2, 0x2, 0x2, 0x311, 0x312, 0x7, 0x1d, 
			 0x2, 0x2, 0x312, 0x31b, 0x5, 0x3e, 0x20, 0x2, 0x313, 0x315, 0x7, 0x7f, 
			 0x2, 0x2, 0x314, 0x313, 0x3, 0x2, 0x2, 0x2, 0x314, 0x315, 0x3, 0x2, 
			 0x2, 0x2, 0x315, 0x316, 0x3, 0x2, 0x2, 0x2, 0x316, 0x317, 0x7, 0x1d, 
			 0x2, 0x2, 0x317, 0x318, 0x7, 0x58, 0x2, 0x2, 0x318, 0x319, 0x7, 0x59, 
			 0x2, 0x2, 0x319, 0x31b, 0x5, 0x3e, 0x20, 0x2, 0x31a, 0x30f, 0x3, 0x2, 
			 0x2, 0x2, 0x31a, 0x314, 0x3, 0x2, 0x2, 0x2, 0x31b, 0x3b, 0x3, 0x2, 0x2, 
			 0x2, 0x31c, 0x31d, 0x7, 0x33, 0x2, 0x2, 0x31d, 0x31e, 0x7, 0x56, 0x2, 
			 0x2, 0x31e, 0x31f, 0x5, 0x5e, 0x30, 0x2, 0x31f, 0x320, 0x7, 0x57, 0x2, 
			 0x2, 0x320, 0x3d, 0x3, 0x2, 0x2, 0x2, 0x321, 0x328, 0x5, 0x2a, 0x16, 
			 0x2, 0x322, 0x323, 0x7, 0x56, 0x2, 0x2, 0x323, 0x324, 0x5, 0x106, 0x84, 
			 0x2, 0x324, 0x325, 0x7, 0x57, 0x2, 0x2, 0x325, 0x326, 0x5, 0x3e, 0x20, 
			 0x2, 0x326, 0x328, 0x3, 0x2, 0x2, 0x2, 0x327, 0x321, 0x3, 0x2, 0x2, 
			 0x2, 0x327, 0x322, 0x3, 0x2, 0x2, 0x2, 0x328, 0x3f, 0x3, 0x2, 0x2, 0x2, 
			 0x329, 0x32a, 0x8, 0x21, 0x1, 0x2, 0x32a, 0x32b, 0x5, 0x3e, 0x20, 0x2, 
			 0x32b, 0x334, 0x3, 0x2, 0x2, 0x2, 0x32c, 0x32d, 0xc, 0x4, 0x2, 0x2, 
			 0x32d, 0x32e, 0x7, 0x82, 0x2, 0x2, 0x32e, 0x333, 0x5, 0x3e, 0x20, 0x2, 
			 0x32f, 0x330, 0xc, 0x3, 0x2, 0x2, 0x330, 0x331, 0x7, 0x7b, 0x2, 0x2, 
			 0x331, 0x333, 0x5, 0x3e, 0x20, 0x2, 0x332, 0x32c, 0x3, 0x2, 0x2, 0x2, 
			 0x332, 0x32f, 0x3, 0x2, 0x2, 0x2, 0x333, 0x336, 0x3, 0x2, 0x2, 0x2, 
			 0x334, 0x332, 0x3, 0x2, 0x2, 0x2, 0x334, 0x335, 0x3, 0x2, 0x2, 0x2, 
			 0x335, 0x41, 0x3, 0x2, 0x2, 0x2, 0x336, 0x334, 0x3, 0x2, 0x2, 0x2, 0x337, 
			 0x338, 0x8, 0x22, 0x1, 0x2, 0x338, 0x339, 0x5, 0x40, 0x21, 0x2, 0x339, 
			 0x345, 0x3, 0x2, 0x2, 0x2, 0x33a, 0x33b, 0xc, 0x5, 0x2, 0x2, 0x33b, 
			 0x33c, 0x7, 0x5e, 0x2, 0x2, 0x33c, 0x344, 0x5, 0x40, 0x21, 0x2, 0x33d, 
			 0x33e, 0xc, 0x4, 0x2, 0x2, 0x33e, 0x33f, 0x7, 0x5f, 0x2, 0x2, 0x33f, 
			 0x344, 0x5, 0x40, 0x21, 0x2, 0x340, 0x341, 0xc, 0x3, 0x2, 0x2, 0x341, 
			 0x342, 0x7, 0x60, 0x2, 0x2, 0x342, 0x344, 0x5, 0x40, 0x21, 0x2, 0x343, 
			 0x33a, 0x3, 0x2, 0x2, 0x2, 0x343, 0x33d, 0x3, 0x2, 0x2, 0x2, 0x343, 
			 0x340, 0x3, 0x2, 0x2, 0x2, 0x344, 0x347, 0x3, 0x2, 0x2, 0x2, 0x345, 
			 0x343, 0x3, 0x2, 0x2, 0x2, 0x345, 0x346, 0x3, 0x2, 0x2, 0x2, 0x346, 
			 0x43, 0x3, 0x2, 0x2, 0x2, 0x347, 0x345, 0x3, 0x2, 0x2, 0x2, 0x348, 0x349, 
			 0x8, 0x23, 0x1, 0x2, 0x349, 0x34a, 0x5, 0x42, 0x22, 0x2, 0x34a, 0x353, 
			 0x3, 0x2, 0x2, 0x2, 0x34b, 0x34c, 0xc, 0x4, 0x2, 0x2, 0x34c, 0x34d, 
			 0x7, 0x5c, 0x2, 0x2, 0x34d, 0x352, 0x5, 0x42, 0x22, 0x2, 0x34e, 0x34f, 
			 0xc, 0x3, 0x2, 0x2, 0x34f, 0x350, 0x7, 0x5d, 0x2, 0x2, 0x350, 0x352, 
			 0x5, 0x42, 0x22, 0x2, 0x351, 0x34b, 0x3, 0x2, 0x2, 0x2, 0x351, 0x34e, 
			 0x3, 0x2, 0x2, 0x2, 0x352, 0x355, 0x3, 0x2, 0x2, 0x2, 0x353, 0x351, 
			 0x3, 0x2, 0x2, 0x2, 0x353, 0x354, 0x3, 0x2, 0x2, 0x2, 0x354, 0x45, 0x3, 
			 0x2, 0x2, 0x2, 0x355, 0x353, 0x3, 0x2, 0x2, 0x2, 0x356, 0x357, 0x8, 
			 0x24, 0x1, 0x2, 0x357, 0x358, 0x5, 0x44, 0x23, 0x2, 0x358, 0x35f, 0x3, 
			 0x2, 0x2, 0x2, 0x359, 0x35a, 0xc, 0x3, 0x2, 0x2, 0x35a, 0x35b, 0x5, 
			 0x48, 0x25, 0x2, 0x35b, 0x35c, 0x5, 0x44, 0x23, 0x2, 0x35c, 0x35e, 0x3, 
			 0x2, 0x2, 0x2, 0x35d, 0x359, 0x3, 0x2, 0x2, 0x2, 0x35e, 0x361, 0x3, 
			 0x2, 0x2, 0x2, 0x35f, 0x35d, 0x3, 0x2, 0x2, 0x2, 0x35f, 0x360, 0x3, 
			 0x2, 0x2, 0x2, 0x360, 0x47, 0x3, 0x2, 0x2, 0x2, 0x361, 0x35f, 0x3, 0x2, 
			 0x2, 0x2, 0x362, 0x365, 0x5, 0x18a, 0xc6, 0x2, 0x363, 0x365, 0x7, 0x70, 
			 0x2, 0x2, 0x364, 0x362, 0x3, 0x2, 0x2, 0x2, 0x364, 0x363, 0x3, 0x2, 
			 0x2, 0x2, 0x365, 0x49, 0x3, 0x2, 0x2, 0x2, 0x366, 0x367, 0x8, 0x26, 
			 0x1, 0x2, 0x367, 0x368, 0x5, 0x46, 0x24, 0x2, 0x368, 0x377, 0x3, 0x2, 
			 0x2, 0x2, 0x369, 0x36a, 0xc, 0x6, 0x2, 0x2, 0x36a, 0x36b, 0x7, 0x67, 
			 0x2, 0x2, 0x36b, 0x376, 0x5, 0x46, 0x24, 0x2, 0x36c, 0x36d, 0xc, 0x5, 
			 0x2, 0x2, 0x36d, 0x36e, 0x7, 0x96, 0x2, 0x2, 0x36e, 0x376, 0x5, 0x46, 
			 0x24, 0x2, 0x36f, 0x370, 0xc, 0x4, 0x2, 0x2, 0x370, 0x371, 0x7, 0x74, 
			 0x2, 0x2, 0x371, 0x376, 0x5, 0x46, 0x24, 0x2, 0x372, 0x373, 0xc, 0x3, 
			 0x2, 0x2, 0x373, 0x374, 0x7, 0x75, 0x2, 0x2, 0x374, 0x376, 0x5, 0x46, 
			 0x24, 0x2, 0x375, 0x369, 0x3, 0x2, 0x2, 0x2, 0x375, 0x36c, 0x3, 0x2, 
			 0x2, 0x2, 0x375, 0x36f, 0x3, 0x2, 0x2, 0x2, 0x375, 0x372, 0x3, 0x2, 
			 0x2, 0x2, 0x376, 0x379, 0x3, 0x2, 0x2, 0x2, 0x377, 0x375, 0x3, 0x2, 
			 0x2, 0x2, 0x377, 0x378, 0x3, 0x2, 0x2, 0x2, 0x378, 0x4b, 0x3, 0x2, 0x2, 
			 0x2, 0x379, 0x377, 0x3, 0x2, 0x2, 0x2, 0x37a, 0x37b, 0x8, 0x27, 0x1, 
			 0x2, 0x37b, 0x37c, 0x5, 0x4a, 0x26, 0x2, 0x37c, 0x385, 0x3, 0x2, 0x2, 
			 0x2, 0x37d, 0x37e, 0xc, 0x4, 0x2, 0x2, 0x37e, 0x37f, 0x7, 0x72, 0x2, 
			 0x2, 0x37f, 0x384, 0x5, 0x4a, 0x26, 0x2, 0x380, 0x381, 0xc, 0x3, 0x2, 
			 0x2, 0x381, 0x382, 0x7, 0x73, 0x2, 0x2, 0x382, 0x384, 0x5, 0x4a, 0x26, 
			 0x2, 0x383, 0x37d, 0x3, 0x2, 0x2, 0x2, 0x383, 0x380, 0x3, 0x2, 0x2, 
			 0x2, 0x384, 0x387, 0x3, 0x2, 0x2, 0x2, 0x385, 0x383, 0x3, 0x2, 0x2, 
			 0x2, 0x385, 0x386, 0x3, 0x2, 0x2, 0x2, 0x386, 0x4d, 0x3, 0x2, 0x2, 0x2, 
			 0x387, 0x385, 0x3, 0x2, 0x2, 0x2, 0x388, 0x389, 0x8, 0x28, 0x1, 0x2, 
			 0x389, 0x38a, 0x5, 0x4c, 0x27, 0x2, 0x38a, 0x390, 0x3, 0x2, 0x2, 0x2, 
			 0x38b, 0x38c, 0xc, 0x3, 0x2, 0x2, 0x38c, 0x38d, 0x7, 0x62, 0x2, 0x2, 
			 0x38d, 0x38f, 0x5, 0x4c, 0x27, 0x2, 0x38e, 0x38b, 0x3, 0x2, 0x2, 0x2, 
			 0x38f, 0x392, 0x3, 0x2, 0x2, 0x2, 0x390, 0x38e, 0x3, 0x2, 0x2, 0x2, 
			 0x390, 0x391, 0x3, 0x2, 0x2, 0x2, 0x391, 0x4f, 0x3, 0x2, 0x2, 0x2, 0x392, 
			 0x390, 0x3, 0x2, 0x2, 0x2, 0x393, 0x394, 0x8, 0x29, 0x1, 0x2, 0x394, 
			 0x395, 0x5, 0x4e, 0x28, 0x2, 0x395, 0x39b, 0x3, 0x2, 0x2, 0x2, 0x396, 
			 0x397, 0xc, 0x3, 0x2, 0x2, 0x397, 0x398, 0x7, 0x61, 0x2, 0x2, 0x398, 
			 0x39a, 0x5, 0x4e, 0x28, 0x2, 0x399, 0x396, 0x3, 0x2, 0x2, 0x2, 0x39a, 
			 0x39d, 0x3, 0x2, 0x2, 0x2, 0x39b, 0x399, 0x3, 0x2, 0x2, 0x2, 0x39b, 
			 0x39c, 0x3, 0x2, 0x2, 0x2, 0x39c, 0x51, 0x3, 0x2, 0x2, 0x2, 0x39d, 0x39b, 
			 0x3, 0x2, 0x2, 0x2, 0x39e, 0x39f, 0x8, 0x2a, 0x1, 0x2, 0x39f, 0x3a0, 
			 0x5, 0x50, 0x29, 0x2, 0x3a0, 0x3a6, 0x3, 0x2, 0x2, 0x2, 0x3a1, 0x3a2, 
			 0xc, 0x3, 0x2, 0x2, 0x3a2, 0x3a3, 0x7, 0x63, 0x2, 0x2, 0x3a3, 0x3a5, 
			 0x5, 0x50, 0x29, 0x2, 0x3a4, 0x3a1, 0x3, 0x2, 0x2, 0x2, 0x3a5, 0x3a8, 
			 0x3, 0x2, 0x2, 0x2, 0x3a6, 0x3a4, 0x3, 0x2, 0x2, 0x2, 0x3a6, 0x3a7, 
			 0x3, 0x2, 0x2, 0x2, 0x3a7, 0x53, 0x3, 0x2, 0x2, 0x2, 0x3a8, 0x3a6, 0x3, 
			 0x2, 0x2, 0x2, 0x3a9, 0x3aa, 0x8, 0x2b, 0x1, 0x2, 0x3aa, 0x3ab, 0x5, 
			 0x52, 0x2a, 0x2, 0x3ab, 0x3b4, 0x3, 0x2, 0x2, 0x2, 0x3ac, 0x3ad, 0xc, 
			 0x4, 0x2, 0x2, 0x3ad, 0x3ae, 0x7, 0x5, 0x2, 0x2, 0x3ae, 0x3b3, 0x5, 
			 0x52, 0x2a, 0x2, 0x3af, 0x3b0, 0xc, 0x3, 0x2, 0x2, 0x3b0, 0x3b1, 0x7, 
			 0x6, 0x2, 0x2, 0x3b1, 0x3b3, 0x5, 0x52, 0x2a, 0x2, 0x3b2, 0x3ac, 0x3, 
			 0x2, 0x2, 0x2, 0x3b2, 0x3af, 0x3, 0x2, 0x2, 0x2, 0x3b3, 0x3b6, 0x3, 
			 0x2, 0x2, 0x2, 0x3b4, 0x3b2, 0x3, 0x2, 0x2, 0x2, 0x3b4, 0x3b5, 0x3, 
			 0x2, 0x2, 0x2, 0x3b5, 0x55, 0x3, 0x2, 0x2, 0x2, 0x3b6, 0x3b4, 0x3, 0x2, 
			 0x2, 0x2, 0x3b7, 0x3b8, 0x8, 0x2c, 0x1, 0x2, 0x3b8, 0x3b9, 0x5, 0x54, 
			 0x2b, 0x2, 0x3b9, 0x3c2, 0x3, 0x2, 0x2, 0x2, 0x3ba, 0x3bb, 0xc, 0x4, 
			 0x2, 0x2, 0x3bb, 0x3bc, 0x7, 0x7, 0x2, 0x2, 0x3bc, 0x3c1, 0x5, 0x54, 
			 0x2b, 0x2, 0x3bd, 0x3be, 0xc, 0x3, 0x2, 0x2, 0x3be, 0x3bf, 0x7, 0x8, 
			 0x2, 0x2, 0x3bf, 0x3c1, 0x5, 0x54, 0x2b, 0x2, 0x3c0, 0x3ba, 0x3, 0x2, 
			 0x2, 0x2, 0x3c0, 0x3bd, 0x3, 0x2, 0x2, 0x2, 0x3c1, 0x3c4, 0x3, 0x2, 
			 0x2, 0x2, 0x3c2, 0x3c0, 0x3, 0x2, 0x2, 0x2, 0x3c2, 0x3c3, 0x3, 0x2, 
			 0x2, 0x2, 0x3c3, 0x57, 0x3, 0x2, 0x2, 0x2, 0x3c4, 0x3c2, 0x3, 0x2, 0x2, 
			 0x2, 0x3c5, 0x3cd, 0x5, 0x56, 0x2c, 0x2, 0x3c6, 0x3c7, 0x5, 0x56, 0x2c, 
			 0x2, 0x3c7, 0x3c8, 0x7, 0x7d, 0x2, 0x2, 0x3c8, 0x3c9, 0x5, 0x5e, 0x30, 
			 0x2, 0x3c9, 0x3ca, 0x7, 0x7e, 0x2, 0x2, 0x3ca, 0x3cb, 0x5, 0x5a, 0x2e, 
			 0x2, 0x3cb, 0x3cd, 0x3, 0x2, 0x2, 0x2, 0x3cc, 0x3c5, 0x3, 0x2, 0x2, 
			 0x2, 0x3cc, 0x3c6, 0x3, 0x2, 0x2, 0x2, 0x3cd, 0x59, 0x3, 0x2, 0x2, 0x2, 
			 0x3ce, 0x3d5, 0x5, 0x58, 0x2d, 0x2, 0x3cf, 0x3d0, 0x5, 0x56, 0x2c, 0x2, 
			 0x3d0, 0x3d1, 0x5, 0x5c, 0x2f, 0x2, 0x3d1, 0x3d2, 0x5, 0x120, 0x91, 
			 0x2, 0x3d2, 0x3d5, 0x3, 0x2, 0x2, 0x2, 0x3d3, 0x3d5, 0x5, 0x180, 0xc1, 
			 0x2, 0x3d4, 0x3ce, 0x3, 0x2, 0x2, 0x2, 0x3d4, 0x3cf, 0x3, 0x2, 0x2, 
			 0x2, 0x3d4, 0x3d3, 0x3, 0x2, 0x2, 0x2, 0x3d5, 0x5b, 0x3, 0x2, 0x2, 0x2, 
			 0x3d6, 0x3e2, 0x7, 0x66, 0x2, 0x2, 0x3d7, 0x3e2, 0x7, 0x6a, 0x2, 0x2, 
			 0x3d8, 0x3e2, 0x7, 0x6b, 0x2, 0x2, 0x3d9, 0x3e2, 0x7, 0x6c, 0x2, 0x2, 
			 0x3da, 0x3e2, 0x7, 0x68, 0x2, 0x2, 0x3db, 0x3e2, 0x7, 0x69, 0x2, 0x2, 
			 0x3dc, 0x3e2, 0x5, 0x18c, 0xc7, 0x2, 0x3dd, 0x3e2, 0x7, 0x71, 0x2, 0x2, 
			 0x3de, 0x3e2, 0x7, 0x6e, 0x2, 0x2, 0x3df, 0x3e2, 0x7, 0x6d, 0x2, 0x2, 
			 0x3e0, 0x3e2, 0x7, 0x6f, 0x2, 0x2, 0x3e1, 0x3d6, 0x3, 0x2, 0x2, 0x2, 
			 0x3e1, 0x3d7, 0x3, 0x2, 0x2, 0x2, 0x3e1, 0x3d8, 0x3, 0x2, 0x2, 0x2, 
			 0x3e1, 0x3d9, 0x3, 0x2, 0x2, 0x2, 0x3e1, 0x3da, 0x3, 0x2, 0x2, 0x2, 
			 0x3e1, 0x3db, 0x3, 0x2, 0x2, 0x2, 0x3e1, 0x3dc, 0x3, 0x2, 0x2, 0x2, 
			 0x3e1, 0x3dd, 0x3, 0x2, 0x2, 0x2, 0x3e1, 0x3de, 0x3, 0x2, 0x2, 0x2, 
			 0x3e1, 0x3df, 0x3, 0x2, 0x2, 0x2, 0x3e1, 0x3e0, 0x3, 0x2, 0x2, 0x2, 
			 0x3e2, 0x5d, 0x3, 0x2, 0x2, 0x2, 0x3e3, 0x3e4, 0x8, 0x30, 0x1, 0x2, 
			 0x3e4, 0x3e5, 0x5, 0x5a, 0x2e, 0x2, 0x3e5, 0x3eb, 0x3, 0x2, 0x2, 0x2, 
			 0x3e6, 0x3e7, 0xc, 0x3, 0x2, 0x2, 0x3e7, 0x3e8, 0x7, 0x7a, 0x2, 0x2, 
			 0x3e8, 0x3ea, 0x5, 0x5a, 0x2e, 0x2, 0x3e9, 0x3e6, 0x3, 0x2, 0x2, 0x2, 
			 0x3ea, 0x3ed, 0x3, 0x2, 0x2, 0x2, 0x3eb, 0x3e9, 0x3, 0x2, 0x2, 0x2, 
			 0x3eb, 0x3ec, 0x3, 0x2, 0x2, 0x2, 0x3ec, 0x5f, 0x3, 0x2, 0x2, 0x2, 0x3ed, 
			 0x3eb, 0x3, 0x2, 0x2, 0x2, 0x3ee, 0x3ef, 0x5, 0x58, 0x2d, 0x2, 0x3ef, 
			 0x61, 0x3, 0x2, 0x2, 0x2, 0x3f0, 0x40b, 0x5, 0x64, 0x33, 0x2, 0x3f1, 
			 0x3f3, 0x5, 0xd8, 0x6d, 0x2, 0x3f2, 0x3f1, 0x3, 0x2, 0x2, 0x2, 0x3f2, 
			 0x3f3, 0x3, 0x2, 0x2, 0x2, 0x3f3, 0x3f4, 0x3, 0x2, 0x2, 0x2, 0x3f4, 
			 0x40b, 0x5, 0x66, 0x34, 0x2, 0x3f5, 0x3f7, 0x5, 0xd8, 0x6d, 0x2, 0x3f6, 
			 0x3f5, 0x3, 0x2, 0x2, 0x2, 0x3f6, 0x3f7, 0x3, 0x2, 0x2, 0x2, 0x3f7, 
			 0x3f8, 0x3, 0x2, 0x2, 0x2, 0x3f8, 0x40b, 0x5, 0x68, 0x35, 0x2, 0x3f9, 
			 0x3fb, 0x5, 0xd8, 0x6d, 0x2, 0x3fa, 0x3f9, 0x3, 0x2, 0x2, 0x2, 0x3fa, 
			 0x3fb, 0x3, 0x2, 0x2, 0x2, 0x3fb, 0x3fc, 0x3, 0x2, 0x2, 0x2, 0x3fc, 
			 0x40b, 0x5, 0x6c, 0x37, 0x2, 0x3fd, 0x3ff, 0x5, 0xd8, 0x6d, 0x2, 0x3fe, 
			 0x3fd, 0x3, 0x2, 0x2, 0x2, 0x3fe, 0x3ff, 0x3, 0x2, 0x2, 0x2, 0x3ff, 
			 0x400, 0x3, 0x2, 0x2, 0x2, 0x400, 0x40b, 0x5, 0x70, 0x39, 0x2, 0x401, 
			 0x403, 0x5, 0xd8, 0x6d, 0x2, 0x402, 0x401, 0x3, 0x2, 0x2, 0x2, 0x402, 
			 0x403, 0x3, 0x2, 0x2, 0x2, 0x403, 0x404, 0x3, 0x2, 0x2, 0x2, 0x404, 
			 0x40b, 0x5, 0x78, 0x3d, 0x2, 0x405, 0x40b, 0x5, 0x7a, 0x3e, 0x2, 0x406, 
			 0x408, 0x5, 0xd8, 0x6d, 0x2, 0x407, 0x406, 0x3, 0x2, 0x2, 0x2, 0x407, 
			 0x408, 0x3, 0x2, 0x2, 0x2, 0x408, 0x409, 0x3, 0x2, 0x2, 0x2, 0x409, 
			 0x40b, 0x5, 0x176, 0xbc, 0x2, 0x40a, 0x3f0, 0x3, 0x2, 0x2, 0x2, 0x40a, 
			 0x3f2, 0x3, 0x2, 0x2, 0x2, 0x40a, 0x3f6, 0x3, 0x2, 0x2, 0x2, 0x40a, 
			 0x3fa, 0x3, 0x2, 0x2, 0x2, 0x40a, 0x3fe, 0x3, 0x2, 0x2, 0x2, 0x40a, 
			 0x402, 0x3, 0x2, 0x2, 0x2, 0x40a, 0x405, 0x3, 0x2, 0x2, 0x2, 0x40a, 
			 0x407, 0x3, 0x2, 0x2, 0x2, 0x40b, 0x63, 0x3, 0x2, 0x2, 0x2, 0x40c, 0x40e, 
			 0x5, 0xd8, 0x6d, 0x2, 0x40d, 0x40c, 0x3, 0x2, 0x2, 0x2, 0x40d, 0x40e, 
			 0x3, 0x2, 0x2, 0x2, 0x40e, 0x40f, 0x3, 0x2, 0x2, 0x2, 0x40f, 0x410, 
			 0x7, 0x84, 0x2, 0x2, 0x410, 0x411, 0x7, 0x7e, 0x2, 0x2, 0x411, 0x421, 
			 0x5, 0x62, 0x32, 0x2, 0x412, 0x414, 0x5, 0xd8, 0x6d, 0x2, 0x413, 0x412, 
			 0x3, 0x2, 0x2, 0x2, 0x413, 0x414, 0x3, 0x2, 0x2, 0x2, 0x414, 0x415, 
			 0x3, 0x2, 0x2, 0x2, 0x415, 0x416, 0x7, 0x11, 0x2, 0x2, 0x416, 0x417, 
			 0x5, 0x60, 0x31, 0x2, 0x417, 0x418, 0x7, 0x7e, 0x2, 0x2, 0x418, 0x419, 
			 0x5, 0x62, 0x32, 0x2, 0x419, 0x421, 0x3, 0x2, 0x2, 0x2, 0x41a, 0x41c, 
			 0x5, 0xd8, 0x6d, 0x2, 0x41b, 0x41a, 0x3, 0x2, 0x2, 0x2, 0x41b, 0x41c, 
			 0x3, 0x2, 0x2, 0x2, 0x41c, 0x41d, 0x3, 0x2, 0x2, 0x2, 0x41d, 0x41e, 
			 0x7, 0x1c, 0x2, 0x2, 0x41e, 0x41f, 0x7, 0x7e, 0x2, 0x2, 0x41f, 0x421, 
			 0x5, 0x62, 0x32, 0x2, 0x420, 0x40d, 0x3, 0x2, 0x2, 0x2, 0x420, 0x413, 
			 0x3, 0x2, 0x2, 0x2, 0x420, 0x41b, 0x3, 0x2, 0x2, 0x2, 0x421, 0x65, 0x3, 
			 0x2, 0x2, 0x2, 0x422, 0x424, 0x5, 0x5e, 0x30, 0x2, 0x423, 0x422, 0x3, 
			 0x2, 0x2, 0x2, 0x423, 0x424, 0x3, 0x2, 0x2, 0x2, 0x424, 0x425, 0x3, 
			 0x2, 0x2, 0x2, 0x425, 0x426, 0x7, 0x80, 0x2, 0x2, 0x426, 0x67, 0x3, 
			 0x2, 0x2, 0x2, 0x427, 0x429, 0x7, 0x5a, 0x2, 0x2, 0x428, 0x42a, 0x5, 
			 0x6a, 0x36, 0x2, 0x429, 0x428, 0x3, 0x2, 0x2, 0x2, 0x429, 0x42a, 0x3, 
			 0x2, 0x2, 0x2, 0x42a, 0x42b, 0x3, 0x2, 0x2, 0x2, 0x42b, 0x42c, 0x7, 
			 0x5b, 0x2, 0x2, 0x42c, 0x69, 0x3, 0x2, 0x2, 0x2, 0x42d, 0x42e, 0x8, 
			 0x36, 0x1, 0x2, 0x42e, 0x42f, 0x5, 0x62, 0x32, 0x2, 0x42f, 0x434, 0x3, 
			 0x2, 0x2, 0x2, 0x430, 0x431, 0xc, 0x3, 0x2, 0x2, 0x431, 0x433, 0x5, 
			 0x62, 0x32, 0x2, 0x432, 0x430, 0x3, 0x2, 0x2, 0x2, 0x433, 0x436, 0x3, 
			 0x2, 0x2, 0x2, 0x434, 0x432, 0x3, 0x2, 0x2, 0x2, 0x434, 0x435, 0x3, 
			 0x2, 0x2, 0x2, 0x435, 0x6b, 0x3, 0x2, 0x2, 0x2, 0x436, 0x434, 0x3, 0x2, 
			 0x2, 0x2, 0x437, 0x438, 0x7, 0x2c, 0x2, 0x2, 0x438, 0x439, 0x7, 0x56, 
			 0x2, 0x2, 0x439, 0x43a, 0x5, 0x6e, 0x38, 0x2, 0x43a, 0x43b, 0x7, 0x57, 
			 0x2, 0x2, 0x43b, 0x43c, 0x5, 0x62, 0x32, 0x2, 0x43c, 0x44c, 0x3, 0x2, 
			 0x2, 0x2, 0x43d, 0x43e, 0x7, 0x2c, 0x2, 0x2, 0x43e, 0x43f, 0x7, 0x56, 
			 0x2, 0x2, 0x43f, 0x440, 0x5, 0x6e, 0x38, 0x2, 0x440, 0x441, 0x7, 0x57, 
			 0x2, 0x2, 0x441, 0x442, 0x5, 0x62, 0x32, 0x2, 0x442, 0x443, 0x7, 0x21, 
			 0x2, 0x2, 0x443, 0x444, 0x5, 0x62, 0x32, 0x2, 0x444, 0x44c, 0x3, 0x2, 
			 0x2, 0x2, 0x445, 0x446, 0x7, 0x44, 0x2, 0x2, 0x446, 0x447, 0x7, 0x56, 
			 0x2, 0x2, 0x447, 0x448, 0x5, 0x6e, 0x38, 0x2, 0x448, 0x449, 0x7, 0x57, 
			 0x2, 0x2, 0x449, 0x44a, 0x5, 0x62, 0x32, 0x2, 0x44a, 0x44c, 0x3, 0x2, 
			 0x2, 0x2, 0x44b, 0x437, 0x3, 0x2, 0x2, 0x2, 0x44b, 0x43d, 0x3, 0x2, 
			 0x2, 0x2, 0x44b, 0x445, 0x3, 0x2, 0x2, 0x2, 0x44c, 0x6d, 0x3, 0x2, 0x2, 
			 0x2, 0x44d, 0x45e, 0x5, 0x5e, 0x30, 0x2, 0x44e, 0x450, 0x5, 0xd8, 0x6d, 
			 0x2, 0x44f, 0x44e, 0x3, 0x2, 0x2, 0x2, 0x44f, 0x450, 0x3, 0x2, 0x2, 
			 0x2, 0x450, 0x451, 0x3, 0x2, 0x2, 0x2, 0x451, 0x452, 0x5, 0x90, 0x49, 
			 0x2, 0x452, 0x453, 0x5, 0xf2, 0x7a, 0x2, 0x453, 0x454, 0x7, 0x66, 0x2, 
			 0x2, 0x454, 0x455, 0x5, 0x120, 0x91, 0x2, 0x455, 0x45e, 0x3, 0x2, 0x2, 
			 0x2, 0x456, 0x458, 0x5, 0xd8, 0x6d, 0x2, 0x457, 0x456, 0x3, 0x2, 0x2, 
			 0x2, 0x457, 0x458, 0x3, 0x2, 0x2, 0x2, 0x458, 0x459, 0x3, 0x2, 0x2, 
			 0x2, 0x459, 0x45a, 0x5, 0x90, 0x49, 0x2, 0x45a, 0x45b, 0x5, 0xf2, 0x7a, 
			 0x2, 0x45b, 0x45c, 0x5, 0x124, 0x93, 0x2, 0x45c, 0x45e, 0x3, 0x2, 0x2, 
			 0x2, 0x45d, 0x44d, 0x3, 0x2, 0x2, 0x2, 0x45d, 0x44f, 0x3, 0x2, 0x2, 
			 0x2, 0x45d, 0x457, 0x3, 0x2, 0x2, 0x2, 0x45e, 0x6f, 0x3, 0x2, 0x2, 0x2, 
			 0x45f, 0x460, 0x7, 0x55, 0x2, 0x2, 0x460, 0x461, 0x7, 0x56, 0x2, 0x2, 
			 0x461, 0x462, 0x5, 0x6e, 0x38, 0x2, 0x462, 0x463, 0x7, 0x57, 0x2, 0x2, 
			 0x463, 0x464, 0x5, 0x62, 0x32, 0x2, 0x464, 0x483, 0x3, 0x2, 0x2, 0x2, 
			 0x465, 0x466, 0x7, 0x1e, 0x2, 0x2, 0x466, 0x467, 0x5, 0x62, 0x32, 0x2, 
			 0x467, 0x468, 0x7, 0x55, 0x2, 0x2, 0x468, 0x469, 0x7, 0x56, 0x2, 0x2, 
			 0x469, 0x46a, 0x5, 0x5e, 0x30, 0x2, 0x46a, 0x46b, 0x7, 0x57, 0x2, 0x2, 
			 0x46b, 0x46c, 0x7, 0x80, 0x2, 0x2, 0x46c, 0x483, 0x3, 0x2, 0x2, 0x2, 
			 0x46d, 0x46e, 0x7, 0x29, 0x2, 0x2, 0x46e, 0x46f, 0x7, 0x56, 0x2, 0x2, 
			 0x46f, 0x471, 0x5, 0x72, 0x3a, 0x2, 0x470, 0x472, 0x5, 0x6e, 0x38, 0x2, 
			 0x471, 0x470, 0x3, 0x2, 0x2, 0x2, 0x471, 0x472, 0x3, 0x2, 0x2, 0x2, 
			 0x472, 0x473, 0x3, 0x2, 0x2, 0x2, 0x473, 0x475, 0x7, 0x80, 0x2, 0x2, 
			 0x474, 0x476, 0x5, 0x5e, 0x30, 0x2, 0x475, 0x474, 0x3, 0x2, 0x2, 0x2, 
			 0x475, 0x476, 0x3, 0x2, 0x2, 0x2, 0x476, 0x477, 0x3, 0x2, 0x2, 0x2, 
			 0x477, 0x478, 0x7, 0x57, 0x2, 0x2, 0x478, 0x479, 0x5, 0x62, 0x32, 0x2, 
			 0x479, 0x483, 0x3, 0x2, 0x2, 0x2, 0x47a, 0x47b, 0x7, 0x29, 0x2, 0x2, 
			 0x47b, 0x47c, 0x7, 0x56, 0x2, 0x2, 0x47c, 0x47d, 0x5, 0x74, 0x3b, 0x2, 
			 0x47d, 0x47e, 0x7, 0x7e, 0x2, 0x2, 0x47e, 0x47f, 0x5, 0x76, 0x3c, 0x2, 
			 0x47f, 0x480, 0x7, 0x57, 0x2, 0x2, 0x480, 0x481, 0x5, 0x62, 0x32, 0x2, 
			 0x481, 0x483, 0x3, 0x2, 0x2, 0x2, 0x482, 0x45f, 0x3, 0x2, 0x2, 0x2, 
			 0x482, 0x465, 0x3, 0x2, 0x2, 0x2, 0x482, 0x46d, 0x3, 0x2, 0x2, 0x2, 
			 0x482, 0x47a, 0x3, 0x2, 0x2, 0x2, 0x483, 0x71, 0x3, 0x2, 0x2, 0x2, 0x484, 
			 0x487, 0x5, 0x66, 0x34, 0x2, 0x485, 0x487, 0x5, 0x86, 0x44, 0x2, 0x486, 
			 0x484, 0x3, 0x2, 0x2, 0x2, 0x486, 0x485, 0x3, 0x2, 0x2, 0x2, 0x487, 
			 0x73, 0x3, 0x2, 0x2, 0x2, 0x488, 0x48a, 0x5, 0xd8, 0x6d, 0x2, 0x489, 
			 0x488, 0x3, 0x2, 0x2, 0x2, 0x489, 0x48a, 0x3, 0x2, 0x2, 0x2, 0x48a, 
			 0x48b, 0x3, 0x2, 0x2, 0x2, 0x48b, 0x48c, 0x5, 0x90, 0x49, 0x2, 0x48c, 
			 0x48d, 0x5, 0xf2, 0x7a, 0x2, 0x48d, 0x75, 0x3, 0x2, 0x2, 0x2, 0x48e, 
			 0x491, 0x5, 0x5e, 0x30, 0x2, 0x48f, 0x491, 0x5, 0x124, 0x93, 0x2, 0x490, 
			 0x48e, 0x3, 0x2, 0x2, 0x2, 0x490, 0x48f, 0x3, 0x2, 0x2, 0x2, 0x491, 
			 0x77, 0x3, 0x2, 0x2, 0x2, 0x492, 0x493, 0x7, 0x10, 0x2, 0x2, 0x493, 
			 0x4a3, 0x7, 0x80, 0x2, 0x2, 0x494, 0x495, 0x7, 0x1a, 0x2, 0x2, 0x495, 
			 0x4a3, 0x7, 0x80, 0x2, 0x2, 0x496, 0x498, 0x7, 0x3c, 0x2, 0x2, 0x497, 
			 0x499, 0x5, 0x5e, 0x30, 0x2, 0x498, 0x497, 0x3, 0x2, 0x2, 0x2, 0x498, 
			 0x499, 0x3, 0x2, 0x2, 0x2, 0x499, 0x49a, 0x3, 0x2, 0x2, 0x2, 0x49a, 
			 0x4a3, 0x7, 0x80, 0x2, 0x2, 0x49b, 0x49c, 0x7, 0x3c, 0x2, 0x2, 0x49c, 
			 0x49d, 0x5, 0x124, 0x93, 0x2, 0x49d, 0x49e, 0x7, 0x80, 0x2, 0x2, 0x49e, 
			 0x4a3, 0x3, 0x2, 0x2, 0x2, 0x49f, 0x4a0, 0x7, 0x2b, 0x2, 0x2, 0x4a0, 
			 0x4a1, 0x7, 0x84, 0x2, 0x2, 0x4a1, 0x4a3, 0x7, 0x80, 0x2, 0x2, 0x4a2, 
			 0x492, 0x3, 0x2, 0x2, 0x2, 0x4a2, 0x494, 0x3, 0x2, 0x2, 0x2, 0x4a2, 
			 0x496, 0x3, 0x2, 0x2, 0x2, 0x4a2, 0x49b, 0x3, 0x2, 0x2, 0x2, 0x4a2, 
			 0x49f, 0x3, 0x2, 0x2, 0x2, 0x4a3, 0x79, 0x3, 0x2, 0x2, 0x2, 0x4a4, 0x4a5, 
			 0x5, 0x82, 0x42, 0x2, 0x4a5, 0x7b, 0x3, 0x2, 0x2, 0x2, 0x4a6, 0x4a8, 
			 0x5, 0x7e, 0x40, 0x2, 0x4a7, 0x4a6, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x4ab, 
			 0x3, 0x2, 0x2, 0x2, 0x4a9, 0x4a7, 0x3, 0x2, 0x2, 0x2, 0x4a9, 0x4aa, 
			 0x3, 0x2, 0x2, 0x2, 0x4aa, 0x7d, 0x3, 0x2, 0x2, 0x2, 0x4ab, 0x4a9, 0x3, 
			 0x2, 0x2, 0x2, 0x4ac, 0x4b7, 0x5, 0x82, 0x42, 0x2, 0x4ad, 0x4b7, 0x5, 
			 0x118, 0x8d, 0x2, 0x4ae, 0x4b7, 0x5, 0x15e, 0xb0, 0x2, 0x4af, 0x4b7, 
			 0x5, 0x172, 0xba, 0x2, 0x4b0, 0x4b7, 0x5, 0x174, 0xbb, 0x2, 0x4b1, 0x4b7, 
			 0x5, 0xd6, 0x6c, 0x2, 0x4b2, 0x4b7, 0x5, 0xbe, 0x60, 0x2, 0x4b3, 0x4b7, 
			 0x5, 0x8a, 0x46, 0x2, 0x4b4, 0x4b7, 0x5, 0x8c, 0x47, 0x2, 0x4b5, 0x4b7, 
			 0x5, 0x80, 0x41, 0x2, 0x4b6, 0x4ac, 0x3, 0x2, 0x2, 0x2, 0x4b6, 0x4ad, 
			 0x3, 0x2, 0x2, 0x2, 0x4b6, 0x4ae, 0x3, 0x2, 0x2, 0x2, 0x4b6, 0x4af, 
			 0x3, 0x2, 0x2, 0x2, 0x4b6, 0x4b0, 0x3, 0x2, 0x2, 0x2, 0x4b6, 0x4b1, 
			 0x3, 0x2, 0x2, 0x2, 0x4b6, 0x4b2, 0x3, 0x2, 0x2, 0x2, 0x4b6, 0x4b3, 
			 0x3, 0x2, 0x2, 0x2, 0x4b6, 0x4b4, 0x3, 0x2, 0x2, 0x2, 0x4b6, 0x4b5, 
			 0x3, 0x2, 0x2, 0x2, 0x4b7, 0x7f, 0x3, 0x2, 0x2, 0x2, 0x4b8, 0x4b9, 0x9, 
			 0x4, 0x2, 0x2, 0x4b9, 0x81, 0x3, 0x2, 0x2, 0x2, 0x4ba, 0x4c3, 0x5, 0x86, 
			 0x44, 0x2, 0x4bb, 0x4c3, 0x5, 0xd4, 0x6b, 0x2, 0x4bc, 0x4c3, 0x5, 0xcc, 
			 0x67, 0x2, 0x4bd, 0x4c3, 0x5, 0xd0, 0x69, 0x2, 0x4be, 0x4c3, 0x5, 0xd2, 
			 0x6a, 0x2, 0x4bf, 0x4c3, 0x5, 0x88, 0x45, 0x2, 0x4c0, 0x4c3, 0x5, 0x84, 
			 0x43, 0x2, 0x4c1, 0x4c3, 0x5, 0xae, 0x58, 0x2, 0x4c2, 0x4ba, 0x3, 0x2, 
			 0x2, 0x2, 0x4c2, 0x4bb, 0x3, 0x2, 0x2, 0x2, 0x4c2, 0x4bc, 0x3, 0x2, 
			 0x2, 0x2, 0x4c2, 0x4bd, 0x3, 0x2, 0x2, 0x2, 0x4c2, 0x4be, 0x3, 0x2, 
			 0x2, 0x2, 0x4c2, 0x4bf, 0x3, 0x2, 0x2, 0x2, 0x4c2, 0x4c0, 0x3, 0x2, 
			 0x2, 0x2, 0x4c2, 0x4c1, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x83, 0x3, 0x2, 0x2, 
			 0x2, 0x4c4, 0x4c5, 0x7, 0x50, 0x2, 0x2, 0x4c5, 0x4c7, 0x7, 0x84, 0x2, 
			 0x2, 0x4c6, 0x4c8, 0x5, 0xd8, 0x6d, 0x2, 0x4c7, 0x4c6, 0x3, 0x2, 0x2, 
			 0x2, 0x4c7, 0x4c8, 0x3, 0x2, 0x2, 0x2, 0x4c8, 0x4c9, 0x3, 0x2, 0x2, 
			 0x2, 0x4c9, 0x4ca, 0x7, 0x66, 0x2, 0x2, 0x4ca, 0x4cb, 0x5, 0x106, 0x84, 
			 0x2, 0x4cb, 0x4cc, 0x7, 0x80, 0x2, 0x2, 0x4cc, 0x85, 0x3, 0x2, 0x2, 
			 0x2, 0x4cd, 0x4cf, 0x5, 0x90, 0x49, 0x2, 0x4ce, 0x4cd, 0x3, 0x2, 0x2, 
			 0x2, 0x4ce, 0x4cf, 0x3, 0x2, 0x2, 0x2, 0x4cf, 0x4d1, 0x3, 0x2, 0x2, 
			 0x2, 0x4d0, 0x4d2, 0x5, 0xee, 0x78, 0x2, 0x4d1, 0x4d0, 0x3, 0x2, 0x2, 
			 0x2, 0x4d1, 0x4d2, 0x3, 0x2, 0x2, 0x2, 0x4d2, 0x4d3, 0x3, 0x2, 0x2, 
			 0x2, 0x4d3, 0x4dc, 0x7, 0x80, 0x2, 0x2, 0x4d4, 0x4d6, 0x5, 0xd8, 0x6d, 
			 0x2, 0x4d5, 0x4d7, 0x5, 0x90, 0x49, 0x2, 0x4d6, 0x4d5, 0x3, 0x2, 0x2, 
			 0x2, 0x4d6, 0x4d7, 0x3, 0x2, 0x2, 0x2, 0x4d7, 0x4d8, 0x3, 0x2, 0x2, 
			 0x2, 0x4d8, 0x4d9, 0x5, 0xee, 0x78, 0x2, 0x4d9, 0x4da, 0x7, 0x80, 0x2, 
			 0x2, 0x4da, 0x4dc, 0x3, 0x2, 0x2, 0x2, 0x4db, 0x4ce, 0x3, 0x2, 0x2, 
			 0x2, 0x4db, 0x4d4, 0x3, 0x2, 0x2, 0x2, 0x4dc, 0x87, 0x3, 0x2, 0x2, 0x2, 
			 0x4dd, 0x4de, 0x7, 0x41, 0x2, 0x2, 0x4de, 0x4df, 0x7, 0x56, 0x2, 0x2, 
			 0x4df, 0x4e0, 0x5, 0x60, 0x31, 0x2, 0x4e0, 0x4e1, 0x7, 0x7a, 0x2, 0x2, 
			 0x4e1, 0x4e2, 0x7, 0x8d, 0x2, 0x2, 0x4e2, 0x4e3, 0x7, 0x57, 0x2, 0x2, 
			 0x4e3, 0x4e4, 0x7, 0x80, 0x2, 0x2, 0x4e4, 0x89, 0x3, 0x2, 0x2, 0x2, 
			 0x4e5, 0x4e6, 0x7, 0x80, 0x2, 0x2, 0x4e6, 0x8b, 0x3, 0x2, 0x2, 0x2, 
			 0x4e7, 0x4e8, 0x5, 0xd8, 0x6d, 0x2, 0x4e8, 0x4e9, 0x7, 0x80, 0x2, 0x2, 
			 0x4e9, 0x8d, 0x3, 0x2, 0x2, 0x2, 0x4ea, 0x4f1, 0x5, 0x92, 0x4a, 0x2, 
			 0x4eb, 0x4f1, 0x5, 0x98, 0x4d, 0x2, 0x4ec, 0x4f1, 0x5, 0x94, 0x4b, 0x2, 
			 0x4ed, 0x4f1, 0x7, 0x2a, 0x2, 0x2, 0x4ee, 0x4f1, 0x7, 0x4b, 0x2, 0x2, 
			 0x4ef, 0x4f1, 0x7, 0x18, 0x2, 0x2, 0x4f0, 0x4ea, 0x3, 0x2, 0x2, 0x2, 
			 0x4f0, 0x4eb, 0x3, 0x2, 0x2, 0x2, 0x4f0, 0x4ec, 0x3, 0x2, 0x2, 0x2, 
			 0x4f0, 0x4ed, 0x3, 0x2, 0x2, 0x2, 0x4f0, 0x4ee, 0x3, 0x2, 0x2, 0x2, 
			 0x4f0, 0x4ef, 0x3, 0x2, 0x2, 0x2, 0x4f1, 0x8f, 0x3, 0x2, 0x2, 0x2, 0x4f2, 
			 0x4f4, 0x5, 0x8e, 0x48, 0x2, 0x4f3, 0x4f5, 0x5, 0xd8, 0x6d, 0x2, 0x4f4, 
			 0x4f3, 0x3, 0x2, 0x2, 0x2, 0x4f4, 0x4f5, 0x3, 0x2, 0x2, 0x2, 0x4f5, 
			 0x4fa, 0x3, 0x2, 0x2, 0x2, 0x4f6, 0x4f7, 0x5, 0x8e, 0x48, 0x2, 0x4f7, 
			 0x4f8, 0x5, 0x90, 0x49, 0x2, 0x4f8, 0x4fa, 0x3, 0x2, 0x2, 0x2, 0x4f9, 
			 0x4f2, 0x3, 0x2, 0x2, 0x2, 0x4f9, 0x4f6, 0x3, 0x2, 0x2, 0x2, 0x4fa, 
			 0x91, 0x3, 0x2, 0x2, 0x2, 0x4fb, 0x4fc, 0x9, 0x5, 0x2, 0x2, 0x4fc, 0x93, 
			 0x3, 0x2, 0x2, 0x2, 0x4fd, 0x4fe, 0x9, 0x6, 0x2, 0x2, 0x4fe, 0x95, 0x3, 
			 0x2, 0x2, 0x2, 0x4ff, 0x500, 0x7, 0x84, 0x2, 0x2, 0x500, 0x97, 0x3, 
			 0x2, 0x2, 0x2, 0x501, 0x505, 0x5, 0x9a, 0x4e, 0x2, 0x502, 0x505, 0x5, 
			 0x128, 0x95, 0x2, 0x503, 0x505, 0x5, 0xaa, 0x56, 0x2, 0x504, 0x501, 
			 0x3, 0x2, 0x2, 0x2, 0x504, 0x502, 0x3, 0x2, 0x2, 0x2, 0x504, 0x503, 
			 0x3, 0x2, 0x2, 0x2, 0x505, 0x99, 0x3, 0x2, 0x2, 0x2, 0x506, 0x50b, 0x5, 
			 0xa0, 0x51, 0x2, 0x507, 0x50b, 0x5, 0xa6, 0x54, 0x2, 0x508, 0x50b, 0x5, 
			 0x170, 0xb9, 0x2, 0x509, 0x50b, 0x5, 0x100, 0x81, 0x2, 0x50a, 0x506, 
			 0x3, 0x2, 0x2, 0x2, 0x50a, 0x507, 0x3, 0x2, 0x2, 0x2, 0x50a, 0x508, 
			 0x3, 0x2, 0x2, 0x2, 0x50a, 0x509, 0x3, 0x2, 0x2, 0x2, 0x50b, 0x9b, 0x3, 
			 0x2, 0x2, 0x2, 0x50c, 0x50e, 0x5, 0x98, 0x4d, 0x2, 0x50d, 0x50f, 0x5, 
			 0xd8, 0x6d, 0x2, 0x50e, 0x50d, 0x3, 0x2, 0x2, 0x2, 0x50e, 0x50f, 0x3, 
			 0x2, 0x2, 0x2, 0x50f, 0x514, 0x3, 0x2, 0x2, 0x2, 0x510, 0x511, 0x5, 
			 0x98, 0x4d, 0x2, 0x511, 0x512, 0x5, 0x9c, 0x4f, 0x2, 0x512, 0x514, 0x3, 
			 0x2, 0x2, 0x2, 0x513, 0x50c, 0x3, 0x2, 0x2, 0x2, 0x513, 0x510, 0x3, 
			 0x2, 0x2, 0x2, 0x514, 0x9d, 0x3, 0x2, 0x2, 0x2, 0x515, 0x517, 0x5, 0x9a, 
			 0x4e, 0x2, 0x516, 0x518, 0x5, 0xd8, 0x6d, 0x2, 0x517, 0x516, 0x3, 0x2, 
			 0x2, 0x2, 0x517, 0x518, 0x3, 0x2, 0x2, 0x2, 0x518, 0x51d, 0x3, 0x2, 
			 0x2, 0x2, 0x519, 0x51a, 0x5, 0x9a, 0x4e, 0x2, 0x51a, 0x51b, 0x5, 0x9e, 
			 0x50, 0x2, 0x51b, 0x51d, 0x3, 0x2, 0x2, 0x2, 0x51c, 0x515, 0x3, 0x2, 
			 0x2, 0x2, 0x51c, 0x519, 0x3, 0x2, 0x2, 0x2, 0x51d, 0x9f, 0x3, 0x2, 0x2, 
			 0x2, 0x51e, 0x520, 0x5, 0xc, 0x7, 0x2, 0x51f, 0x51e, 0x3, 0x2, 0x2, 
			 0x2, 0x51f, 0x520, 0x3, 0x2, 0x2, 0x2, 0x520, 0x521, 0x3, 0x2, 0x2, 
			 0x2, 0x521, 0x536, 0x5, 0xa2, 0x52, 0x2, 0x522, 0x523, 0x5, 0xc, 0x7, 
			 0x2, 0x523, 0x524, 0x7, 0x45, 0x2, 0x2, 0x524, 0x525, 0x5, 0x166, 0xb4, 
			 0x2, 0x525, 0x536, 0x3, 0x2, 0x2, 0x2, 0x526, 0x536, 0x7, 0x13, 0x2, 
			 0x2, 0x527, 0x536, 0x7, 0x14, 0x2, 0x2, 0x528, 0x536, 0x7, 0x15, 0x2, 
			 0x2, 0x529, 0x536, 0x7, 0x54, 0x2, 0x2, 0x52a, 0x536, 0x7, 0xf, 0x2, 
			 0x2, 0x52b, 0x536, 0x7, 0x3d, 0x2, 0x2, 0x52c, 0x536, 0x7, 0x2e, 0x2, 
			 0x2, 0x52d, 0x536, 0x7, 0x2f, 0x2, 0x2, 0x52e, 0x536, 0x7, 0x3e, 0x2, 
			 0x2, 0x52f, 0x536, 0x7, 0x4f, 0x2, 0x2, 0x530, 0x536, 0x7, 0x28, 0x2, 
			 0x2, 0x531, 0x536, 0x7, 0x1f, 0x2, 0x2, 0x532, 0x536, 0x7, 0x52, 0x2, 
			 0x2, 0x533, 0x536, 0x7, 0xe, 0x2, 0x2, 0x534, 0x536, 0x5, 0xa4, 0x53, 
			 0x2, 0x535, 0x51f, 0x3, 0x2, 0x2, 0x2, 0x535, 0x522, 0x3, 0x2, 0x2, 
			 0x2, 0x535, 0x526, 0x3, 0x2, 0x2, 0x2, 0x535, 0x527, 0x3, 0x2, 0x2, 
			 0x2, 0x535, 0x528, 0x3, 0x2, 0x2, 0x2, 0x535, 0x529, 0x3, 0x2, 0x2, 
			 0x2, 0x535, 0x52a, 0x3, 0x2, 0x2, 0x2, 0x535, 0x52b, 0x3, 0x2, 0x2, 
			 0x2, 0x535, 0x52c, 0x3, 0x2, 0x2, 0x2, 0x535, 0x52d, 0x3, 0x2, 0x2, 
			 0x2, 0x535, 0x52e, 0x3, 0x2, 0x2, 0x2, 0x535, 0x52f, 0x3, 0x2, 0x2, 
			 0x2, 0x535, 0x530, 0x3, 0x2, 0x2, 0x2, 0x535, 0x531, 0x3, 0x2, 0x2, 
			 0x2, 0x535, 0x532, 0x3, 0x2, 0x2, 0x2, 0x535, 0x533, 0x3, 0x2, 0x2, 
			 0x2, 0x535, 0x534, 0x3, 0x2, 0x2, 0x2, 0x536, 0xa1, 0x3, 0x2, 0x2, 0x2, 
			 0x537, 0x53c, 0x5, 0x126, 0x94, 0x2, 0x538, 0x53c, 0x5, 0xa8, 0x55, 
			 0x2, 0x539, 0x53c, 0x5, 0x96, 0x4c, 0x2, 0x53a, 0x53c, 0x5, 0x166, 0xb4, 
			 0x2, 0x53b, 0x537, 0x3, 0x2, 0x2, 0x2, 0x53b, 0x538, 0x3, 0x2, 0x2, 
			 0x2, 0x53b, 0x539, 0x3, 0x2, 0x2, 0x2, 0x53b, 0x53a, 0x3, 0x2, 0x2, 
			 0x2, 0x53c, 0xa3, 0x3, 0x2, 0x2, 0x2, 0x53d, 0x53e, 0x7, 0x1b, 0x2, 
			 0x2, 0x53e, 0x53f, 0x7, 0x56, 0x2, 0x2, 0x53f, 0x540, 0x5, 0x5e, 0x30, 
			 0x2, 0x540, 0x541, 0x7, 0x57, 0x2, 0x2, 0x541, 0x547, 0x3, 0x2, 0x2, 
			 0x2, 0x542, 0x543, 0x7, 0x1b, 0x2, 0x2, 0x543, 0x544, 0x7, 0x56, 0x2, 
			 0x2, 0x544, 0x545, 0x7, 0xe, 0x2, 0x2, 0x545, 0x547, 0x7, 0x57, 0x2, 
			 0x2, 0x546, 0x53d, 0x3, 0x2, 0x2, 0x2, 0x546, 0x542, 0x3, 0x2, 0x2, 
			 0x2, 0x547, 0xa5, 0x3, 0x2, 0x2, 0x2, 0x548, 0x54a, 0x5, 0x130, 0x99, 
			 0x2, 0x549, 0x54b, 0x5, 0xd8, 0x6d, 0x2, 0x54a, 0x549, 0x3, 0x2, 0x2, 
			 0x2, 0x54a, 0x54b, 0x3, 0x2, 0x2, 0x2, 0x54b, 0x54d, 0x3, 0x2, 0x2, 
			 0x2, 0x54c, 0x54e, 0x5, 0xc, 0x7, 0x2, 0x54d, 0x54c, 0x3, 0x2, 0x2, 
			 0x2, 0x54d, 0x54e, 0x3, 0x2, 0x2, 0x2, 0x54e, 0x54f, 0x3, 0x2, 0x2, 
			 0x2, 0x54f, 0x550, 0x7, 0x84, 0x2, 0x2, 0x550, 0x561, 0x3, 0x2, 0x2, 
			 0x2, 0x551, 0x552, 0x5, 0x130, 0x99, 0x2, 0x552, 0x553, 0x5, 0x166, 
			 0xb4, 0x2, 0x553, 0x561, 0x3, 0x2, 0x2, 0x2, 0x554, 0x555, 0x5, 0x130, 
			 0x99, 0x2, 0x555, 0x557, 0x5, 0xc, 0x7, 0x2, 0x556, 0x558, 0x7, 0x45, 
			 0x2, 0x2, 0x557, 0x556, 0x3, 0x2, 0x2, 0x2, 0x557, 0x558, 0x3, 0x2, 
			 0x2, 0x2, 0x558, 0x559, 0x3, 0x2, 0x2, 0x2, 0x559, 0x55a, 0x5, 0x166, 
			 0xb4, 0x2, 0x55a, 0x561, 0x3, 0x2, 0x2, 0x2, 0x55b, 0x55d, 0x7, 0x22, 
			 0x2, 0x2, 0x55c, 0x55e, 0x5, 0xc, 0x7, 0x2, 0x55d, 0x55c, 0x3, 0x2, 
			 0x2, 0x2, 0x55d, 0x55e, 0x3, 0x2, 0x2, 0x2, 0x55e, 0x55f, 0x3, 0x2, 
			 0x2, 0x2, 0x55f, 0x561, 0x7, 0x84, 0x2, 0x2, 0x560, 0x548, 0x3, 0x2, 
			 0x2, 0x2, 0x560, 0x551, 0x3, 0x2, 0x2, 0x2, 0x560, 0x554, 0x3, 0x2, 
			 0x2, 0x2, 0x560, 0x55b, 0x3, 0x2, 0x2, 0x2, 0x561, 0xa7, 0x3, 0x2, 0x2, 
			 0x2, 0x562, 0x563, 0x7, 0x84, 0x2, 0x2, 0x563, 0xa9, 0x3, 0x2, 0x2, 
			 0x2, 0x564, 0x565, 0x5, 0xac, 0x57, 0x2, 0x565, 0x567, 0x7, 0x5a, 0x2, 
			 0x2, 0x566, 0x568, 0x5, 0xb4, 0x5b, 0x2, 0x567, 0x566, 0x3, 0x2, 0x2, 
			 0x2, 0x567, 0x568, 0x3, 0x2, 0x2, 0x2, 0x568, 0x569, 0x3, 0x2, 0x2, 
			 0x2, 0x569, 0x56a, 0x7, 0x5b, 0x2, 0x2, 0x56a, 0x572, 0x3, 0x2, 0x2, 
			 0x2, 0x56b, 0x56c, 0x5, 0xac, 0x57, 0x2, 0x56c, 0x56d, 0x7, 0x5a, 0x2, 
			 0x2, 0x56d, 0x56e, 0x5, 0xb4, 0x5b, 0x2, 0x56e, 0x56f, 0x7, 0x7a, 0x2, 
			 0x2, 0x56f, 0x570, 0x7, 0x5b, 0x2, 0x2, 0x570, 0x572, 0x3, 0x2, 0x2, 
			 0x2, 0x571, 0x564, 0x3, 0x2, 0x2, 0x2, 0x571, 0x56b, 0x3, 0x2, 0x2, 
			 0x2, 0x572, 0xab, 0x3, 0x2, 0x2, 0x2, 0x573, 0x575, 0x5, 0xb0, 0x59, 
			 0x2, 0x574, 0x576, 0x5, 0xd8, 0x6d, 0x2, 0x575, 0x574, 0x3, 0x2, 0x2, 
			 0x2, 0x575, 0x576, 0x3, 0x2, 0x2, 0x2, 0x576, 0x578, 0x3, 0x2, 0x2, 
			 0x2, 0x577, 0x579, 0x7, 0x84, 0x2, 0x2, 0x578, 0x577, 0x3, 0x2, 0x2, 
			 0x2, 0x578, 0x579, 0x3, 0x2, 0x2, 0x2, 0x579, 0x57b, 0x3, 0x2, 0x2, 
			 0x2, 0x57a, 0x57c, 0x5, 0xb2, 0x5a, 0x2, 0x57b, 0x57a, 0x3, 0x2, 0x2, 
			 0x2, 0x57b, 0x57c, 0x3, 0x2, 0x2, 0x2, 0x57c, 0x587, 0x3, 0x2, 0x2, 
			 0x2, 0x57d, 0x57f, 0x5, 0xb0, 0x59, 0x2, 0x57e, 0x580, 0x5, 0xd8, 0x6d, 
			 0x2, 0x57f, 0x57e, 0x3, 0x2, 0x2, 0x2, 0x57f, 0x580, 0x3, 0x2, 0x2, 
			 0x2, 0x580, 0x581, 0x3, 0x2, 0x2, 0x2, 0x581, 0x582, 0x5, 0xc, 0x7, 
			 0x2, 0x582, 0x584, 0x7, 0x84, 0x2, 0x2, 0x583, 0x585, 0x5, 0xb2, 0x5a, 
			 0x2, 0x584, 0x583, 0x3, 0x2, 0x2, 0x2, 0x584, 0x585, 0x3, 0x2, 0x2, 
			 0x2, 0x585, 0x587, 0x3, 0x2, 0x2, 0x2, 0x586, 0x573, 0x3, 0x2, 0x2, 
			 0x2, 0x586, 0x57d, 0x3, 0x2, 0x2, 0x2, 0x587, 0xad, 0x3, 0x2, 0x2, 0x2, 
			 0x588, 0x58a, 0x5, 0xb0, 0x59, 0x2, 0x589, 0x58b, 0x5, 0xd8, 0x6d, 0x2, 
			 0x58a, 0x589, 0x3, 0x2, 0x2, 0x2, 0x58a, 0x58b, 0x3, 0x2, 0x2, 0x2, 
			 0x58b, 0x58c, 0x3, 0x2, 0x2, 0x2, 0x58c, 0x58e, 0x7, 0x84, 0x2, 0x2, 
			 0x58d, 0x58f, 0x5, 0xb2, 0x5a, 0x2, 0x58e, 0x58d, 0x3, 0x2, 0x2, 0x2, 
			 0x58e, 0x58f, 0x3, 0x2, 0x2, 0x2, 0x58f, 0x590, 0x3, 0x2, 0x2, 0x2, 
			 0x590, 0x591, 0x7, 0x80, 0x2, 0x2, 0x591, 0xaf, 0x3, 0x2, 0x2, 0x2, 
			 0x592, 0x598, 0x7, 0x22, 0x2, 0x2, 0x593, 0x594, 0x7, 0x22, 0x2, 0x2, 
			 0x594, 0x598, 0x7, 0x16, 0x2, 0x2, 0x595, 0x596, 0x7, 0x22, 0x2, 0x2, 
			 0x596, 0x598, 0x7, 0x43, 0x2, 0x2, 0x597, 0x592, 0x3, 0x2, 0x2, 0x2, 
			 0x597, 0x593, 0x3, 0x2, 0x2, 0x2, 0x597, 0x595, 0x3, 0x2, 0x2, 0x2, 
			 0x598, 0xb1, 0x3, 0x2, 0x2, 0x2, 0x599, 0x59a, 0x7, 0x7e, 0x2, 0x2, 
			 0x59a, 0x59b, 0x5, 0x9c, 0x4f, 0x2, 0x59b, 0xb3, 0x3, 0x2, 0x2, 0x2, 
			 0x59c, 0x59d, 0x8, 0x5b, 0x1, 0x2, 0x59d, 0x59e, 0x5, 0xb6, 0x5c, 0x2, 
			 0x59e, 0x5a4, 0x3, 0x2, 0x2, 0x2, 0x59f, 0x5a0, 0xc, 0x3, 0x2, 0x2, 
			 0x5a0, 0x5a1, 0x7, 0x7a, 0x2, 0x2, 0x5a1, 0x5a3, 0x5, 0xb6, 0x5c, 0x2, 
			 0x5a2, 0x59f, 0x3, 0x2, 0x2, 0x2, 0x5a3, 0x5a6, 0x3, 0x2, 0x2, 0x2, 
			 0x5a4, 0x5a2, 0x3, 0x2, 0x2, 0x2, 0x5a4, 0x5a5, 0x3, 0x2, 0x2, 0x2, 
			 0x5a5, 0xb5, 0x3, 0x2, 0x2, 0x2, 0x5a6, 0x5a4, 0x3, 0x2, 0x2, 0x2, 0x5a7, 
			 0x5ad, 0x5, 0xb8, 0x5d, 0x2, 0x5a8, 0x5a9, 0x5, 0xb8, 0x5d, 0x2, 0x5a9, 
			 0x5aa, 0x7, 0x66, 0x2, 0x2, 0x5aa, 0x5ab, 0x5, 0x60, 0x31, 0x2, 0x5ab, 
			 0x5ad, 0x3, 0x2, 0x2, 0x2, 0x5ac, 0x5a7, 0x3, 0x2, 0x2, 0x2, 0x5ac, 
			 0x5a8, 0x3, 0x2, 0x2, 0x2, 0x5ad, 0xb7, 0x3, 0x2, 0x2, 0x2, 0x5ae, 0x5af, 
			 0x7, 0x84, 0x2, 0x2, 0x5af, 0xb9, 0x3, 0x2, 0x2, 0x2, 0x5b0, 0x5b3, 
			 0x5, 0xbc, 0x5f, 0x2, 0x5b1, 0x5b3, 0x5, 0xca, 0x66, 0x2, 0x5b2, 0x5b0, 
			 0x3, 0x2, 0x2, 0x2, 0x5b2, 0x5b1, 0x3, 0x2, 0x2, 0x2, 0x5b3, 0xbb, 0x3, 
			 0x2, 0x2, 0x2, 0x5b4, 0x5b5, 0x7, 0x84, 0x2, 0x2, 0x5b5, 0xbd, 0x3, 
			 0x2, 0x2, 0x2, 0x5b6, 0x5b9, 0x5, 0xc0, 0x61, 0x2, 0x5b7, 0x5b9, 0x5, 
			 0xc6, 0x64, 0x2, 0x5b8, 0x5b6, 0x3, 0x2, 0x2, 0x2, 0x5b8, 0x5b7, 0x3, 
			 0x2, 0x2, 0x2, 0x5b9, 0xbf, 0x3, 0x2, 0x2, 0x2, 0x5ba, 0x5bd, 0x5, 0xc2, 
			 0x62, 0x2, 0x5bb, 0x5bd, 0x5, 0xc4, 0x63, 0x2, 0x5bc, 0x5ba, 0x3, 0x2, 
			 0x2, 0x2, 0x5bc, 0x5bb, 0x3, 0x2, 0x2, 0x2, 0x5bd, 0xc1, 0x3, 0x2, 0x2, 
			 0x2, 0x5be, 0x5c0, 0x7, 0x2d, 0x2, 0x2, 0x5bf, 0x5be, 0x3, 0x2, 0x2, 
			 0x2, 0x5bf, 0x5c0, 0x3, 0x2, 0x2, 0x2, 0x5c0, 0x5c1, 0x3, 0x2, 0x2, 
			 0x2, 0x5c1, 0x5c2, 0x7, 0x31, 0x2, 0x2, 0x5c2, 0x5c3, 0x7, 0x84, 0x2, 
			 0x2, 0x5c3, 0x5c4, 0x7, 0x5a, 0x2, 0x2, 0x5c4, 0x5c5, 0x5, 0xc8, 0x65, 
			 0x2, 0x5c5, 0x5c6, 0x7, 0x5b, 0x2, 0x2, 0x5c6, 0xc3, 0x3, 0x2, 0x2, 
			 0x2, 0x5c7, 0x5c9, 0x7, 0x2d, 0x2, 0x2, 0x5c8, 0x5c7, 0x3, 0x2, 0x2, 
			 0x2, 0x5c8, 0x5c9, 0x3, 0x2, 0x2, 0x2, 0x5c9, 0x5ca, 0x3, 0x2, 0x2, 
			 0x2, 0x5ca, 0x5cb, 0x7, 0x31, 0x2, 0x2, 0x5cb, 0x5cc, 0x5, 0xbc, 0x5f, 
			 0x2, 0x5cc, 0x5cd, 0x7, 0x5a, 0x2, 0x2, 0x5cd, 0x5ce, 0x5, 0xc8, 0x65, 
			 0x2, 0x5ce, 0x5cf, 0x7, 0x5b, 0x2, 0x2, 0x5cf, 0xc5, 0x3, 0x2, 0x2, 
			 0x2, 0x5d0, 0x5d2, 0x7, 0x2d, 0x2, 0x2, 0x5d1, 0x5d0, 0x3, 0x2, 0x2, 
			 0x2, 0x5d1, 0x5d2, 0x3, 0x2, 0x2, 0x2, 0x5d2, 0x5d3, 0x3, 0x2, 0x2, 
			 0x2, 0x5d3, 0x5d4, 0x7, 0x31, 0x2, 0x2, 0x5d4, 0x5d5, 0x7, 0x5a, 0x2, 
			 0x2, 0x5d5, 0x5d6, 0x5, 0xc8, 0x65, 0x2, 0x5d6, 0x5d7, 0x7, 0x5b, 0x2, 
			 0x2, 0x5d7, 0xc7, 0x3, 0x2, 0x2, 0x2, 0x5d8, 0x5da, 0x5, 0x7c, 0x3f, 
			 0x2, 0x5d9, 0x5d8, 0x3, 0x2, 0x2, 0x2, 0x5d9, 0x5da, 0x3, 0x2, 0x2, 
			 0x2, 0x5da, 0xc9, 0x3, 0x2, 0x2, 0x2, 0x5db, 0x5dc, 0x7, 0x84, 0x2, 
			 0x2, 0x5dc, 0xcb, 0x3, 0x2, 0x2, 0x2, 0x5dd, 0x5de, 0x7, 0x31, 0x2, 
			 0x2, 0x5de, 0x5df, 0x7, 0x84, 0x2, 0x2, 0x5df, 0x5e0, 0x7, 0x66, 0x2, 
			 0x2, 0x5e0, 0x5e1, 0x5, 0xce, 0x68, 0x2, 0x5e1, 0x5e2, 0x7, 0x80, 0x2, 
			 0x2, 0x5e2, 0xcd, 0x3, 0x2, 0x2, 0x2, 0x5e3, 0x5e5, 0x5, 0xc, 0x7, 0x2, 
			 0x5e4, 0x5e3, 0x3, 0x2, 0x2, 0x2, 0x5e4, 0x5e5, 0x3, 0x2, 0x2, 0x2, 
			 0x5e5, 0x5e6, 0x3, 0x2, 0x2, 0x2, 0x5e6, 0x5e7, 0x5, 0xba, 0x5e, 0x2, 
			 0x5e7, 0xcf, 0x3, 0x2, 0x2, 0x2, 0x5e8, 0x5ea, 0x7, 0x50, 0x2, 0x2, 
			 0x5e9, 0x5eb, 0x7, 0x4d, 0x2, 0x2, 0x5ea, 0x5e9, 0x3, 0x2, 0x2, 0x2, 
			 0x5ea, 0x5eb, 0x3, 0x2, 0x2, 0x2, 0x5eb, 0x5ec, 0x3, 0x2, 0x2, 0x2, 
			 0x5ec, 0x5ed, 0x5, 0xc, 0x7, 0x2, 0x5ed, 0x5ee, 0x5, 0x8, 0x5, 0x2, 
			 0x5ee, 0x5ef, 0x7, 0x80, 0x2, 0x2, 0x5ef, 0x5f6, 0x3, 0x2, 0x2, 0x2, 
			 0x5f0, 0x5f1, 0x7, 0x50, 0x2, 0x2, 0x5f1, 0x5f2, 0x7, 0x7f, 0x2, 0x2, 
			 0x5f2, 0x5f3, 0x5, 0x8, 0x5, 0x2, 0x5f3, 0x5f4, 0x7, 0x80, 0x2, 0x2, 
			 0x5f4, 0x5f6, 0x3, 0x2, 0x2, 0x2, 0x5f5, 0x5e8, 0x3, 0x2, 0x2, 0x2, 
			 0x5f5, 0x5f0, 0x3, 0x2, 0x2, 0x2, 0x5f6, 0xd1, 0x3, 0x2, 0x2, 0x2, 0x5f7, 
			 0x5f9, 0x5, 0xd8, 0x6d, 0x2, 0x5f8, 0x5f7, 0x3, 0x2, 0x2, 0x2, 0x5f8, 
			 0x5f9, 0x3, 0x2, 0x2, 0x2, 0x5f9, 0x5fa, 0x3, 0x2, 0x2, 0x2, 0x5fa, 
			 0x5fb, 0x7, 0x50, 0x2, 0x2, 0x5fb, 0x5fd, 0x7, 0x31, 0x2, 0x2, 0x5fc, 
			 0x5fe, 0x5, 0xc, 0x7, 0x2, 0x5fd, 0x5fc, 0x3, 0x2, 0x2, 0x2, 0x5fd, 
			 0x5fe, 0x3, 0x2, 0x2, 0x2, 0x5fe, 0x5ff, 0x3, 0x2, 0x2, 0x2, 0x5ff, 
			 0x600, 0x5, 0xba, 0x5e, 0x2, 0x600, 0x601, 0x7, 0x80, 0x2, 0x2, 0x601, 
			 0xd3, 0x3, 0x2, 0x2, 0x2, 0x602, 0x603, 0x7, 0xd, 0x2, 0x2, 0x603, 0x604, 
			 0x7, 0x56, 0x2, 0x2, 0x604, 0x605, 0x7, 0x8d, 0x2, 0x2, 0x605, 0x606, 
			 0x7, 0x57, 0x2, 0x2, 0x606, 0x607, 0x7, 0x80, 0x2, 0x2, 0x607, 0xd5, 
			 0x3, 0x2, 0x2, 0x2, 0x608, 0x609, 0x7, 0x25, 0x2, 0x2, 0x609, 0x60a, 
			 0x7, 0x8d, 0x2, 0x2, 0x60a, 0x60c, 0x7, 0x5a, 0x2, 0x2, 0x60b, 0x60d, 
			 0x5, 0x7c, 0x3f, 0x2, 0x60c, 0x60b, 0x3, 0x2, 0x2, 0x2, 0x60c, 0x60d, 
			 0x3, 0x2, 0x2, 0x2, 0x60d, 0x60e, 0x3, 0x2, 0x2, 0x2, 0x60e, 0x613, 
			 0x7, 0x5b, 0x2, 0x2, 0x60f, 0x610, 0x7, 0x25, 0x2, 0x2, 0x610, 0x611, 
			 0x7, 0x8d, 0x2, 0x2, 0x611, 0x613, 0x5, 0x7e, 0x40, 0x2, 0x612, 0x608, 
			 0x3, 0x2, 0x2, 0x2, 0x612, 0x60f, 0x3, 0x2, 0x2, 0x2, 0x613, 0xd7, 0x3, 
			 0x2, 0x2, 0x2, 0x614, 0x615, 0x8, 0x6d, 0x1, 0x2, 0x615, 0x616, 0x5, 
			 0xda, 0x6e, 0x2, 0x616, 0x61b, 0x3, 0x2, 0x2, 0x2, 0x617, 0x618, 0xc, 
			 0x3, 0x2, 0x2, 0x618, 0x61a, 0x5, 0xda, 0x6e, 0x2, 0x619, 0x617, 0x3, 
			 0x2, 0x2, 0x2, 0x61a, 0x61d, 0x3, 0x2, 0x2, 0x2, 0x61b, 0x619, 0x3, 
			 0x2, 0x2, 0x2, 0x61b, 0x61c, 0x3, 0x2, 0x2, 0x2, 0x61c, 0xd9, 0x3, 0x2, 
			 0x2, 0x2, 0x61d, 0x61b, 0x3, 0x2, 0x2, 0x2, 0x61e, 0x61f, 0x7, 0x58, 
			 0x2, 0x2, 0x61f, 0x620, 0x7, 0x58, 0x2, 0x2, 0x620, 0x621, 0x5, 0xde, 
			 0x70, 0x2, 0x621, 0x622, 0x7, 0x59, 0x2, 0x2, 0x622, 0x623, 0x7, 0x59, 
			 0x2, 0x2, 0x623, 0x626, 0x3, 0x2, 0x2, 0x2, 0x624, 0x626, 0x5, 0xdc, 
			 0x6f, 0x2, 0x625, 0x61e, 0x3, 0x2, 0x2, 0x2, 0x625, 0x624, 0x3, 0x2, 
			 0x2, 0x2, 0x626, 0xdb, 0x3, 0x2, 0x2, 0x2, 0x627, 0x628, 0x7, 0xb, 0x2, 
			 0x2, 0x628, 0x629, 0x7, 0x56, 0x2, 0x2, 0x629, 0x62b, 0x5, 0x106, 0x84, 
			 0x2, 0x62a, 0x62c, 0x7, 0x83, 0x2, 0x2, 0x62b, 0x62a, 0x3, 0x2, 0x2, 
			 0x2, 0x62b, 0x62c, 0x3, 0x2, 0x2, 0x2, 0x62c, 0x62d, 0x3, 0x2, 0x2, 
			 0x2, 0x62d, 0x62e, 0x7, 0x57, 0x2, 0x2, 0x62e, 0x638, 0x3, 0x2, 0x2, 
			 0x2, 0x62f, 0x630, 0x7, 0xb, 0x2, 0x2, 0x630, 0x631, 0x7, 0x56, 0x2, 
			 0x2, 0x631, 0x633, 0x5, 0x60, 0x31, 0x2, 0x632, 0x634, 0x7, 0x83, 0x2, 
			 0x2, 0x633, 0x632, 0x3, 0x2, 0x2, 0x2, 0x633, 0x634, 0x3, 0x2, 0x2, 
			 0x2, 0x634, 0x635, 0x3, 0x2, 0x2, 0x2, 0x635, 0x636, 0x7, 0x57, 0x2, 
			 0x2, 0x636, 0x638, 0x3, 0x2, 0x2, 0x2, 0x637, 0x627, 0x3, 0x2, 0x2, 
			 0x2, 0x637, 0x62f, 0x3, 0x2, 0x2, 0x2, 0x638, 0xdd, 0x3, 0x2, 0x2, 0x2, 
			 0x639, 0x63b, 0x8, 0x70, 0x1, 0x2, 0x63a, 0x63c, 0x5, 0xe0, 0x71, 0x2, 
			 0x63b, 0x63a, 0x3, 0x2, 0x2, 0x2, 0x63b, 0x63c, 0x3, 0x2, 0x2, 0x2, 
			 0x63c, 0x641, 0x3, 0x2, 0x2, 0x2, 0x63d, 0x63e, 0x5, 0xe0, 0x71, 0x2, 
			 0x63e, 0x63f, 0x7, 0x83, 0x2, 0x2, 0x63f, 0x641, 0x3, 0x2, 0x2, 0x2, 
			 0x640, 0x639, 0x3, 0x2, 0x2, 0x2, 0x640, 0x63d, 0x3, 0x2, 0x2, 0x2, 
			 0x641, 0x64e, 0x3, 0x2, 0x2, 0x2, 0x642, 0x643, 0xc, 0x5, 0x2, 0x2, 
			 0x643, 0x645, 0x7, 0x7a, 0x2, 0x2, 0x644, 0x646, 0x5, 0xe0, 0x71, 0x2, 
			 0x645, 0x644, 0x3, 0x2, 0x2, 0x2, 0x645, 0x646, 0x3, 0x2, 0x2, 0x2, 
			 0x646, 0x64d, 0x3, 0x2, 0x2, 0x2, 0x647, 0x648, 0xc, 0x3, 0x2, 0x2, 
			 0x648, 0x649, 0x7, 0x7a, 0x2, 0x2, 0x649, 0x64a, 0x5, 0xe0, 0x71, 0x2, 
			 0x64a, 0x64b, 0x7, 0x83, 0x2, 0x2, 0x64b, 0x64d, 0x3, 0x2, 0x2, 0x2, 
			 0x64c, 0x642, 0x3, 0x2, 0x2, 0x2, 0x64c, 0x647, 0x3, 0x2, 0x2, 0x2, 
			 0x64d, 0x650, 0x3, 0x2, 0x2, 0x2, 0x64e, 0x64c, 0x3, 0x2, 0x2, 0x2, 
			 0x64e, 0x64f, 0x3, 0x2, 0x2, 0x2, 0x64f, 0xdf, 0x3, 0x2, 0x2, 0x2, 0x650, 
			 0x64e, 0x3, 0x2, 0x2, 0x2, 0x651, 0x653, 0x5, 0xe2, 0x72, 0x2, 0x652, 
			 0x654, 0x5, 0xe8, 0x75, 0x2, 0x653, 0x652, 0x3, 0x2, 0x2, 0x2, 0x653, 
			 0x654, 0x3, 0x2, 0x2, 0x2, 0x654, 0xe1, 0x3, 0x2, 0x2, 0x2, 0x655, 0x658, 
			 0x7, 0x84, 0x2, 0x2, 0x656, 0x658, 0x5, 0xe4, 0x73, 0x2, 0x657, 0x655, 
			 0x3, 0x2, 0x2, 0x2, 0x657, 0x656, 0x3, 0x2, 0x2, 0x2, 0x658, 0xe3, 0x3, 
			 0x2, 0x2, 0x2, 0x659, 0x65a, 0x5, 0xe6, 0x74, 0x2, 0x65a, 0x65b, 0x7, 
			 0x7f, 0x2, 0x2, 0x65b, 0x65c, 0x7, 0x84, 0x2, 0x2, 0x65c, 0xe5, 0x3, 
			 0x2, 0x2, 0x2, 0x65d, 0x65e, 0x7, 0x84, 0x2, 0x2, 0x65e, 0xe7, 0x3, 
			 0x2, 0x2, 0x2, 0x65f, 0x660, 0x7, 0x56, 0x2, 0x2, 0x660, 0x661, 0x5, 
			 0xea, 0x76, 0x2, 0x661, 0x662, 0x7, 0x57, 0x2, 0x2, 0x662, 0xe9, 0x3, 
			 0x2, 0x2, 0x2, 0x663, 0x665, 0x8, 0x76, 0x1, 0x2, 0x664, 0x666, 0x5, 
			 0xec, 0x77, 0x2, 0x665, 0x664, 0x3, 0x2, 0x2, 0x2, 0x665, 0x666, 0x3, 
			 0x2, 0x2, 0x2, 0x666, 0x66b, 0x3, 0x2, 0x2, 0x2, 0x667, 0x668, 0xc, 
			 0x3, 0x2, 0x2, 0x668, 0x66a, 0x5, 0xec, 0x77, 0x2, 0x669, 0x667, 0x3, 
			 0x2, 0x2, 0x2, 0x66a, 0x66d, 0x3, 0x2, 0x2, 0x2, 0x66b, 0x669, 0x3, 
			 0x2, 0x2, 0x2, 0x66b, 0x66c, 0x3, 0x2, 0x2, 0x2, 0x66c, 0xeb, 0x3, 0x2, 
			 0x2, 0x2, 0x66d, 0x66b, 0x3, 0x2, 0x2, 0x2, 0x66e, 0x66f, 0x7, 0x56, 
			 0x2, 0x2, 0x66f, 0x670, 0x5, 0xea, 0x76, 0x2, 0x670, 0x671, 0x7, 0x57, 
			 0x2, 0x2, 0x671, 0x680, 0x3, 0x2, 0x2, 0x2, 0x672, 0x673, 0x7, 0x58, 
			 0x2, 0x2, 0x673, 0x674, 0x5, 0xea, 0x76, 0x2, 0x674, 0x675, 0x7, 0x59, 
			 0x2, 0x2, 0x675, 0x680, 0x3, 0x2, 0x2, 0x2, 0x676, 0x677, 0x7, 0x5a, 
			 0x2, 0x2, 0x677, 0x678, 0x5, 0xea, 0x76, 0x2, 0x678, 0x679, 0x7, 0x5b, 
			 0x2, 0x2, 0x679, 0x680, 0x3, 0x2, 0x2, 0x2, 0x67a, 0x67c, 0xa, 0x7, 
			 0x2, 0x2, 0x67b, 0x67a, 0x3, 0x2, 0x2, 0x2, 0x67c, 0x67d, 0x3, 0x2, 
			 0x2, 0x2, 0x67d, 0x67b, 0x3, 0x2, 0x2, 0x2, 0x67d, 0x67e, 0x3, 0x2, 
			 0x2, 0x2, 0x67e, 0x680, 0x3, 0x2, 0x2, 0x2, 0x67f, 0x66e, 0x3, 0x2, 
			 0x2, 0x2, 0x67f, 0x672, 0x3, 0x2, 0x2, 0x2, 0x67f, 0x676, 0x3, 0x2, 
			 0x2, 0x2, 0x67f, 0x67b, 0x3, 0x2, 0x2, 0x2, 0x680, 0xed, 0x3, 0x2, 0x2, 
			 0x2, 0x681, 0x682, 0x8, 0x78, 0x1, 0x2, 0x682, 0x683, 0x5, 0xf0, 0x79, 
			 0x2, 0x683, 0x689, 0x3, 0x2, 0x2, 0x2, 0x684, 0x685, 0xc, 0x3, 0x2, 
			 0x2, 0x685, 0x686, 0x7, 0x7a, 0x2, 0x2, 0x686, 0x688, 0x5, 0xf0, 0x79, 
			 0x2, 0x687, 0x684, 0x3, 0x2, 0x2, 0x2, 0x688, 0x68b, 0x3, 0x2, 0x2, 
			 0x2, 0x689, 0x687, 0x3, 0x2, 0x2, 0x2, 0x689, 0x68a, 0x3, 0x2, 0x2, 
			 0x2, 0x68a, 0xef, 0x3, 0x2, 0x2, 0x2, 0x68b, 0x689, 0x3, 0x2, 0x2, 0x2, 
			 0x68c, 0x68e, 0x5, 0xf2, 0x7a, 0x2, 0x68d, 0x68f, 0x5, 0x11c, 0x8f, 
			 0x2, 0x68e, 0x68d, 0x3, 0x2, 0x2, 0x2, 0x68e, 0x68f, 0x3, 0x2, 0x2, 
			 0x2, 0x68f, 0xf1, 0x3, 0x2, 0x2, 0x2, 0x690, 0x696, 0x5, 0xf4, 0x7b, 
			 0x2, 0x691, 0x692, 0x5, 0xf6, 0x7c, 0x2, 0x692, 0x693, 0x5, 0xf8, 0x7d, 
			 0x2, 0x693, 0x694, 0x5, 0xfa, 0x7e, 0x2, 0x694, 0x696, 0x3, 0x2, 0x2, 
			 0x2, 0x695, 0x690, 0x3, 0x2, 0x2, 0x2, 0x695, 0x691, 0x3, 0x2, 0x2, 
			 0x2, 0x696, 0xf3, 0x3, 0x2, 0x2, 0x2, 0x697, 0x69c, 0x5, 0xf6, 0x7c, 
			 0x2, 0x698, 0x699, 0x5, 0xfc, 0x7f, 0x2, 0x699, 0x69a, 0x5, 0xf4, 0x7b, 
			 0x2, 0x69a, 0x69c, 0x3, 0x2, 0x2, 0x2, 0x69b, 0x697, 0x3, 0x2, 0x2, 
			 0x2, 0x69b, 0x698, 0x3, 0x2, 0x2, 0x2, 0x69c, 0xf5, 0x3, 0x2, 0x2, 0x2, 
			 0x69d, 0x69e, 0x8, 0x7c, 0x1, 0x2, 0x69e, 0x6a0, 0x5, 0x104, 0x83, 0x2, 
			 0x69f, 0x6a1, 0x5, 0xd8, 0x6d, 0x2, 0x6a0, 0x69f, 0x3, 0x2, 0x2, 0x2, 
			 0x6a0, 0x6a1, 0x3, 0x2, 0x2, 0x2, 0x6a1, 0x6a7, 0x3, 0x2, 0x2, 0x2, 
			 0x6a2, 0x6a3, 0x7, 0x56, 0x2, 0x2, 0x6a3, 0x6a4, 0x5, 0xf4, 0x7b, 0x2, 
			 0x6a4, 0x6a5, 0x7, 0x57, 0x2, 0x2, 0x6a5, 0x6a7, 0x3, 0x2, 0x2, 0x2, 
			 0x6a6, 0x69d, 0x3, 0x2, 0x2, 0x2, 0x6a6, 0x6a2, 0x3, 0x2, 0x2, 0x2, 
			 0x6a7, 0x6b5, 0x3, 0x2, 0x2, 0x2, 0x6a8, 0x6a9, 0xc, 0x5, 0x2, 0x2, 
			 0x6a9, 0x6b4, 0x5, 0xf8, 0x7d, 0x2, 0x6aa, 0x6ab, 0xc, 0x4, 0x2, 0x2, 
			 0x6ab, 0x6ad, 0x7, 0x58, 0x2, 0x2, 0x6ac, 0x6ae, 0x5, 0x60, 0x31, 0x2, 
			 0x6ad, 0x6ac, 0x3, 0x2, 0x2, 0x2, 0x6ad, 0x6ae, 0x3, 0x2, 0x2, 0x2, 
			 0x6ae, 0x6af, 0x3, 0x2, 0x2, 0x2, 0x6af, 0x6b1, 0x7, 0x59, 0x2, 0x2, 
			 0x6b0, 0x6b2, 0x5, 0xd8, 0x6d, 0x2, 0x6b1, 0x6b0, 0x3, 0x2, 0x2, 0x2, 
			 0x6b1, 0x6b2, 0x3, 0x2, 0x2, 0x2, 0x6b2, 0x6b4, 0x3, 0x2, 0x2, 0x2, 
			 0x6b3, 0x6a8, 0x3, 0x2, 0x2, 0x2, 0x6b3, 0x6aa, 0x3, 0x2, 0x2, 0x2, 
			 0x6b4, 0x6b7, 0x3, 0x2, 0x2, 0x2, 0x6b5, 0x6b3, 0x3, 0x2, 0x2, 0x2, 
			 0x6b5, 0x6b6, 0x3, 0x2, 0x2, 0x2, 0x6b6, 0xf7, 0x3, 0x2, 0x2, 0x2, 0x6b7, 
			 0x6b5, 0x3, 0x2, 0x2, 0x2, 0x6b8, 0x6b9, 0x7, 0x56, 0x2, 0x2, 0x6b9, 
			 0x6ba, 0x5, 0x112, 0x8a, 0x2, 0x6ba, 0x6bc, 0x7, 0x57, 0x2, 0x2, 0x6bb, 
			 0x6bd, 0x5, 0xfe, 0x80, 0x2, 0x6bc, 0x6bb, 0x3, 0x2, 0x2, 0x2, 0x6bc, 
			 0x6bd, 0x3, 0x2, 0x2, 0x2, 0x6bd, 0x6bf, 0x3, 0x2, 0x2, 0x2, 0x6be, 
			 0x6c0, 0x5, 0x102, 0x82, 0x2, 0x6bf, 0x6be, 0x3, 0x2, 0x2, 0x2, 0x6bf, 
			 0x6c0, 0x3, 0x2, 0x2, 0x2, 0x6c0, 0x6c2, 0x3, 0x2, 0x2, 0x2, 0x6c1, 
			 0x6c3, 0x5, 0x182, 0xc2, 0x2, 0x6c2, 0x6c1, 0x3, 0x2, 0x2, 0x2, 0x6c2, 
			 0x6c3, 0x3, 0x2, 0x2, 0x2, 0x6c3, 0x6c5, 0x3, 0x2, 0x2, 0x2, 0x6c4, 
			 0x6c6, 0x5, 0xd8, 0x6d, 0x2, 0x6c5, 0x6c4, 0x3, 0x2, 0x2, 0x2, 0x6c5, 
			 0x6c6, 0x3, 0x2, 0x2, 0x2, 0x6c6, 0xf9, 0x3, 0x2, 0x2, 0x2, 0x6c7, 0x6c8, 
			 0x7, 0x7c, 0x2, 0x2, 0x6c8, 0x6ca, 0x5, 0x9e, 0x50, 0x2, 0x6c9, 0x6cb, 
			 0x5, 0x108, 0x85, 0x2, 0x6ca, 0x6c9, 0x3, 0x2, 0x2, 0x2, 0x6ca, 0x6cb, 
			 0x3, 0x2, 0x2, 0x2, 0x6cb, 0xfb, 0x3, 0x2, 0x2, 0x2, 0x6cc, 0x6ce, 0x7, 
			 0x5e, 0x2, 0x2, 0x6cd, 0x6cf, 0x5, 0xd8, 0x6d, 0x2, 0x6ce, 0x6cd, 0x3, 
			 0x2, 0x2, 0x2, 0x6ce, 0x6cf, 0x3, 0x2, 0x2, 0x2, 0x6cf, 0x6d1, 0x3, 
			 0x2, 0x2, 0x2, 0x6d0, 0x6d2, 0x5, 0xfe, 0x80, 0x2, 0x6d1, 0x6d0, 0x3, 
			 0x2, 0x2, 0x2, 0x6d1, 0x6d2, 0x3, 0x2, 0x2, 0x2, 0x6d2, 0x6e4, 0x3, 
			 0x2, 0x2, 0x2, 0x6d3, 0x6d5, 0x7, 0x62, 0x2, 0x2, 0x6d4, 0x6d6, 0x5, 
			 0xd8, 0x6d, 0x2, 0x6d5, 0x6d4, 0x3, 0x2, 0x2, 0x2, 0x6d5, 0x6d6, 0x3, 
			 0x2, 0x2, 0x2, 0x6d6, 0x6e4, 0x3, 0x2, 0x2, 0x2, 0x6d7, 0x6d9, 0x7, 
			 0x5, 0x2, 0x2, 0x6d8, 0x6da, 0x5, 0xd8, 0x6d, 0x2, 0x6d9, 0x6d8, 0x3, 
			 0x2, 0x2, 0x2, 0x6d9, 0x6da, 0x3, 0x2, 0x2, 0x2, 0x6da, 0x6e4, 0x3, 
			 0x2, 0x2, 0x2, 0x6db, 0x6dc, 0x5, 0xc, 0x7, 0x2, 0x6dc, 0x6de, 0x7, 
			 0x5e, 0x2, 0x2, 0x6dd, 0x6df, 0x5, 0xd8, 0x6d, 0x2, 0x6de, 0x6dd, 0x3, 
			 0x2, 0x2, 0x2, 0x6de, 0x6df, 0x3, 0x2, 0x2, 0x2, 0x6df, 0x6e1, 0x3, 
			 0x2, 0x2, 0x2, 0x6e0, 0x6e2, 0x5, 0xfe, 0x80, 0x2, 0x6e1, 0x6e0, 0x3, 
			 0x2, 0x2, 0x2, 0x6e1, 0x6e2, 0x3, 0x2, 0x2, 0x2, 0x6e2, 0x6e4, 0x3, 
			 0x2, 0x2, 0x2, 0x6e3, 0x6cc, 0x3, 0x2, 0x2, 0x2, 0x6e3, 0x6d3, 0x3, 
			 0x2, 0x2, 0x2, 0x6e3, 0x6d7, 0x3, 0x2, 0x2, 0x2, 0x6e3, 0x6db, 0x3, 
			 0x2, 0x2, 0x2, 0x6e4, 0xfd, 0x3, 0x2, 0x2, 0x2, 0x6e5, 0x6e7, 0x5, 0x100, 
			 0x81, 0x2, 0x6e6, 0x6e8, 0x5, 0xfe, 0x80, 0x2, 0x6e7, 0x6e6, 0x3, 0x2, 
			 0x2, 0x2, 0x6e7, 0x6e8, 0x3, 0x2, 0x2, 0x2, 0x6e8, 0xff, 0x3, 0x2, 0x2, 
			 0x2, 0x6e9, 0x6ea, 0x9, 0x8, 0x2, 0x2, 0x6ea, 0x101, 0x3, 0x2, 0x2, 
			 0x2, 0x6eb, 0x6ec, 0x9, 0x9, 0x2, 0x2, 0x6ec, 0x103, 0x3, 0x2, 0x2, 
			 0x2, 0x6ed, 0x6ef, 0x7, 0x83, 0x2, 0x2, 0x6ee, 0x6ed, 0x3, 0x2, 0x2, 
			 0x2, 0x6ee, 0x6ef, 0x3, 0x2, 0x2, 0x2, 0x6ef, 0x6f0, 0x3, 0x2, 0x2, 
			 0x2, 0x6f0, 0x6f1, 0x5, 0x6, 0x4, 0x2, 0x6f1, 0x105, 0x3, 0x2, 0x2, 
			 0x2, 0x6f2, 0x6f4, 0x5, 0x9c, 0x4f, 0x2, 0x6f3, 0x6f5, 0x5, 0x108, 0x85, 
			 0x2, 0x6f4, 0x6f3, 0x3, 0x2, 0x2, 0x2, 0x6f4, 0x6f5, 0x3, 0x2, 0x2, 
			 0x2, 0x6f5, 0x107, 0x3, 0x2, 0x2, 0x2, 0x6f6, 0x6ff, 0x5, 0x10a, 0x86, 
			 0x2, 0x6f7, 0x6f9, 0x5, 0x10c, 0x87, 0x2, 0x6f8, 0x6f7, 0x3, 0x2, 0x2, 
			 0x2, 0x6f8, 0x6f9, 0x3, 0x2, 0x2, 0x2, 0x6f9, 0x6fa, 0x3, 0x2, 0x2, 
			 0x2, 0x6fa, 0x6fb, 0x5, 0xf8, 0x7d, 0x2, 0x6fb, 0x6fc, 0x5, 0xfa, 0x7e, 
			 0x2, 0x6fc, 0x6ff, 0x3, 0x2, 0x2, 0x2, 0x6fd, 0x6ff, 0x5, 0x10e, 0x88, 
			 0x2, 0x6fe, 0x6f6, 0x3, 0x2, 0x2, 0x2, 0x6fe, 0x6f8, 0x3, 0x2, 0x2, 
			 0x2, 0x6fe, 0x6fd, 0x3, 0x2, 0x2, 0x2, 0x6ff, 0x109, 0x3, 0x2, 0x2, 
			 0x2, 0x700, 0x706, 0x5, 0x10c, 0x87, 0x2, 0x701, 0x703, 0x5, 0xfc, 0x7f, 
			 0x2, 0x702, 0x704, 0x5, 0x10a, 0x86, 0x2, 0x703, 0x702, 0x3, 0x2, 0x2, 
			 0x2, 0x703, 0x704, 0x3, 0x2, 0x2, 0x2, 0x704, 0x706, 0x3, 0x2, 0x2, 
			 0x2, 0x705, 0x700, 0x3, 0x2, 0x2, 0x2, 0x705, 0x701, 0x3, 0x2, 0x2, 
			 0x2, 0x706, 0x10b, 0x3, 0x2, 0x2, 0x2, 0x707, 0x708, 0x8, 0x87, 0x1, 
			 0x2, 0x708, 0x716, 0x5, 0xf8, 0x7d, 0x2, 0x709, 0x70b, 0x7, 0x58, 0x2, 
			 0x2, 0x70a, 0x70c, 0x5, 0x60, 0x31, 0x2, 0x70b, 0x70a, 0x3, 0x2, 0x2, 
			 0x2, 0x70b, 0x70c, 0x3, 0x2, 0x2, 0x2, 0x70c, 0x70d, 0x3, 0x2, 0x2, 
			 0x2, 0x70d, 0x70f, 0x7, 0x59, 0x2, 0x2, 0x70e, 0x710, 0x5, 0xd8, 0x6d, 
			 0x2, 0x70f, 0x70e, 0x3, 0x2, 0x2, 0x2, 0x70f, 0x710, 0x3, 0x2, 0x2, 
			 0x2, 0x710, 0x716, 0x3, 0x2, 0x2, 0x2, 0x711, 0x712, 0x7, 0x56, 0x2, 
			 0x2, 0x712, 0x713, 0x5, 0x10a, 0x86, 0x2, 0x713, 0x714, 0x7, 0x57, 0x2, 
			 0x2, 0x714, 0x716, 0x3, 0x2, 0x2, 0x2, 0x715, 0x707, 0x3, 0x2, 0x2, 
			 0x2, 0x715, 0x709, 0x3, 0x2, 0x2, 0x2, 0x715, 0x711, 0x3, 0x2, 0x2, 
			 0x2, 0x716, 0x724, 0x3, 0x2, 0x2, 0x2, 0x717, 0x718, 0xc, 0x7, 0x2, 
			 0x2, 0x718, 0x723, 0x5, 0xf8, 0x7d, 0x2, 0x719, 0x71a, 0xc, 0x5, 0x2, 
			 0x2, 0x71a, 0x71c, 0x7, 0x58, 0x2, 0x2, 0x71b, 0x71d, 0x5, 0x60, 0x31, 
			 0x2, 0x71c, 0x71b, 0x3, 0x2, 0x2, 0x2, 0x71c, 0x71d, 0x3, 0x2, 0x2, 
			 0x2, 0x71d, 0x71e, 0x3, 0x2, 0x2, 0x2, 0x71e, 0x720, 0x7, 0x59, 0x2, 
			 0x2, 0x71f, 0x721, 0x5, 0xd8, 0x6d, 0x2, 0x720, 0x71f, 0x3, 0x2, 0x2, 
			 0x2, 0x720, 0x721, 0x3, 0x2, 0x2, 0x2, 0x721, 0x723, 0x3, 0x2, 0x2, 
			 0x2, 0x722, 0x717, 0x3, 0x2, 0x2, 0x2, 0x722, 0x719, 0x3, 0x2, 0x2, 
			 0x2, 0x723, 0x726, 0x3, 0x2, 0x2, 0x2, 0x724, 0x722, 0x3, 0x2, 0x2, 
			 0x2, 0x724, 0x725, 0x3, 0x2, 0x2, 0x2, 0x725, 0x10d, 0x3, 0x2, 0x2, 
			 0x2, 0x726, 0x724, 0x3, 0x2, 0x2, 0x2, 0x727, 0x72c, 0x5, 0x110, 0x89, 
			 0x2, 0x728, 0x729, 0x5, 0xfc, 0x7f, 0x2, 0x729, 0x72a, 0x5, 0x10e, 0x88, 
			 0x2, 0x72a, 0x72c, 0x3, 0x2, 0x2, 0x2, 0x72b, 0x727, 0x3, 0x2, 0x2, 
			 0x2, 0x72b, 0x728, 0x3, 0x2, 0x2, 0x2, 0x72c, 0x10f, 0x3, 0x2, 0x2, 
			 0x2, 0x72d, 0x72e, 0x8, 0x89, 0x1, 0x2, 0x72e, 0x72f, 0x7, 0x83, 0x2, 
			 0x2, 0x72f, 0x73d, 0x3, 0x2, 0x2, 0x2, 0x730, 0x731, 0xc, 0x5, 0x2, 
			 0x2, 0x731, 0x73c, 0x5, 0xf8, 0x7d, 0x2, 0x732, 0x733, 0xc, 0x4, 0x2, 
			 0x2, 0x733, 0x735, 0x7, 0x58, 0x2, 0x2, 0x734, 0x736, 0x5, 0x60, 0x31, 
			 0x2, 0x735, 0x734, 0x3, 0x2, 0x2, 0x2, 0x735, 0x736, 0x3, 0x2, 0x2, 
			 0x2, 0x736, 0x737, 0x3, 0x2, 0x2, 0x2, 0x737, 0x739, 0x7, 0x59, 0x2, 
			 0x2, 0x738, 0x73a, 0x5, 0xd8, 0x6d, 0x2, 0x739, 0x738, 0x3, 0x2, 0x2, 
			 0x2, 0x739, 0x73a, 0x3, 0x2, 0x2, 0x2, 0x73a, 0x73c, 0x3, 0x2, 0x2, 
			 0x2, 0x73b, 0x730, 0x3, 0x2, 0x2, 0x2, 0x73b, 0x732, 0x3, 0x2, 0x2, 
			 0x2, 0x73c, 0x73f, 0x3, 0x2, 0x2, 0x2, 0x73d, 0x73b, 0x3, 0x2, 0x2, 
			 0x2, 0x73d, 0x73e, 0x3, 0x2, 0x2, 0x2, 0x73e, 0x111, 0x3, 0x2, 0x2, 
			 0x2, 0x73f, 0x73d, 0x3, 0x2, 0x2, 0x2, 0x740, 0x742, 0x5, 0x114, 0x8b, 
			 0x2, 0x741, 0x740, 0x3, 0x2, 0x2, 0x2, 0x741, 0x742, 0x3, 0x2, 0x2, 
			 0x2, 0x742, 0x744, 0x3, 0x2, 0x2, 0x2, 0x743, 0x745, 0x7, 0x83, 0x2, 
			 0x2, 0x744, 0x743, 0x3, 0x2, 0x2, 0x2, 0x744, 0x745, 0x3, 0x2, 0x2, 
			 0x2, 0x745, 0x74b, 0x3, 0x2, 0x2, 0x2, 0x746, 0x747, 0x5, 0x114, 0x8b, 
			 0x2, 0x747, 0x748, 0x7, 0x7a, 0x2, 0x2, 0x748, 0x749, 0x7, 0x83, 0x2, 
			 0x2, 0x749, 0x74b, 0x3, 0x2, 0x2, 0x2, 0x74a, 0x741, 0x3, 0x2, 0x2, 
			 0x2, 0x74a, 0x746, 0x3, 0x2, 0x2, 0x2, 0x74b, 0x113, 0x3, 0x2, 0x2, 
			 0x2, 0x74c, 0x74d, 0x8, 0x8b, 0x1, 0x2, 0x74d, 0x74e, 0x5, 0x116, 0x8c, 
			 0x2, 0x74e, 0x754, 0x3, 0x2, 0x2, 0x2, 0x74f, 0x750, 0xc, 0x3, 0x2, 
			 0x2, 0x750, 0x751, 0x7, 0x7a, 0x2, 0x2, 0x751, 0x753, 0x5, 0x116, 0x8c, 
			 0x2, 0x752, 0x74f, 0x3, 0x2, 0x2, 0x2, 0x753, 0x756, 0x3, 0x2, 0x2, 
			 0x2, 0x754, 0x752, 0x3, 0x2, 0x2, 0x2, 0x754, 0x755, 0x3, 0x2, 0x2, 
			 0x2, 0x755, 0x115, 0x3, 0x2, 0x2, 0x2, 0x756, 0x754, 0x3, 0x2, 0x2, 
			 0x2, 0x757, 0x759, 0x5, 0xd8, 0x6d, 0x2, 0x758, 0x757, 0x3, 0x2, 0x2, 
			 0x2, 0x758, 0x759, 0x3, 0x2, 0x2, 0x2, 0x759, 0x75a, 0x3, 0x2, 0x2, 
			 0x2, 0x75a, 0x75b, 0x5, 0x90, 0x49, 0x2, 0x75b, 0x75d, 0x5, 0xf2, 0x7a, 
			 0x2, 0x75c, 0x75e, 0x5, 0x8, 0x5, 0x2, 0x75d, 0x75c, 0x3, 0x2, 0x2, 
			 0x2, 0x75d, 0x75e, 0x3, 0x2, 0x2, 0x2, 0x75e, 0x782, 0x3, 0x2, 0x2, 
			 0x2, 0x75f, 0x761, 0x5, 0xd8, 0x6d, 0x2, 0x760, 0x75f, 0x3, 0x2, 0x2, 
			 0x2, 0x760, 0x761, 0x3, 0x2, 0x2, 0x2, 0x761, 0x762, 0x3, 0x2, 0x2, 
			 0x2, 0x762, 0x763, 0x5, 0x90, 0x49, 0x2, 0x763, 0x765, 0x5, 0xf2, 0x7a, 
			 0x2, 0x764, 0x766, 0x5, 0x8, 0x5, 0x2, 0x765, 0x764, 0x3, 0x2, 0x2, 
			 0x2, 0x765, 0x766, 0x3, 0x2, 0x2, 0x2, 0x766, 0x767, 0x3, 0x2, 0x2, 
			 0x2, 0x767, 0x768, 0x7, 0x66, 0x2, 0x2, 0x768, 0x769, 0x5, 0x120, 0x91, 
			 0x2, 0x769, 0x782, 0x3, 0x2, 0x2, 0x2, 0x76a, 0x76c, 0x5, 0xd8, 0x6d, 
			 0x2, 0x76b, 0x76a, 0x3, 0x2, 0x2, 0x2, 0x76b, 0x76c, 0x3, 0x2, 0x2, 
			 0x2, 0x76c, 0x76d, 0x3, 0x2, 0x2, 0x2, 0x76d, 0x76f, 0x5, 0x90, 0x49, 
			 0x2, 0x76e, 0x770, 0x5, 0x108, 0x85, 0x2, 0x76f, 0x76e, 0x3, 0x2, 0x2, 
			 0x2, 0x76f, 0x770, 0x3, 0x2, 0x2, 0x2, 0x770, 0x772, 0x3, 0x2, 0x2, 
			 0x2, 0x771, 0x773, 0x5, 0x8, 0x5, 0x2, 0x772, 0x771, 0x3, 0x2, 0x2, 
			 0x2, 0x772, 0x773, 0x3, 0x2, 0x2, 0x2, 0x773, 0x782, 0x3, 0x2, 0x2, 
			 0x2, 0x774, 0x776, 0x5, 0xd8, 0x6d, 0x2, 0x775, 0x774, 0x3, 0x2, 0x2, 
			 0x2, 0x775, 0x776, 0x3, 0x2, 0x2, 0x2, 0x776, 0x777, 0x3, 0x2, 0x2, 
			 0x2, 0x777, 0x779, 0x5, 0x90, 0x49, 0x2, 0x778, 0x77a, 0x5, 0x108, 0x85, 
			 0x2, 0x779, 0x778, 0x3, 0x2, 0x2, 0x2, 0x779, 0x77a, 0x3, 0x2, 0x2, 
			 0x2, 0x77a, 0x77c, 0x3, 0x2, 0x2, 0x2, 0x77b, 0x77d, 0x5, 0x8, 0x5, 
			 0x2, 0x77c, 0x77b, 0x3, 0x2, 0x2, 0x2, 0x77c, 0x77d, 0x3, 0x2, 0x2, 
			 0x2, 0x77d, 0x77e, 0x3, 0x2, 0x2, 0x2, 0x77e, 0x77f, 0x7, 0x66, 0x2, 
			 0x2, 0x77f, 0x780, 0x5, 0x120, 0x91, 0x2, 0x780, 0x782, 0x3, 0x2, 0x2, 
			 0x2, 0x781, 0x758, 0x3, 0x2, 0x2, 0x2, 0x781, 0x760, 0x3, 0x2, 0x2, 
			 0x2, 0x781, 0x76b, 0x3, 0x2, 0x2, 0x2, 0x781, 0x775, 0x3, 0x2, 0x2, 
			 0x2, 0x782, 0x117, 0x3, 0x2, 0x2, 0x2, 0x783, 0x785, 0x5, 0xd8, 0x6d, 
			 0x2, 0x784, 0x783, 0x3, 0x2, 0x2, 0x2, 0x784, 0x785, 0x3, 0x2, 0x2, 
			 0x2, 0x785, 0x787, 0x3, 0x2, 0x2, 0x2, 0x786, 0x788, 0x5, 0x90, 0x49, 
			 0x2, 0x787, 0x786, 0x3, 0x2, 0x2, 0x2, 0x787, 0x788, 0x3, 0x2, 0x2, 
			 0x2, 0x788, 0x789, 0x3, 0x2, 0x2, 0x2, 0x789, 0x78b, 0x5, 0xf2, 0x7a, 
			 0x2, 0x78a, 0x78c, 0x5, 0x13a, 0x9e, 0x2, 0x78b, 0x78a, 0x3, 0x2, 0x2, 
			 0x2, 0x78b, 0x78c, 0x3, 0x2, 0x2, 0x2, 0x78c, 0x78d, 0x3, 0x2, 0x2, 
			 0x2, 0x78d, 0x78e, 0x5, 0x11a, 0x8e, 0x2, 0x78e, 0x119, 0x3, 0x2, 0x2, 
			 0x2, 0x78f, 0x791, 0x5, 0x152, 0xaa, 0x2, 0x790, 0x78f, 0x3, 0x2, 0x2, 
			 0x2, 0x790, 0x791, 0x3, 0x2, 0x2, 0x2, 0x791, 0x792, 0x3, 0x2, 0x2, 
			 0x2, 0x792, 0x79b, 0x5, 0x68, 0x35, 0x2, 0x793, 0x79b, 0x5, 0x178, 0xbd, 
			 0x2, 0x794, 0x795, 0x7, 0x66, 0x2, 0x2, 0x795, 0x796, 0x7, 0x1c, 0x2, 
			 0x2, 0x796, 0x79b, 0x7, 0x80, 0x2, 0x2, 0x797, 0x798, 0x7, 0x66, 0x2, 
			 0x2, 0x798, 0x799, 0x7, 0x1d, 0x2, 0x2, 0x799, 0x79b, 0x7, 0x80, 0x2, 
			 0x2, 0x79a, 0x790, 0x3, 0x2, 0x2, 0x2, 0x79a, 0x793, 0x3, 0x2, 0x2, 
			 0x2, 0x79a, 0x794, 0x3, 0x2, 0x2, 0x2, 0x79a, 0x797, 0x3, 0x2, 0x2, 
			 0x2, 0x79b, 0x11b, 0x3, 0x2, 0x2, 0x2, 0x79c, 0x7a2, 0x5, 0x11e, 0x90, 
			 0x2, 0x79d, 0x79e, 0x7, 0x56, 0x2, 0x2, 0x79e, 0x79f, 0x5, 0x26, 0x14, 
			 0x2, 0x79f, 0x7a0, 0x7, 0x57, 0x2, 0x2, 0x7a0, 0x7a2, 0x3, 0x2, 0x2, 
			 0x2, 0x7a1, 0x79c, 0x3, 0x2, 0x2, 0x2, 0x7a1, 0x79d, 0x3, 0x2, 0x2, 
			 0x2, 0x7a2, 0x11d, 0x3, 0x2, 0x2, 0x2, 0x7a3, 0x7a4, 0x7, 0x66, 0x2, 
			 0x2, 0x7a4, 0x7a7, 0x5, 0x120, 0x91, 0x2, 0x7a5, 0x7a7, 0x5, 0x124, 
			 0x93, 0x2, 0x7a6, 0x7a3, 0x3, 0x2, 0x2, 0x2, 0x7a6, 0x7a5, 0x3, 0x2, 
			 0x2, 0x2, 0x7a7, 0x11f, 0x3, 0x2, 0x2, 0x2, 0x7a8, 0x7ab, 0x5, 0x5a, 
			 0x2e, 0x2, 0x7a9, 0x7ab, 0x5, 0x124, 0x93, 0x2, 0x7aa, 0x7a8, 0x3, 0x2, 
			 0x2, 0x2, 0x7aa, 0x7a9, 0x3, 0x2, 0x2, 0x2, 0x7ab, 0x121, 0x3, 0x2, 
			 0x2, 0x2, 0x7ac, 0x7ad, 0x8, 0x92, 0x1, 0x2, 0x7ad, 0x7af, 0x5, 0x120, 
			 0x91, 0x2, 0x7ae, 0x7b0, 0x7, 0x83, 0x2, 0x2, 0x7af, 0x7ae, 0x3, 0x2, 
			 0x2, 0x2, 0x7af, 0x7b0, 0x3, 0x2, 0x2, 0x2, 0x7b0, 0x7b9, 0x3, 0x2, 
			 0x2, 0x2, 0x7b1, 0x7b2, 0xc, 0x3, 0x2, 0x2, 0x7b2, 0x7b3, 0x7, 0x7a, 
			 0x2, 0x2, 0x7b3, 0x7b5, 0x5, 0x120, 0x91, 0x2, 0x7b4, 0x7b6, 0x7, 0x83, 
			 0x2, 0x2, 0x7b5, 0x7b4, 0x3, 0x2, 0x2, 0x2, 0x7b5, 0x7b6, 0x3, 0x2, 
			 0x2, 0x2, 0x7b6, 0x7b8, 0x3, 0x2, 0x2, 0x2, 0x7b7, 0x7b1, 0x3, 0x2, 
			 0x2, 0x2, 0x7b8, 0x7bb, 0x3, 0x2, 0x2, 0x2, 0x7b9, 0x7b7, 0x3, 0x2, 
			 0x2, 0x2, 0x7b9, 0x7ba, 0x3, 0x2, 0x2, 0x2, 0x7ba, 0x123, 0x3, 0x2, 
			 0x2, 0x2, 0x7bb, 0x7b9, 0x3, 0x2, 0x2, 0x2, 0x7bc, 0x7bd, 0x7, 0x5a, 
			 0x2, 0x2, 0x7bd, 0x7bf, 0x5, 0x122, 0x92, 0x2, 0x7be, 0x7c0, 0x7, 0x7a, 
			 0x2, 0x2, 0x7bf, 0x7be, 0x3, 0x2, 0x2, 0x2, 0x7bf, 0x7c0, 0x3, 0x2, 
			 0x2, 0x2, 0x7c0, 0x7c1, 0x3, 0x2, 0x2, 0x2, 0x7c1, 0x7c2, 0x7, 0x5b, 
			 0x2, 0x2, 0x7c2, 0x7c6, 0x3, 0x2, 0x2, 0x2, 0x7c3, 0x7c4, 0x7, 0x5a, 
			 0x2, 0x2, 0x7c4, 0x7c6, 0x7, 0x5b, 0x2, 0x2, 0x7c5, 0x7bc, 0x3, 0x2, 
			 0x2, 0x2, 0x7c5, 0x7c3, 0x3, 0x2, 0x2, 0x2, 0x7c6, 0x125, 0x3, 0x2, 
			 0x2, 0x2, 0x7c7, 0x7ca, 0x7, 0x84, 0x2, 0x2, 0x7c8, 0x7ca, 0x5, 0x166, 
			 0xb4, 0x2, 0x7c9, 0x7c7, 0x3, 0x2, 0x2, 0x2, 0x7c9, 0x7c8, 0x3, 0x2, 
			 0x2, 0x2, 0x7ca, 0x127, 0x3, 0x2, 0x2, 0x2, 0x7cb, 0x7cc, 0x5, 0x12a, 
			 0x96, 0x2, 0x7cc, 0x7ce, 0x7, 0x5a, 0x2, 0x2, 0x7cd, 0x7cf, 0x5, 0x132, 
			 0x9a, 0x2, 0x7ce, 0x7cd, 0x3, 0x2, 0x2, 0x2, 0x7ce, 0x7cf, 0x3, 0x2, 
			 0x2, 0x2, 0x7cf, 0x7d0, 0x3, 0x2, 0x2, 0x2, 0x7d0, 0x7d1, 0x7, 0x5b, 
			 0x2, 0x2, 0x7d1, 0x129, 0x3, 0x2, 0x2, 0x2, 0x7d2, 0x7d4, 0x5, 0x130, 
			 0x99, 0x2, 0x7d3, 0x7d5, 0x5, 0xd8, 0x6d, 0x2, 0x7d4, 0x7d3, 0x3, 0x2, 
			 0x2, 0x2, 0x7d4, 0x7d5, 0x3, 0x2, 0x2, 0x2, 0x7d5, 0x7d6, 0x3, 0x2, 
			 0x2, 0x2, 0x7d6, 0x7d8, 0x5, 0x12c, 0x97, 0x2, 0x7d7, 0x7d9, 0x5, 0x12e, 
			 0x98, 0x2, 0x7d8, 0x7d7, 0x3, 0x2, 0x2, 0x2, 0x7d8, 0x7d9, 0x3, 0x2, 
			 0x2, 0x2, 0x7d9, 0x7db, 0x3, 0x2, 0x2, 0x2, 0x7da, 0x7dc, 0x5, 0x140, 
			 0xa1, 0x2, 0x7db, 0x7da, 0x3, 0x2, 0x2, 0x2, 0x7db, 0x7dc, 0x3, 0x2, 
			 0x2, 0x2, 0x7dc, 0x7e5, 0x3, 0x2, 0x2, 0x2, 0x7dd, 0x7df, 0x5, 0x130, 
			 0x99, 0x2, 0x7de, 0x7e0, 0x5, 0xd8, 0x6d, 0x2, 0x7df, 0x7de, 0x3, 0x2, 
			 0x2, 0x2, 0x7df, 0x7e0, 0x3, 0x2, 0x2, 0x2, 0x7e0, 0x7e2, 0x3, 0x2, 
			 0x2, 0x2, 0x7e1, 0x7e3, 0x5, 0x140, 0xa1, 0x2, 0x7e2, 0x7e1, 0x3, 0x2, 
			 0x2, 0x2, 0x7e2, 0x7e3, 0x3, 0x2, 0x2, 0x2, 0x7e3, 0x7e5, 0x3, 0x2, 
			 0x2, 0x2, 0x7e4, 0x7d2, 0x3, 0x2, 0x2, 0x2, 0x7e4, 0x7dd, 0x3, 0x2, 
			 0x2, 0x2, 0x7e5, 0x12b, 0x3, 0x2, 0x2, 0x2, 0x7e6, 0x7e8, 0x5, 0xc, 
			 0x7, 0x2, 0x7e7, 0x7e6, 0x3, 0x2, 0x2, 0x2, 0x7e7, 0x7e8, 0x3, 0x2, 
			 0x2, 0x2, 0x7e8, 0x7e9, 0x3, 0x2, 0x2, 0x2, 0x7e9, 0x7ea, 0x5, 0x126, 
			 0x94, 0x2, 0x7ea, 0x12d, 0x3, 0x2, 0x2, 0x2, 0x7eb, 0x7ec, 0x7, 0x27, 
			 0x2, 0x2, 0x7ec, 0x12f, 0x3, 0x2, 0x2, 0x2, 0x7ed, 0x7ee, 0x9, 0xa, 
			 0x2, 0x2, 0x7ee, 0x131, 0x3, 0x2, 0x2, 0x2, 0x7ef, 0x7f1, 0x5, 0x134, 
			 0x9b, 0x2, 0x7f0, 0x7f2, 0x5, 0x132, 0x9a, 0x2, 0x7f1, 0x7f0, 0x3, 0x2, 
			 0x2, 0x2, 0x7f1, 0x7f2, 0x3, 0x2, 0x2, 0x2, 0x7f2, 0x7f9, 0x3, 0x2, 
			 0x2, 0x2, 0x7f3, 0x7f4, 0x5, 0x14a, 0xa6, 0x2, 0x7f4, 0x7f6, 0x7, 0x7e, 
			 0x2, 0x2, 0x7f5, 0x7f7, 0x5, 0x132, 0x9a, 0x2, 0x7f6, 0x7f5, 0x3, 0x2, 
			 0x2, 0x2, 0x7f6, 0x7f7, 0x3, 0x2, 0x2, 0x2, 0x7f7, 0x7f9, 0x3, 0x2, 
			 0x2, 0x2, 0x7f8, 0x7ef, 0x3, 0x2, 0x2, 0x2, 0x7f8, 0x7f3, 0x3, 0x2, 
			 0x2, 0x2, 0x7f9, 0x133, 0x3, 0x2, 0x2, 0x2, 0x7fa, 0x7fc, 0x5, 0xd8, 
			 0x6d, 0x2, 0x7fb, 0x7fa, 0x3, 0x2, 0x2, 0x2, 0x7fb, 0x7fc, 0x3, 0x2, 
			 0x2, 0x2, 0x7fc, 0x7fe, 0x3, 0x2, 0x2, 0x2, 0x7fd, 0x7ff, 0x5, 0x90, 
			 0x49, 0x2, 0x7fe, 0x7fd, 0x3, 0x2, 0x2, 0x2, 0x7fe, 0x7ff, 0x3, 0x2, 
			 0x2, 0x2, 0x7ff, 0x801, 0x3, 0x2, 0x2, 0x2, 0x800, 0x802, 0x5, 0x136, 
			 0x9c, 0x2, 0x801, 0x800, 0x3, 0x2, 0x2, 0x2, 0x801, 0x802, 0x3, 0x2, 
			 0x2, 0x2, 0x802, 0x803, 0x3, 0x2, 0x2, 0x2, 0x803, 0x80b, 0x7, 0x80, 
			 0x2, 0x2, 0x804, 0x80b, 0x5, 0x118, 0x8d, 0x2, 0x805, 0x80b, 0x5, 0xd0, 
			 0x69, 0x2, 0x806, 0x80b, 0x5, 0x88, 0x45, 0x2, 0x807, 0x80b, 0x5, 0x15e, 
			 0xb0, 0x2, 0x808, 0x80b, 0x5, 0x84, 0x43, 0x2, 0x809, 0x80b, 0x5, 0x8a, 
			 0x46, 0x2, 0x80a, 0x7fb, 0x3, 0x2, 0x2, 0x2, 0x80a, 0x804, 0x3, 0x2, 
			 0x2, 0x2, 0x80a, 0x805, 0x3, 0x2, 0x2, 0x2, 0x80a, 0x806, 0x3, 0x2, 
			 0x2, 0x2, 0x80a, 0x807, 0x3, 0x2, 0x2, 0x2, 0x80a, 0x808, 0x3, 0x2, 
			 0x2, 0x2, 0x80a, 0x809, 0x3, 0x2, 0x2, 0x2, 0x80b, 0x135, 0x3, 0x2, 
			 0x2, 0x2, 0x80c, 0x80d, 0x8, 0x9c, 0x1, 0x2, 0x80d, 0x80e, 0x5, 0x138, 
			 0x9d, 0x2, 0x80e, 0x814, 0x3, 0x2, 0x2, 0x2, 0x80f, 0x810, 0xc, 0x3, 
			 0x2, 0x2, 0x810, 0x811, 0x7, 0x7a, 0x2, 0x2, 0x811, 0x813, 0x5, 0x138, 
			 0x9d, 0x2, 0x812, 0x80f, 0x3, 0x2, 0x2, 0x2, 0x813, 0x816, 0x3, 0x2, 
			 0x2, 0x2, 0x814, 0x812, 0x3, 0x2, 0x2, 0x2, 0x814, 0x815, 0x3, 0x2, 
			 0x2, 0x2, 0x815, 0x137, 0x3, 0x2, 0x2, 0x2, 0x816, 0x814, 0x3, 0x2, 
			 0x2, 0x2, 0x817, 0x819, 0x5, 0xf2, 0x7a, 0x2, 0x818, 0x81a, 0x5, 0x13a, 
			 0x9e, 0x2, 0x819, 0x818, 0x3, 0x2, 0x2, 0x2, 0x819, 0x81a, 0x3, 0x2, 
			 0x2, 0x2, 0x81a, 0x81c, 0x3, 0x2, 0x2, 0x2, 0x81b, 0x81d, 0x5, 0x13e, 
			 0xa0, 0x2, 0x81c, 0x81b, 0x3, 0x2, 0x2, 0x2, 0x81c, 0x81d, 0x3, 0x2, 
			 0x2, 0x2, 0x81d, 0x82b, 0x3, 0x2, 0x2, 0x2, 0x81e, 0x820, 0x5, 0xf2, 
			 0x7a, 0x2, 0x81f, 0x821, 0x5, 0x11e, 0x90, 0x2, 0x820, 0x81f, 0x3, 0x2, 
			 0x2, 0x2, 0x820, 0x821, 0x3, 0x2, 0x2, 0x2, 0x821, 0x82b, 0x3, 0x2, 
			 0x2, 0x2, 0x822, 0x824, 0x7, 0x84, 0x2, 0x2, 0x823, 0x822, 0x3, 0x2, 
			 0x2, 0x2, 0x823, 0x824, 0x3, 0x2, 0x2, 0x2, 0x824, 0x826, 0x3, 0x2, 
			 0x2, 0x2, 0x825, 0x827, 0x5, 0xd8, 0x6d, 0x2, 0x826, 0x825, 0x3, 0x2, 
			 0x2, 0x2, 0x826, 0x827, 0x3, 0x2, 0x2, 0x2, 0x827, 0x828, 0x3, 0x2, 
			 0x2, 0x2, 0x828, 0x829, 0x7, 0x7e, 0x2, 0x2, 0x829, 0x82b, 0x5, 0x60, 
			 0x31, 0x2, 0x82a, 0x817, 0x3, 0x2, 0x2, 0x2, 0x82a, 0x81e, 0x3, 0x2, 
			 0x2, 0x2, 0x82a, 0x823, 0x3, 0x2, 0x2, 0x2, 0x82b, 0x139, 0x3, 0x2, 
			 0x2, 0x2, 0x82c, 0x82d, 0x8, 0x9e, 0x1, 0x2, 0x82d, 0x82e, 0x5, 0x13c, 
			 0x9f, 0x2, 0x82e, 0x833, 0x3, 0x2, 0x2, 0x2, 0x82f, 0x830, 0xc, 0x3, 
			 0x2, 0x2, 0x830, 0x832, 0x5, 0x13c, 0x9f, 0x2, 0x831, 0x82f, 0x3, 0x2, 
			 0x2, 0x2, 0x832, 0x835, 0x3, 0x2, 0x2, 0x2, 0x833, 0x831, 0x3, 0x2, 
			 0x2, 0x2, 0x833, 0x834, 0x3, 0x2, 0x2, 0x2, 0x834, 0x13b, 0x3, 0x2, 
			 0x2, 0x2, 0x835, 0x833, 0x3, 0x2, 0x2, 0x2, 0x836, 0x837, 0x9, 0xb, 
			 0x2, 0x2, 0x837, 0x13d, 0x3, 0x2, 0x2, 0x2, 0x838, 0x839, 0x7, 0x66, 
			 0x2, 0x2, 0x839, 0x83a, 0x7, 0x87, 0x2, 0x2, 0x83a, 0x13f, 0x3, 0x2, 
			 0x2, 0x2, 0x83b, 0x83c, 0x7, 0x7e, 0x2, 0x2, 0x83c, 0x83d, 0x5, 0x142, 
			 0xa2, 0x2, 0x83d, 0x141, 0x3, 0x2, 0x2, 0x2, 0x83e, 0x83f, 0x8, 0xa2, 
			 0x1, 0x2, 0x83f, 0x841, 0x5, 0x144, 0xa3, 0x2, 0x840, 0x842, 0x7, 0x83, 
			 0x2, 0x2, 0x841, 0x840, 0x3, 0x2, 0x2, 0x2, 0x841, 0x842, 0x3, 0x2, 
			 0x2, 0x2, 0x842, 0x84b, 0x3, 0x2, 0x2, 0x2, 0x843, 0x844, 0xc, 0x3, 
			 0x2, 0x2, 0x844, 0x845, 0x7, 0x7a, 0x2, 0x2, 0x845, 0x847, 0x5, 0x144, 
			 0xa3, 0x2, 0x846, 0x848, 0x7, 0x83, 0x2, 0x2, 0x847, 0x846, 0x3, 0x2, 
			 0x2, 0x2, 0x847, 0x848, 0x3, 0x2, 0x2, 0x2, 0x848, 0x84a, 0x3, 0x2, 
			 0x2, 0x2, 0x849, 0x843, 0x3, 0x2, 0x2, 0x2, 0x84a, 0x84d, 0x3, 0x2, 
			 0x2, 0x2, 0x84b, 0x849, 0x3, 0x2, 0x2, 0x2, 0x84b, 0x84c, 0x3, 0x2, 
			 0x2, 0x2, 0x84c, 0x143, 0x3, 0x2, 0x2, 0x2, 0x84d, 0x84b, 0x3, 0x2, 
			 0x2, 0x2, 0x84e, 0x850, 0x5, 0xd8, 0x6d, 0x2, 0x84f, 0x84e, 0x3, 0x2, 
			 0x2, 0x2, 0x84f, 0x850, 0x3, 0x2, 0x2, 0x2, 0x850, 0x851, 0x3, 0x2, 
			 0x2, 0x2, 0x851, 0x864, 0x5, 0x148, 0xa5, 0x2, 0x852, 0x854, 0x5, 0xd8, 
			 0x6d, 0x2, 0x853, 0x852, 0x3, 0x2, 0x2, 0x2, 0x853, 0x854, 0x3, 0x2, 
			 0x2, 0x2, 0x854, 0x855, 0x3, 0x2, 0x2, 0x2, 0x855, 0x857, 0x7, 0x51, 
			 0x2, 0x2, 0x856, 0x858, 0x5, 0x14a, 0xa6, 0x2, 0x857, 0x856, 0x3, 0x2, 
			 0x2, 0x2, 0x857, 0x858, 0x3, 0x2, 0x2, 0x2, 0x858, 0x859, 0x3, 0x2, 
			 0x2, 0x2, 0x859, 0x864, 0x5, 0x148, 0xa5, 0x2, 0x85a, 0x85c, 0x5, 0xd8, 
			 0x6d, 0x2, 0x85b, 0x85a, 0x3, 0x2, 0x2, 0x2, 0x85b, 0x85c, 0x3, 0x2, 
			 0x2, 0x2, 0x85c, 0x85d, 0x3, 0x2, 0x2, 0x2, 0x85d, 0x85f, 0x5, 0x14a, 
			 0xa6, 0x2, 0x85e, 0x860, 0x7, 0x51, 0x2, 0x2, 0x85f, 0x85e, 0x3, 0x2, 
			 0x2, 0x2, 0x85f, 0x860, 0x3, 0x2, 0x2, 0x2, 0x860, 0x861, 0x3, 0x2, 
			 0x2, 0x2, 0x861, 0x862, 0x5, 0x148, 0xa5, 0x2, 0x862, 0x864, 0x3, 0x2, 
			 0x2, 0x2, 0x863, 0x84f, 0x3, 0x2, 0x2, 0x2, 0x863, 0x853, 0x3, 0x2, 
			 0x2, 0x2, 0x863, 0x85b, 0x3, 0x2, 0x2, 0x2, 0x864, 0x145, 0x3, 0x2, 
			 0x2, 0x2, 0x865, 0x867, 0x5, 0xc, 0x7, 0x2, 0x866, 0x865, 0x3, 0x2, 
			 0x2, 0x2, 0x866, 0x867, 0x3, 0x2, 0x2, 0x2, 0x867, 0x868, 0x3, 0x2, 
			 0x2, 0x2, 0x868, 0x86b, 0x5, 0x126, 0x94, 0x2, 0x869, 0x86b, 0x5, 0xa4, 
			 0x53, 0x2, 0x86a, 0x866, 0x3, 0x2, 0x2, 0x2, 0x86a, 0x869, 0x3, 0x2, 
			 0x2, 0x2, 0x86b, 0x147, 0x3, 0x2, 0x2, 0x2, 0x86c, 0x86d, 0x5, 0x146, 
			 0xa4, 0x2, 0x86d, 0x149, 0x3, 0x2, 0x2, 0x2, 0x86e, 0x86f, 0x9, 0xc, 
			 0x2, 0x2, 0x86f, 0x14b, 0x3, 0x2, 0x2, 0x2, 0x870, 0x871, 0x7, 0x35, 
			 0x2, 0x2, 0x871, 0x872, 0x5, 0x14e, 0xa8, 0x2, 0x872, 0x14d, 0x3, 0x2, 
			 0x2, 0x2, 0x873, 0x875, 0x5, 0x9c, 0x4f, 0x2, 0x874, 0x876, 0x5, 0x150, 
			 0xa9, 0x2, 0x875, 0x874, 0x3, 0x2, 0x2, 0x2, 0x875, 0x876, 0x3, 0x2, 
			 0x2, 0x2, 0x876, 0x14f, 0x3, 0x2, 0x2, 0x2, 0x877, 0x879, 0x5, 0xfc, 
			 0x7f, 0x2, 0x878, 0x87a, 0x5, 0x150, 0xa9, 0x2, 0x879, 0x878, 0x3, 0x2, 
			 0x2, 0x2, 0x879, 0x87a, 0x3, 0x2, 0x2, 0x2, 0x87a, 0x151, 0x3, 0x2, 
			 0x2, 0x2, 0x87b, 0x87c, 0x7, 0x7e, 0x2, 0x2, 0x87c, 0x87d, 0x5, 0x154, 
			 0xab, 0x2, 0x87d, 0x153, 0x3, 0x2, 0x2, 0x2, 0x87e, 0x880, 0x5, 0x156, 
			 0xac, 0x2, 0x87f, 0x881, 0x7, 0x83, 0x2, 0x2, 0x880, 0x87f, 0x3, 0x2, 
			 0x2, 0x2, 0x880, 0x881, 0x3, 0x2, 0x2, 0x2, 0x881, 0x88a, 0x3, 0x2, 
			 0x2, 0x2, 0x882, 0x884, 0x5, 0x156, 0xac, 0x2, 0x883, 0x885, 0x7, 0x83, 
			 0x2, 0x2, 0x884, 0x883, 0x3, 0x2, 0x2, 0x2, 0x884, 0x885, 0x3, 0x2, 
			 0x2, 0x2, 0x885, 0x886, 0x3, 0x2, 0x2, 0x2, 0x886, 0x887, 0x7, 0x7a, 
			 0x2, 0x2, 0x887, 0x888, 0x5, 0x154, 0xab, 0x2, 0x888, 0x88a, 0x3, 0x2, 
			 0x2, 0x2, 0x889, 0x87e, 0x3, 0x2, 0x2, 0x2, 0x889, 0x882, 0x3, 0x2, 
			 0x2, 0x2, 0x88a, 0x155, 0x3, 0x2, 0x2, 0x2, 0x88b, 0x88c, 0x5, 0x158, 
			 0xad, 0x2, 0x88c, 0x88e, 0x7, 0x56, 0x2, 0x2, 0x88d, 0x88f, 0x5, 0x26, 
			 0x14, 0x2, 0x88e, 0x88d, 0x3, 0x2, 0x2, 0x2, 0x88e, 0x88f, 0x3, 0x2, 
			 0x2, 0x2, 0x88f, 0x890, 0x3, 0x2, 0x2, 0x2, 0x890, 0x891, 0x7, 0x57, 
			 0x2, 0x2, 0x891, 0x896, 0x3, 0x2, 0x2, 0x2, 0x892, 0x893, 0x5, 0x158, 
			 0xad, 0x2, 0x893, 0x894, 0x5, 0x124, 0x93, 0x2, 0x894, 0x896, 0x3, 0x2, 
			 0x2, 0x2, 0x895, 0x88b, 0x3, 0x2, 0x2, 0x2, 0x895, 0x892, 0x3, 0x2, 
			 0x2, 0x2, 0x896, 0x157, 0x3, 0x2, 0x2, 0x2, 0x897, 0x89a, 0x5, 0x146, 
			 0xa4, 0x2, 0x898, 0x89a, 0x7, 0x84, 0x2, 0x2, 0x899, 0x897, 0x3, 0x2, 
			 0x2, 0x2, 0x899, 0x898, 0x3, 0x2, 0x2, 0x2, 0x89a, 0x159, 0x3, 0x2, 
			 0x2, 0x2, 0x89b, 0x89c, 0x7, 0x35, 0x2, 0x2, 0x89c, 0x89d, 0x5, 0x18e, 
			 0xc8, 0x2, 0x89d, 0x15b, 0x3, 0x2, 0x2, 0x2, 0x89e, 0x89f, 0x7, 0x35, 
			 0x2, 0x2, 0x89f, 0x8a0, 0x7, 0x8d, 0x2, 0x2, 0x8a0, 0x8a4, 0x7, 0x84, 
			 0x2, 0x2, 0x8a1, 0x8a2, 0x7, 0x35, 0x2, 0x2, 0x8a2, 0x8a4, 0x7, 0x90, 
			 0x2, 0x2, 0x8a3, 0x89e, 0x3, 0x2, 0x2, 0x2, 0x8a3, 0x8a1, 0x3, 0x2, 
			 0x2, 0x2, 0x8a4, 0x15d, 0x3, 0x2, 0x2, 0x2, 0x8a5, 0x8a6, 0x7, 0x45, 
			 0x2, 0x2, 0x8a6, 0x8a7, 0x7, 0x67, 0x2, 0x2, 0x8a7, 0x8a8, 0x5, 0x160, 
			 0xb1, 0x2, 0x8a8, 0x8a9, 0x7, 0x96, 0x2, 0x2, 0x8a9, 0x8aa, 0x5, 0x7e, 
			 0x40, 0x2, 0x8aa, 0x15f, 0x3, 0x2, 0x2, 0x2, 0x8ab, 0x8ac, 0x8, 0xb1, 
			 0x1, 0x2, 0x8ac, 0x8ad, 0x5, 0x162, 0xb2, 0x2, 0x8ad, 0x8b3, 0x3, 0x2, 
			 0x2, 0x2, 0x8ae, 0x8af, 0xc, 0x3, 0x2, 0x2, 0x8af, 0x8b0, 0x7, 0x7a, 
			 0x2, 0x2, 0x8b0, 0x8b2, 0x5, 0x162, 0xb2, 0x2, 0x8b1, 0x8ae, 0x3, 0x2, 
			 0x2, 0x2, 0x8b2, 0x8b5, 0x3, 0x2, 0x2, 0x2, 0x8b3, 0x8b1, 0x3, 0x2, 
			 0x2, 0x2, 0x8b3, 0x8b4, 0x3, 0x2, 0x2, 0x2, 0x8b4, 0x161, 0x3, 0x2, 
			 0x2, 0x2, 0x8b5, 0x8b3, 0x3, 0x2, 0x2, 0x2, 0x8b6, 0x8b9, 0x5, 0x164, 
			 0xb3, 0x2, 0x8b7, 0x8b9, 0x5, 0x116, 0x8c, 0x2, 0x8b8, 0x8b6, 0x3, 0x2, 
			 0x2, 0x2, 0x8b8, 0x8b7, 0x3, 0x2, 0x2, 0x2, 0x8b9, 0x163, 0x3, 0x2, 
			 0x2, 0x2, 0x8ba, 0x8bc, 0x7, 0x16, 0x2, 0x2, 0x8bb, 0x8bd, 0x7, 0x83, 
			 0x2, 0x2, 0x8bc, 0x8bb, 0x3, 0x2, 0x2, 0x2, 0x8bc, 0x8bd, 0x3, 0x2, 
			 0x2, 0x2, 0x8bd, 0x8bf, 0x3, 0x2, 0x2, 0x2, 0x8be, 0x8c0, 0x7, 0x84, 
			 0x2, 0x2, 0x8bf, 0x8be, 0x3, 0x2, 0x2, 0x2, 0x8bf, 0x8c0, 0x3, 0x2, 
			 0x2, 0x2, 0x8c0, 0x8eb, 0x3, 0x2, 0x2, 0x2, 0x8c1, 0x8c3, 0x7, 0x16, 
			 0x2, 0x2, 0x8c2, 0x8c4, 0x7, 0x84, 0x2, 0x2, 0x8c3, 0x8c2, 0x3, 0x2, 
			 0x2, 0x2, 0x8c3, 0x8c4, 0x3, 0x2, 0x2, 0x2, 0x8c4, 0x8c5, 0x3, 0x2, 
			 0x2, 0x2, 0x8c5, 0x8c6, 0x7, 0x66, 0x2, 0x2, 0x8c6, 0x8eb, 0x5, 0x106, 
			 0x84, 0x2, 0x8c7, 0x8c9, 0x7, 0x4d, 0x2, 0x2, 0x8c8, 0x8ca, 0x7, 0x83, 
			 0x2, 0x2, 0x8c9, 0x8c8, 0x3, 0x2, 0x2, 0x2, 0x8c9, 0x8ca, 0x3, 0x2, 
			 0x2, 0x2, 0x8ca, 0x8cc, 0x3, 0x2, 0x2, 0x2, 0x8cb, 0x8cd, 0x7, 0x84, 
			 0x2, 0x2, 0x8cc, 0x8cb, 0x3, 0x2, 0x2, 0x2, 0x8cc, 0x8cd, 0x3, 0x2, 
			 0x2, 0x2, 0x8cd, 0x8eb, 0x3, 0x2, 0x2, 0x2, 0x8ce, 0x8d0, 0x7, 0x4d, 
			 0x2, 0x2, 0x8cf, 0x8d1, 0x7, 0x84, 0x2, 0x2, 0x8d0, 0x8cf, 0x3, 0x2, 
			 0x2, 0x2, 0x8d0, 0x8d1, 0x3, 0x2, 0x2, 0x2, 0x8d1, 0x8d2, 0x3, 0x2, 
			 0x2, 0x2, 0x8d2, 0x8d3, 0x7, 0x66, 0x2, 0x2, 0x8d3, 0x8eb, 0x5, 0x106, 
			 0x84, 0x2, 0x8d4, 0x8d5, 0x7, 0x45, 0x2, 0x2, 0x8d5, 0x8d6, 0x7, 0x67, 
			 0x2, 0x2, 0x8d6, 0x8d7, 0x5, 0x160, 0xb1, 0x2, 0x8d7, 0x8d8, 0x7, 0x96, 
			 0x2, 0x2, 0x8d8, 0x8da, 0x7, 0x16, 0x2, 0x2, 0x8d9, 0x8db, 0x7, 0x83, 
			 0x2, 0x2, 0x8da, 0x8d9, 0x3, 0x2, 0x2, 0x2, 0x8da, 0x8db, 0x3, 0x2, 
			 0x2, 0x2, 0x8db, 0x8dd, 0x3, 0x2, 0x2, 0x2, 0x8dc, 0x8de, 0x7, 0x84, 
			 0x2, 0x2, 0x8dd, 0x8dc, 0x3, 0x2, 0x2, 0x2, 0x8dd, 0x8de, 0x3, 0x2, 
			 0x2, 0x2, 0x8de, 0x8eb, 0x3, 0x2, 0x2, 0x2, 0x8df, 0x8e0, 0x7, 0x45, 
			 0x2, 0x2, 0x8e0, 0x8e1, 0x7, 0x67, 0x2, 0x2, 0x8e1, 0x8e2, 0x5, 0x160, 
			 0xb1, 0x2, 0x8e2, 0x8e3, 0x7, 0x96, 0x2, 0x2, 0x8e3, 0x8e5, 0x7, 0x16, 
			 0x2, 0x2, 0x8e4, 0x8e6, 0x7, 0x84, 0x2, 0x2, 0x8e5, 0x8e4, 0x3, 0x2, 
			 0x2, 0x2, 0x8e5, 0x8e6, 0x3, 0x2, 0x2, 0x2, 0x8e6, 0x8e7, 0x3, 0x2, 
			 0x2, 0x2, 0x8e7, 0x8e8, 0x7, 0x66, 0x2, 0x2, 0x8e8, 0x8e9, 0x5, 0x6, 
			 0x4, 0x2, 0x8e9, 0x8eb, 0x3, 0x2, 0x2, 0x2, 0x8ea, 0x8ba, 0x3, 0x2, 
			 0x2, 0x2, 0x8ea, 0x8c1, 0x3, 0x2, 0x2, 0x2, 0x8ea, 0x8c7, 0x3, 0x2, 
			 0x2, 0x2, 0x8ea, 0x8ce, 0x3, 0x2, 0x2, 0x2, 0x8ea, 0x8d4, 0x3, 0x2, 
			 0x2, 0x2, 0x8ea, 0x8df, 0x3, 0x2, 0x2, 0x2, 0x8eb, 0x165, 0x3, 0x2, 
			 0x2, 0x2, 0x8ec, 0x8ed, 0x5, 0x16a, 0xb6, 0x2, 0x8ed, 0x8ef, 0x7, 0x67, 
			 0x2, 0x2, 0x8ee, 0x8f0, 0x5, 0x16c, 0xb7, 0x2, 0x8ef, 0x8ee, 0x3, 0x2, 
			 0x2, 0x2, 0x8ef, 0x8f0, 0x3, 0x2, 0x2, 0x2, 0x8f0, 0x8f1, 0x3, 0x2, 
			 0x2, 0x2, 0x8f1, 0x8f2, 0x7, 0x96, 0x2, 0x2, 0x8f2, 0x167, 0x3, 0x2, 
			 0x2, 0x2, 0x8f3, 0x903, 0x5, 0x166, 0xb4, 0x2, 0x8f4, 0x8f5, 0x5, 0x15a, 
			 0xae, 0x2, 0x8f5, 0x8f7, 0x7, 0x67, 0x2, 0x2, 0x8f6, 0x8f8, 0x5, 0x16c, 
			 0xb7, 0x2, 0x8f7, 0x8f6, 0x3, 0x2, 0x2, 0x2, 0x8f7, 0x8f8, 0x3, 0x2, 
			 0x2, 0x2, 0x8f8, 0x8f9, 0x3, 0x2, 0x2, 0x2, 0x8f9, 0x8fa, 0x7, 0x96, 
			 0x2, 0x2, 0x8fa, 0x903, 0x3, 0x2, 0x2, 0x2, 0x8fb, 0x8fc, 0x5, 0x15c, 
			 0xaf, 0x2, 0x8fc, 0x8fe, 0x7, 0x67, 0x2, 0x2, 0x8fd, 0x8ff, 0x5, 0x16c, 
			 0xb7, 0x2, 0x8fe, 0x8fd, 0x3, 0x2, 0x2, 0x2, 0x8fe, 0x8ff, 0x3, 0x2, 
			 0x2, 0x2, 0x8ff, 0x900, 0x3, 0x2, 0x2, 0x2, 0x900, 0x901, 0x7, 0x96, 
			 0x2, 0x2, 0x901, 0x903, 0x3, 0x2, 0x2, 0x2, 0x902, 0x8f3, 0x3, 0x2, 
			 0x2, 0x2, 0x902, 0x8f4, 0x3, 0x2, 0x2, 0x2, 0x902, 0x8fb, 0x3, 0x2, 
			 0x2, 0x2, 0x903, 0x169, 0x3, 0x2, 0x2, 0x2, 0x904, 0x905, 0x7, 0x84, 
			 0x2, 0x2, 0x905, 0x16b, 0x3, 0x2, 0x2, 0x2, 0x906, 0x907, 0x8, 0xb7, 
			 0x1, 0x2, 0x907, 0x909, 0x5, 0x16e, 0xb8, 0x2, 0x908, 0x90a, 0x7, 0x83, 
			 0x2, 0x2, 0x909, 0x908, 0x3, 0x2, 0x2, 0x2, 0x909, 0x90a, 0x3, 0x2, 
			 0x2, 0x2, 0x90a, 0x913, 0x3, 0x2, 0x2, 0x2, 0x90b, 0x90c, 0xc, 0x3, 
			 0x2, 0x2, 0x90c, 0x90d, 0x7, 0x7a, 0x2, 0x2, 0x90d, 0x90f, 0x5, 0x16e, 
			 0xb8, 0x2, 0x90e, 0x910, 0x7, 0x83, 0x2, 0x2, 0x90f, 0x90e, 0x3, 0x2, 
			 0x2, 0x2, 0x90f, 0x910, 0x3, 0x2, 0x2, 0x2, 0x910, 0x912, 0x3, 0x2, 
			 0x2, 0x2, 0x911, 0x90b, 0x3, 0x2, 0x2, 0x2, 0x912, 0x915, 0x3, 0x2, 
			 0x2, 0x2, 0x913, 0x911, 0x3, 0x2, 0x2, 0x2, 0x913, 0x914, 0x3, 0x2, 
			 0x2, 0x2, 0x914, 0x16d, 0x3, 0x2, 0x2, 0x2, 0x915, 0x913, 0x3, 0x2, 
			 0x2, 0x2, 0x916, 0x91b, 0x5, 0x166, 0xb4, 0x2, 0x917, 0x91b, 0x5, 0x106, 
			 0x84, 0x2, 0x918, 0x91b, 0x5, 0x60, 0x31, 0x2, 0x919, 0x91b, 0x5, 0x6, 
			 0x4, 0x2, 0x91a, 0x916, 0x3, 0x2, 0x2, 0x2, 0x91a, 0x917, 0x3, 0x2, 
			 0x2, 0x2, 0x91a, 0x918, 0x3, 0x2, 0x2, 0x2, 0x91a, 0x919, 0x3, 0x2, 
			 0x2, 0x2, 0x91b, 0x16f, 0x3, 0x2, 0x2, 0x2, 0x91c, 0x91d, 0x7, 0x4d, 
			 0x2, 0x2, 0x91d, 0x91e, 0x5, 0xc, 0x7, 0x2, 0x91e, 0x91f, 0x7, 0x84, 
			 0x2, 0x2, 0x91f, 0x928, 0x3, 0x2, 0x2, 0x2, 0x920, 0x921, 0x7, 0x4d, 
			 0x2, 0x2, 0x921, 0x923, 0x5, 0xc, 0x7, 0x2, 0x922, 0x924, 0x7, 0x45, 
			 0x2, 0x2, 0x923, 0x922, 0x3, 0x2, 0x2, 0x2, 0x923, 0x924, 0x3, 0x2, 
			 0x2, 0x2, 0x924, 0x925, 0x3, 0x2, 0x2, 0x2, 0x925, 0x926, 0x5, 0x166, 
			 0xb4, 0x2, 0x926, 0x928, 0x3, 0x2, 0x2, 0x2, 0x927, 0x91c, 0x3, 0x2, 
			 0x2, 0x2, 0x927, 0x920, 0x3, 0x2, 0x2, 0x2, 0x928, 0x171, 0x3, 0x2, 
			 0x2, 0x2, 0x929, 0x92b, 0x7, 0x25, 0x2, 0x2, 0x92a, 0x929, 0x3, 0x2, 
			 0x2, 0x2, 0x92a, 0x92b, 0x3, 0x2, 0x2, 0x2, 0x92b, 0x92c, 0x3, 0x2, 
			 0x2, 0x2, 0x92c, 0x92d, 0x7, 0x45, 0x2, 0x2, 0x92d, 0x92e, 0x5, 0x7e, 
			 0x40, 0x2, 0x92e, 0x173, 0x3, 0x2, 0x2, 0x2, 0x92f, 0x930, 0x7, 0x45, 
			 0x2, 0x2, 0x930, 0x931, 0x7, 0x67, 0x2, 0x2, 0x931, 0x932, 0x7, 0x96, 
			 0x2, 0x2, 0x932, 0x933, 0x5, 0x7e, 0x40, 0x2, 0x933, 0x175, 0x3, 0x2, 
			 0x2, 0x2, 0x934, 0x935, 0x7, 0x4a, 0x2, 0x2, 0x935, 0x936, 0x5, 0x68, 
			 0x35, 0x2, 0x936, 0x937, 0x5, 0x17a, 0xbe, 0x2, 0x937, 0x177, 0x3, 0x2, 
			 0x2, 0x2, 0x938, 0x93a, 0x7, 0x4a, 0x2, 0x2, 0x939, 0x93b, 0x5, 0x152, 
			 0xaa, 0x2, 0x93a, 0x939, 0x3, 0x2, 0x2, 0x2, 0x93a, 0x93b, 0x3, 0x2, 
			 0x2, 0x2, 0x93b, 0x93c, 0x3, 0x2, 0x2, 0x2, 0x93c, 0x93d, 0x5, 0x68, 
			 0x35, 0x2, 0x93d, 0x93e, 0x5, 0x17a, 0xbe, 0x2, 0x93e, 0x179, 0x3, 0x2, 
			 0x2, 0x2, 0x93f, 0x941, 0x5, 0x17c, 0xbf, 0x2, 0x940, 0x942, 0x5, 0x17a, 
			 0xbe, 0x2, 0x941, 0x940, 0x3, 0x2, 0x2, 0x2, 0x941, 0x942, 0x3, 0x2, 
			 0x2, 0x2, 0x942, 0x17b, 0x3, 0x2, 0x2, 0x2, 0x943, 0x944, 0x7, 0x12, 
			 0x2, 0x2, 0x944, 0x945, 0x7, 0x56, 0x2, 0x2, 0x945, 0x946, 0x5, 0x17e, 
			 0xc0, 0x2, 0x946, 0x947, 0x7, 0x57, 0x2, 0x2, 0x947, 0x948, 0x5, 0x68, 
			 0x35, 0x2, 0x948, 0x17d, 0x3, 0x2, 0x2, 0x2, 0x949, 0x94b, 0x5, 0xd8, 
			 0x6d, 0x2, 0x94a, 0x949, 0x3, 0x2, 0x2, 0x2, 0x94a, 0x94b, 0x3, 0x2, 
			 0x2, 0x2, 0x94b, 0x94c, 0x3, 0x2, 0x2, 0x2, 0x94c, 0x94d, 0x5, 0x9c, 
			 0x4f, 0x2, 0x94d, 0x94e, 0x5, 0xf2, 0x7a, 0x2, 0x94e, 0x958, 0x3, 0x2, 
			 0x2, 0x2, 0x94f, 0x951, 0x5, 0xd8, 0x6d, 0x2, 0x950, 0x94f, 0x3, 0x2, 
			 0x2, 0x2, 0x950, 0x951, 0x3, 0x2, 0x2, 0x2, 0x951, 0x952, 0x3, 0x2, 
			 0x2, 0x2, 0x952, 0x954, 0x5, 0x9c, 0x4f, 0x2, 0x953, 0x955, 0x5, 0x108, 
			 0x85, 0x2, 0x954, 0x953, 0x3, 0x2, 0x2, 0x2, 0x954, 0x955, 0x3, 0x2, 
			 0x2, 0x2, 0x955, 0x958, 0x3, 0x2, 0x2, 0x2, 0x956, 0x958, 0x7, 0x83, 
			 0x2, 0x2, 0x957, 0x94a, 0x3, 0x2, 0x2, 0x2, 0x957, 0x950, 0x3, 0x2, 
			 0x2, 0x2, 0x957, 0x956, 0x3, 0x2, 0x2, 0x2, 0x958, 0x17f, 0x3, 0x2, 
			 0x2, 0x2, 0x959, 0x95b, 0x7, 0x48, 0x2, 0x2, 0x95a, 0x95c, 0x5, 0x5a, 
			 0x2e, 0x2, 0x95b, 0x95a, 0x3, 0x2, 0x2, 0x2, 0x95b, 0x95c, 0x3, 0x2, 
			 0x2, 0x2, 0x95c, 0x181, 0x3, 0x2, 0x2, 0x2, 0x95d, 0x960, 0x5, 0x184, 
			 0xc3, 0x2, 0x95e, 0x960, 0x5, 0x188, 0xc5, 0x2, 0x95f, 0x95d, 0x3, 0x2, 
			 0x2, 0x2, 0x95f, 0x95e, 0x3, 0x2, 0x2, 0x2, 0x960, 0x183, 0x3, 0x2, 
			 0x2, 0x2, 0x961, 0x962, 0x7, 0x48, 0x2, 0x2, 0x962, 0x964, 0x7, 0x56, 
			 0x2, 0x2, 0x963, 0x965, 0x5, 0x186, 0xc4, 0x2, 0x964, 0x963, 0x3, 0x2, 
			 0x2, 0x2, 0x964, 0x965, 0x3, 0x2, 0x2, 0x2, 0x965, 0x966, 0x3, 0x2, 
			 0x2, 0x2, 0x966, 0x967, 0x7, 0x57, 0x2, 0x2, 0x967, 0x185, 0x3, 0x2, 
			 0x2, 0x2, 0x968, 0x969, 0x8, 0xc4, 0x1, 0x2, 0x969, 0x96b, 0x5, 0x106, 
			 0x84, 0x2, 0x96a, 0x96c, 0x7, 0x83, 0x2, 0x2, 0x96b, 0x96a, 0x3, 0x2, 
			 0x2, 0x2, 0x96b, 0x96c, 0x3, 0x2, 0x2, 0x2, 0x96c, 0x975, 0x3, 0x2, 
			 0x2, 0x2, 0x96d, 0x96e, 0xc, 0x3, 0x2, 0x2, 0x96e, 0x96f, 0x7, 0x7a, 
			 0x2, 0x2, 0x96f, 0x971, 0x5, 0x106, 0x84, 0x2, 0x970, 0x972, 0x7, 0x83, 
			 0x2, 0x2, 0x971, 0x970, 0x3, 0x2, 0x2, 0x2, 0x971, 0x972, 0x3, 0x2, 
			 0x2, 0x2, 0x972, 0x974, 0x3, 0x2, 0x2, 0x2, 0x973, 0x96d, 0x3, 0x2, 
			 0x2, 0x2, 0x974, 0x977, 0x3, 0x2, 0x2, 0x2, 0x975, 0x973, 0x3, 0x2, 
			 0x2, 0x2, 0x975, 0x976, 0x3, 0x2, 0x2, 0x2, 0x976, 0x187, 0x3, 0x2, 
			 0x2, 0x2, 0x977, 0x975, 0x3, 0x2, 0x2, 0x2, 0x978, 0x979, 0x7, 0x33, 
			 0x2, 0x2, 0x979, 0x97a, 0x7, 0x56, 0x2, 0x2, 0x97a, 0x97b, 0x5, 0x60, 
			 0x31, 0x2, 0x97b, 0x97c, 0x7, 0x57, 0x2, 0x2, 0x97c, 0x97f, 0x3, 0x2, 
			 0x2, 0x2, 0x97d, 0x97f, 0x7, 0x33, 0x2, 0x2, 0x97e, 0x978, 0x3, 0x2, 
			 0x2, 0x2, 0x97e, 0x97d, 0x3, 0x2, 0x2, 0x2, 0x97f, 0x189, 0x3, 0x2, 
			 0x2, 0x2, 0x980, 0x981, 0x7, 0x96, 0x2, 0x2, 0x981, 0x982, 0x7, 0x96, 
			 0x2, 0x2, 0x982, 0x18b, 0x3, 0x2, 0x2, 0x2, 0x983, 0x984, 0x7, 0x96, 
			 0x2, 0x2, 0x984, 0x985, 0x7, 0x96, 0x2, 0x2, 0x985, 0x986, 0x7, 0x66, 
			 0x2, 0x2, 0x986, 0x18d, 0x3, 0x2, 0x2, 0x2, 0x987, 0x9bb, 0x7, 0x32, 
			 0x2, 0x2, 0x988, 0x9bb, 0x7, 0x1d, 0x2, 0x2, 0x989, 0x98a, 0x7, 0x32, 
			 0x2, 0x2, 0x98a, 0x98b, 0x7, 0x58, 0x2, 0x2, 0x98b, 0x9bb, 0x7, 0x59, 
			 0x2, 0x2, 
	};
	static uint16_t serializedATNSegment1[] =
	{
		0x98c, 0x98d, 0x7, 0x1d, 0x2, 0x2, 0x98d, 0x98e, 0x7, 0x58, 0x2, 0x2, 
			 0x98e, 0x9bb, 0x7, 0x59, 0x2, 0x2, 0x98f, 0x9bb, 0x7, 0x5c, 0x2, 0x2, 
			 0x990, 0x9bb, 0x7, 0x5d, 0x2, 0x2, 0x991, 0x9bb, 0x7, 0x5e, 0x2, 0x2, 
			 0x992, 0x9bb, 0x7, 0x5f, 0x2, 0x2, 0x993, 0x9bb, 0x7, 0x60, 0x2, 0x2, 
			 0x994, 0x9bb, 0x7, 0x61, 0x2, 0x2, 0x995, 0x9bb, 0x7, 0x62, 0x2, 0x2, 
			 0x996, 0x9bb, 0x7, 0x63, 0x2, 0x2, 0x997, 0x9bb, 0x7, 0x64, 0x2, 0x2, 
			 0x998, 0x9bb, 0x7, 0x3, 0x2, 0x2, 0x999, 0x9bb, 0x7, 0x4, 0x2, 0x2, 
			 0x99a, 0x9bb, 0x7, 0x66, 0x2, 0x2, 0x99b, 0x9bb, 0x7, 0x67, 0x2, 0x2, 
			 0x99c, 0x9bb, 0x7, 0x96, 0x2, 0x2, 0x99d, 0x9bb, 0x7, 0x68, 0x2, 0x2, 
			 0x99e, 0x9bb, 0x7, 0x69, 0x2, 0x2, 0x99f, 0x9bb, 0x7, 0x6a, 0x2, 0x2, 
			 0x9a0, 0x9bb, 0x7, 0x6b, 0x2, 0x2, 0x9a1, 0x9bb, 0x7, 0x6c, 0x2, 0x2, 
			 0x9a2, 0x9bb, 0x7, 0x6d, 0x2, 0x2, 0x9a3, 0x9bb, 0x7, 0x6e, 0x2, 0x2, 
			 0x9a4, 0x9bb, 0x7, 0x6f, 0x2, 0x2, 0x9a5, 0x9bb, 0x7, 0x70, 0x2, 0x2, 
			 0x9a6, 0x9bb, 0x5, 0x18a, 0xc6, 0x2, 0x9a7, 0x9bb, 0x5, 0x18c, 0xc7, 
			 0x2, 0x9a8, 0x9bb, 0x7, 0x71, 0x2, 0x2, 0x9a9, 0x9bb, 0x7, 0x72, 0x2, 
			 0x2, 0x9aa, 0x9bb, 0x7, 0x73, 0x2, 0x2, 0x9ab, 0x9bb, 0x7, 0x74, 0x2, 
			 0x2, 0x9ac, 0x9bb, 0x7, 0x75, 0x2, 0x2, 0x9ad, 0x9bb, 0x7, 0x5, 0x2, 
			 0x2, 0x9ae, 0x9bb, 0x7, 0x6, 0x2, 0x2, 0x9af, 0x9bb, 0x7, 0x7, 0x2, 
			 0x2, 0x9b0, 0x9bb, 0x7, 0x8, 0x2, 0x2, 0x9b1, 0x9bb, 0x7, 0x78, 0x2, 
			 0x2, 0x9b2, 0x9bb, 0x7, 0x79, 0x2, 0x2, 0x9b3, 0x9bb, 0x7, 0x7a, 0x2, 
			 0x2, 0x9b4, 0x9bb, 0x7, 0x7b, 0x2, 0x2, 0x9b5, 0x9bb, 0x7, 0x7c, 0x2, 
			 0x2, 0x9b6, 0x9b7, 0x7, 0x56, 0x2, 0x2, 0x9b7, 0x9bb, 0x7, 0x57, 0x2, 
			 0x2, 0x9b8, 0x9b9, 0x7, 0x58, 0x2, 0x2, 0x9b9, 0x9bb, 0x7, 0x59, 0x2, 
			 0x2, 0x9ba, 0x987, 0x3, 0x2, 0x2, 0x2, 0x9ba, 0x988, 0x3, 0x2, 0x2, 
			 0x2, 0x9ba, 0x989, 0x3, 0x2, 0x2, 0x2, 0x9ba, 0x98c, 0x3, 0x2, 0x2, 
			 0x2, 0x9ba, 0x98f, 0x3, 0x2, 0x2, 0x2, 0x9ba, 0x990, 0x3, 0x2, 0x2, 
			 0x2, 0x9ba, 0x991, 0x3, 0x2, 0x2, 0x2, 0x9ba, 0x992, 0x3, 0x2, 0x2, 
			 0x2, 0x9ba, 0x993, 0x3, 0x2, 0x2, 0x2, 0x9ba, 0x994, 0x3, 0x2, 0x2, 
			 0x2, 0x9ba, 0x995, 0x3, 0x2, 0x2, 0x2, 0x9ba, 0x996, 0x3, 0x2, 0x2, 
			 0x2, 0x9ba, 0x997, 0x3, 0x2, 0x2, 0x2, 0x9ba, 0x998, 0x3, 0x2, 0x2, 
			 0x2, 0x9ba, 0x999, 0x3, 0x2, 0x2, 0x2, 0x9ba, 0x99a, 0x3, 0x2, 0x2, 
			 0x2, 0x9ba, 0x99b, 0x3, 0x2, 0x2, 0x2, 0x9ba, 0x99c, 0x3, 0x2, 0x2, 
			 0x2, 0x9ba, 0x99d, 0x3, 0x2, 0x2, 0x2, 0x9ba, 0x99e, 0x3, 0x2, 0x2, 
			 0x2, 0x9ba, 0x99f, 0x3, 0x2, 0x2, 0x2, 0x9ba, 0x9a0, 0x3, 0x2, 0x2, 
			 0x2, 0x9ba, 0x9a1, 0x3, 0x2, 0x2, 0x2, 0x9ba, 0x9a2, 0x3, 0x2, 0x2, 
			 0x2, 0x9ba, 0x9a3, 0x3, 0x2, 0x2, 0x2, 0x9ba, 0x9a4, 0x3, 0x2, 0x2, 
			 0x2, 0x9ba, 0x9a5, 0x3, 0x2, 0x2, 0x2, 0x9ba, 0x9a6, 0x3, 0x2, 0x2, 
			 0x2, 0x9ba, 0x9a7, 0x3, 0x2, 0x2, 0x2, 0x9ba, 0x9a8, 0x3, 0x2, 0x2, 
			 0x2, 0x9ba, 0x9a9, 0x3, 0x2, 0x2, 0x2, 0x9ba, 0x9aa, 0x3, 0x2, 0x2, 
			 0x2, 0x9ba, 0x9ab, 0x3, 0x2, 0x2, 0x2, 0x9ba, 0x9ac, 0x3, 0x2, 0x2, 
			 0x2, 0x9ba, 0x9ad, 0x3, 0x2, 0x2, 0x2, 0x9ba, 0x9ae, 0x3, 0x2, 0x2, 
			 0x2, 0x9ba, 0x9af, 0x3, 0x2, 0x2, 0x2, 0x9ba, 0x9b0, 0x3, 0x2, 0x2, 
			 0x2, 0x9ba, 0x9b1, 0x3, 0x2, 0x2, 0x2, 0x9ba, 0x9b2, 0x3, 0x2, 0x2, 
			 0x2, 0x9ba, 0x9b3, 0x3, 0x2, 0x2, 0x2, 0x9ba, 0x9b4, 0x3, 0x2, 0x2, 
			 0x2, 0x9ba, 0x9b5, 0x3, 0x2, 0x2, 0x2, 0x9ba, 0x9b6, 0x3, 0x2, 0x2, 
			 0x2, 0x9ba, 0x9b8, 0x3, 0x2, 0x2, 0x2, 0x9bb, 0x18f, 0x3, 0x2, 0x2, 
			 0x2, 0x9bc, 0x9c4, 0x7, 0x85, 0x2, 0x2, 0x9bd, 0x9c4, 0x7, 0x8b, 0x2, 
			 0x2, 0x9be, 0x9c4, 0x7, 0x8c, 0x2, 0x2, 0x9bf, 0x9c4, 0x7, 0x8d, 0x2, 
			 0x2, 0x9c0, 0x9c4, 0x5, 0x192, 0xca, 0x2, 0x9c1, 0x9c4, 0x5, 0x194, 
			 0xcb, 0x2, 0x9c2, 0x9c4, 0x5, 0x196, 0xcc, 0x2, 0x9c3, 0x9bc, 0x3, 0x2, 
			 0x2, 0x2, 0x9c3, 0x9bd, 0x3, 0x2, 0x2, 0x2, 0x9c3, 0x9be, 0x3, 0x2, 
			 0x2, 0x2, 0x9c3, 0x9bf, 0x3, 0x2, 0x2, 0x2, 0x9c3, 0x9c0, 0x3, 0x2, 
			 0x2, 0x2, 0x9c3, 0x9c1, 0x3, 0x2, 0x2, 0x2, 0x9c3, 0x9c2, 0x3, 0x2, 
			 0x2, 0x2, 0x9c4, 0x191, 0x3, 0x2, 0x2, 0x2, 0x9c5, 0x9c6, 0x9, 0xd, 
			 0x2, 0x2, 0x9c6, 0x193, 0x3, 0x2, 0x2, 0x2, 0x9c7, 0x9c8, 0x7, 0x34, 
			 0x2, 0x2, 0x9c8, 0x195, 0x3, 0x2, 0x2, 0x2, 0x9c9, 0x9ca, 0x9, 0xe, 
			 0x2, 0x2, 0x9ca, 0x197, 0x3, 0x2, 0x2, 0x2, 0x144, 0x199, 0x1a5, 0x1a9, 
			 0x1b4, 0x1b8, 0x1c7, 0x1ce, 0x1d3, 0x1d5, 0x1da, 0x1e0, 0x1ea, 0x1f1, 
			 0x1f7, 0x1fb, 0x200, 0x206, 0x20d, 0x213, 0x216, 0x219, 0x21c, 0x223, 
			 0x22a, 0x25e, 0x26d, 0x273, 0x279, 0x286, 0x288, 0x292, 0x2a1, 0x2a7, 
			 0x2c5, 0x2ca, 0x2ce, 0x2d2, 0x2d5, 0x2d9, 0x2df, 0x2e1, 0x2e9, 0x2ed, 
			 0x2f1, 0x2f8, 0x2ff, 0x303, 0x308, 0x30c, 0x30f, 0x314, 0x31a, 0x327, 
			 0x332, 0x334, 0x343, 0x345, 0x351, 0x353, 0x35f, 0x364, 0x375, 0x377, 
			 0x383, 0x385, 0x390, 0x39b, 0x3a6, 0x3b2, 0x3b4, 0x3c0, 0x3c2, 0x3cc, 
			 0x3d4, 0x3e1, 0x3eb, 0x3f2, 0x3f6, 0x3fa, 0x3fe, 0x402, 0x407, 0x40a, 
			 0x40d, 0x413, 0x41b, 0x420, 0x423, 0x429, 0x434, 0x44b, 0x44f, 0x457, 
			 0x45d, 0x471, 0x475, 0x482, 0x486, 0x489, 0x490, 0x498, 0x4a2, 0x4a9, 
			 0x4b6, 0x4c2, 0x4c7, 0x4ce, 0x4d1, 0x4d6, 0x4db, 0x4f0, 0x4f4, 0x4f9, 
			 0x504, 0x50a, 0x50e, 0x513, 0x517, 0x51c, 0x51f, 0x535, 0x53b, 0x546, 
			 0x54a, 0x54d, 0x557, 0x55d, 0x560, 0x567, 0x571, 0x575, 0x578, 0x57b, 
			 0x57f, 0x584, 0x586, 0x58a, 0x58e, 0x597, 0x5a4, 0x5ac, 0x5b2, 0x5b8, 
			 0x5bc, 0x5bf, 0x5c8, 0x5d1, 0x5d9, 0x5e4, 0x5ea, 0x5f5, 0x5f8, 0x5fd, 
			 0x60c, 0x612, 0x61b, 0x625, 0x62b, 0x633, 0x637, 0x63b, 0x640, 0x645, 
			 0x64c, 0x64e, 0x653, 0x657, 0x665, 0x66b, 0x67d, 0x67f, 0x689, 0x68e, 
			 0x695, 0x69b, 0x6a0, 0x6a6, 0x6ad, 0x6b1, 0x6b3, 0x6b5, 0x6bc, 0x6bf, 
			 0x6c2, 0x6c5, 0x6ca, 0x6ce, 0x6d1, 0x6d5, 0x6d9, 0x6de, 0x6e1, 0x6e3, 
			 0x6e7, 0x6ee, 0x6f4, 0x6f8, 0x6fe, 0x703, 0x705, 0x70b, 0x70f, 0x715, 
			 0x71c, 0x720, 0x722, 0x724, 0x72b, 0x735, 0x739, 0x73b, 0x73d, 0x741, 
			 0x744, 0x74a, 0x754, 0x758, 0x75d, 0x760, 0x765, 0x76b, 0x76f, 0x772, 
			 0x775, 0x779, 0x77c, 0x781, 0x784, 0x787, 0x78b, 0x790, 0x79a, 0x7a1, 
			 0x7a6, 0x7aa, 0x7af, 0x7b5, 0x7b9, 0x7bf, 0x7c5, 0x7c9, 0x7ce, 0x7d4, 
			 0x7d8, 0x7db, 0x7df, 0x7e2, 0x7e4, 0x7e7, 0x7f1, 0x7f6, 0x7f8, 0x7fb, 
			 0x7fe, 0x801, 0x80a, 0x814, 0x819, 0x81c, 0x820, 0x823, 0x826, 0x82a, 
			 0x833, 0x841, 0x847, 0x84b, 0x84f, 0x853, 0x857, 0x85b, 0x85f, 0x863, 
			 0x866, 0x86a, 0x875, 0x879, 0x880, 0x884, 0x889, 0x88e, 0x895, 0x899, 
			 0x8a3, 0x8b3, 0x8b8, 0x8bc, 0x8bf, 0x8c3, 0x8c9, 0x8cc, 0x8d0, 0x8da, 
			 0x8dd, 0x8e5, 0x8ea, 0x8ef, 0x8f7, 0x8fe, 0x902, 0x909, 0x90f, 0x913, 
			 0x91a, 0x923, 0x927, 0x92a, 0x93a, 0x941, 0x94a, 0x950, 0x954, 0x957, 
			 0x95b, 0x95f, 0x964, 0x96b, 0x971, 0x975, 0x97e, 0x9ba, 0x9c3, 
	};

	_serializedATN.insert(_serializedATN.end(), serializedATNSegment0,
		serializedATNSegment0 + sizeof(serializedATNSegment0) / sizeof(serializedATNSegment0[0]));
	_serializedATN.insert(_serializedATN.end(), serializedATNSegment1,
		serializedATNSegment1 + sizeof(serializedATNSegment1) / sizeof(serializedATNSegment1[0]));


	atn::ATNDeserializer deserializer;
	_atn = deserializer.deserialize(_serializedATN);

	size_t count = _atn.getNumberOfDecisions();
	_decisionToDFA.reserve(count);
	for (size_t i = 0; i < count; i++)
	{ 
		_decisionToDFA.emplace_back(_atn.getDecisionState(i), i);
	}
}

CPP14Parser::Initializer CPP14Parser::_init;
